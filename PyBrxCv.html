<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PyBrxCv.pyi</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: Consolas, monospace;
            margin: 2em;
        }
        a {
            color: #569cd6;
        }
        .class {
            margin-bottom: 1em;
        }
        summary {
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }
        details {
            margin-left: 0.5em;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            padding: 0.5em;
        }
        code {
            display: block;
            margin: 0.3em 0;
            white-space: pre;
            background-color: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4em 0.6em;
            border-left: 4px solid #007acc;
            font-size: 1.2em;
        }
        .kw {
            color: #569cd6;
            font-weight: bold;
        }
        h1 {
            color: #569cd6;
        }
        .tag {
            background: #007acc;
            color: #fff;
            border-radius: 4px;
            padding: 0.1em 0.5em;
            font-size: 0.9em;
            margin-left: 0.5em;
        }
        .toc {
            margin-bottom: 2em;
        }
    </style>
</head>
<body>
    <h1>PyBrxCv.pyi</h1>
    <div class="toc">
        <h2>Classes</h2>
        <ul>
            <li><a href="#ArcParameterType">ArcParameterType</a></li>
            <li><a href="#ArcType">ArcType</a></li>
            <li><a href="#BlockAttachment">BlockAttachment</a></li>
            <li><a href="#BorderType">BorderType</a></li>
            <li><a href="#BreaklineIntersectionElevation">BreaklineIntersectionElevation</a></li>
            <li><a href="#Civil3dAlignmentType">Civil3dAlignmentType</a></li>
            <li><a href="#Civil3dEntityType">Civil3dEntityType</a></li>
            <li><a href="#Civil3dLabels">Civil3dLabels</a></li>
            <li><a href="#Civil3dProfileType">Civil3dProfileType</a></li>
            <li><a href="#CustomSymbol">CustomSymbol</a></li>
            <li><a href="#CvAttribVariant">CvAttribVariant</a></li>
            <li><a href="#CvCivil3dConverter">CvCivil3dConverter</a></li>
            <li><a href="#CvCivil3dEntityInfo">CvCivil3dEntityInfo</a></li>
            <li><a href="#CvDataType">CvDataType</a></li>
            <li><a href="#CvDb3dAlignment">CvDb3dAlignment</a></li>
            <li><a href="#CvDbCurve">CvDbCurve</a></li>
            <li><a href="#CvDbCurveLabelStyleManager">CvDbCurveLabelStyleManager</a></li>
            <li><a href="#CvDbEntity">CvDbEntity</a></li>
            <li><a href="#CvDbFileFormatManager">CvDbFileFormatManager</a></li>
            <li><a href="#CvDbGrading">CvDbGrading</a></li>
            <li><a href="#CvDbHAlignment">CvDbHAlignment</a></li>
            <li><a href="#CvDbHAlignmentArc">CvDbHAlignmentArc</a></li>
            <li><a href="#CvDbHAlignmentCurve">CvDbHAlignmentCurve</a></li>
            <li><a href="#CvDbHAlignmentElement">CvDbHAlignmentElement</a></li>
            <li><a href="#CvDbHAlignmentLine">CvDbHAlignmentLine</a></li>
            <li><a href="#CvDbHAlignmentPI">CvDbHAlignmentPI</a></li>
            <li><a href="#CvDbHAlignmentSCS">CvDbHAlignmentSCS</a></li>
            <li><a href="#CvDbHAlignmentSSCSS">CvDbHAlignmentSSCSS</a></li>
            <li><a href="#CvDbHAlignmentSTS">CvDbHAlignmentSTS</a></li>
            <li><a href="#CvDbHAlignmentSpiral">CvDbHAlignmentSpiral</a></li>
            <li><a href="#CvDbLabelStyle">CvDbLabelStyle</a></li>
            <li><a href="#CvDbLabelStyleArrow">CvDbLabelStyleArrow</a></li>
            <li><a href="#CvDbLabelStyleBlock">CvDbLabelStyleBlock</a></li>
            <li><a href="#CvDbLabelStyleComponent">CvDbLabelStyleComponent</a></li>
            <li><a href="#CvDbLabelStyleLine">CvDbLabelStyleLine</a></li>
            <li><a href="#CvDbLabelStyleText">CvDbLabelStyleText</a></li>
            <li><a href="#CvDbLineLabelStyleManager">CvDbLineLabelStyleManager</a></li>
            <li><a href="#CvDbObject">CvDbObject</a></li>
            <li><a href="#CvDbObjectManager">CvDbObjectManager</a></li>
            <li><a href="#CvDbPoint">CvDbPoint</a></li>
            <li><a href="#CvDbPointGroup">CvDbPointGroup</a></li>
            <li><a href="#CvDbPointGroupManager">CvDbPointGroupManager</a></li>
            <li><a href="#CvDbPointLabelStyleManager">CvDbPointLabelStyleManager</a></li>
            <li><a href="#CvDbPointReferencedEntity">CvDbPointReferencedEntity</a></li>
            <li><a href="#CvDbStyle">CvDbStyle</a></li>
            <li><a href="#CvDbStyleManager">CvDbStyleManager</a></li>
            <li><a href="#CvDbStylePartDisplaySettings">CvDbStylePartDisplaySettings</a></li>
            <li><a href="#CvDbSubObject">CvDbSubObject</a></li>
            <li><a href="#CvDbSurfaceContourLabelStyleManager">CvDbSurfaceContourLabelStyleManager</a></li>
            <li><a href="#CvDbSurfaceElevationLabelStyleManager">CvDbSurfaceElevationLabelStyleManager</a></li>
            <li><a href="#CvDbSurfaceSlopeLabelStyleManager">CvDbSurfaceSlopeLabelStyleManager</a></li>
            <li><a href="#CvDbSymbolStyle">CvDbSymbolStyle</a></li>
            <li><a href="#CvDbSymbolStyleManager">CvDbSymbolStyleManager</a></li>
            <li><a href="#CvDbTinSurface">CvDbTinSurface</a></li>
            <li><a href="#CvDbTinSurfaceBoundary">CvDbTinSurfaceBoundary</a></li>
            <li><a href="#CvDbTinSurfaceBreakline">CvDbTinSurfaceBreakline</a></li>
            <li><a href="#CvDbTinSurfaceConstraint">CvDbTinSurfaceConstraint</a></li>
            <li><a href="#CvDbTinSurfaceDefinition">CvDbTinSurfaceDefinition</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionAddDrawingObjects">CvDbTinSurfaceDefinitionAddDrawingObjects</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionAddFromFiles">CvDbTinSurfaceDefinitionAddFromFiles</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionAddFromPointClouds">CvDbTinSurfaceDefinitionAddFromPointClouds</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionAddLine">CvDbTinSurfaceDefinitionAddLine</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionAddLines">CvDbTinSurfaceDefinitionAddLines</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionAddPoint">CvDbTinSurfaceDefinitionAddPoint</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionAddPointGroups">CvDbTinSurfaceDefinitionAddPointGroups</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionAddPoints">CvDbTinSurfaceDefinitionAddPoints</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionCreateFromC3D">CvDbTinSurfaceDefinitionCreateFromC3D</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionCreateFromFaces">CvDbTinSurfaceDefinitionCreateFromFaces</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionCreateFromLandXML">CvDbTinSurfaceDefinitionCreateFromLandXML</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionDeleteEdge">CvDbTinSurfaceDefinitionDeleteEdge</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionDeleteEdges">CvDbTinSurfaceDefinitionDeleteEdges</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionDeletePoint">CvDbTinSurfaceDefinitionDeletePoint</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionGroupDefs">CvDbTinSurfaceDefinitionGroupDefs</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionModifyPointElevation">CvDbTinSurfaceDefinitionModifyPointElevation</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionModifyPointsElevation">CvDbTinSurfaceDefinitionModifyPointsElevation</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionModifyPointsElevations">CvDbTinSurfaceDefinitionModifyPointsElevations</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionMovePoint">CvDbTinSurfaceDefinitionMovePoint</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionMovePoints">CvDbTinSurfaceDefinitionMovePoints</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionRemoveElevations">CvDbTinSurfaceDefinitionRemoveElevations</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionRemoveOuterEdges">CvDbTinSurfaceDefinitionRemoveOuterEdges</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionRiseLower">CvDbTinSurfaceDefinitionRiseLower</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionSwapEdge">CvDbTinSurfaceDefinitionSwapEdge</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionTransform">CvDbTinSurfaceDefinitionTransform</a></li>
            <li><a href="#CvDbTinSurfaceDefinitionTrianglesVisibility">CvDbTinSurfaceDefinitionTrianglesVisibility</a></li>
            <li><a href="#CvDbTinSurfaceWall">CvDbTinSurfaceWall</a></li>
            <li><a href="#CvDbVAlignment">CvDbVAlignment</a></li>
            <li><a href="#CvDbVAlignmentArc">CvDbVAlignmentArc</a></li>
            <li><a href="#CvDbVAlignmentCurve">CvDbVAlignmentCurve</a></li>
            <li><a href="#CvDbVAlignmentElement">CvDbVAlignmentElement</a></li>
            <li><a href="#CvDbVAlignmentPVI">CvDbVAlignmentPVI</a></li>
            <li><a href="#CvDbVAlignmentParabola">CvDbVAlignmentParabola</a></li>
            <li><a href="#CvDbVAlignmentTangent">CvDbVAlignmentTangent</a></li>
            <li><a href="#CvDbVAlignmentView">CvDbVAlignmentView</a></li>
            <li><a href="#CvDbView">CvDbView</a></li>
            <li><a href="#CvDbVolumeSurface">CvDbVolumeSurface</a></li>
            <li><a href="#CvGradingRule">CvGradingRule</a></li>
            <li><a href="#CvGradingSlopeOffsetRule">CvGradingSlopeOffsetRule</a></li>
            <li><a href="#CvGradingSlopeSurfaceRule">CvGradingSlopeSurfaceRule</a></li>
            <li><a href="#CvStationEquation">CvStationEquation</a></li>
            <li><a href="#CvStationEquations">CvStationEquations</a></li>
            <li><a href="#CvTinPoint">CvTinPoint</a></li>
            <li><a href="#CvTinTriangle">CvTinTriangle</a></li>
            <li><a href="#DisplayMode">DisplayMode</a></li>
            <li><a href="#DisplayOrientation">DisplayOrientation</a></li>
            <li><a href="#DrawingObjectType">DrawingObjectType</a></li>
            <li><a href="#ForcedInsertion">ForcedInsertion</a></li>
            <li><a href="#GradingCalculationMethod">GradingCalculationMethod</a></li>
            <li><a href="#GradingSide">GradingSide</a></li>
            <li><a href="#GradingSlopeFormat">GradingSlopeFormat</a></li>
            <li><a href="#GradingStatus">GradingStatus</a></li>
            <li><a href="#GradingType">GradingType</a></li>
            <li><a href="#GradingVisualStyle">GradingVisualStyle</a></li>
            <li><a href="#HAlignmentElementType">HAlignmentElementType</a></li>
            <li><a href="#HAlignmentParameterConstraint">HAlignmentParameterConstraint</a></li>
            <li><a href="#HAlignmentTangencyConstraint">HAlignmentTangencyConstraint</a></li>
            <li><a href="#HAlignmentVisualStyle">HAlignmentVisualStyle</a></li>
            <li><a href="#LabelAnchor">LabelAnchor</a></li>
            <li><a href="#LeaderAttachment">LeaderAttachment</a></li>
            <li><a href="#LeaderType">LeaderType</a></li>
            <li><a href="#LengthType">LengthType</a></li>
            <li><a href="#OrientationRef">OrientationRef</a></li>
            <li><a href="#ScalingType">ScalingType</a></li>
            <li><a href="#SpiralCurveType">SpiralCurveType</a></li>
            <li><a href="#SpiralDefinitionType">SpiralDefinitionType</a></li>
            <li><a href="#SpiralDefinitionTypeSpiral">SpiralDefinitionTypeSpiral</a></li>
            <li><a href="#SpiralDirectionType">SpiralDirectionType</a></li>
            <li><a href="#SpiralParameterType">SpiralParameterType</a></li>
            <li><a href="#SpiralParameterType2">SpiralParameterType2</a></li>
            <li><a href="#StationEquationType">StationEquationType</a></li>
            <li><a href="#StyleManagerType">StyleManagerType</a></li>
            <li><a href="#SymbolType">SymbolType</a></li>
            <li><a href="#TinBoundaryType">TinBoundaryType</a></li>
            <li><a href="#TinBreaklineType">TinBreaklineType</a></li>
            <li><a href="#TinConstraintType">TinConstraintType</a></li>
            <li><a href="#TinIntersectionElevation">TinIntersectionElevation</a></li>
            <li><a href="#TinSurfaceDefinitionType">TinSurfaceDefinitionType</a></li>
            <li><a href="#TinSurfaceIntersectType">TinSurfaceIntersectType</a></li>
            <li><a href="#TinSurfaceMeshType">TinSurfaceMeshType</a></li>
            <li><a href="#TinSurfaceSolidType">TinSurfaceSolidType</a></li>
            <li><a href="#TinSurfaceStyle">TinSurfaceStyle</a></li>
            <li><a href="#TinWallSide">TinWallSide</a></li>
            <li><a href="#TinWallType">TinWallType</a></li>
            <li><a href="#VAlignmentElementType">VAlignmentElementType</a></li>
            <li><a href="#VAlignmentParameterConstraint">VAlignmentParameterConstraint</a></li>
            <li><a href="#VAlignmentTangencyConstraint">VAlignmentTangencyConstraint</a></li>
            <li><a href="#VAlignmentType">VAlignmentType</a></li>
            <li><a href="#VAlignmentVisualStyle">VAlignmentVisualStyle</a></li>
            <li><a href="#VolumeSurfaceType">VolumeSurfaceType</a></li>
        </ul>
    </div>

    <div class="class" id="ArcParameterType">
        <details>
            <summary>class ArcParameterType <span class="tag">Class</span></summary>
            <code>eRadius: ClassVar[Self]</code>
            <code>eDegreeOfCurve: ClassVar[Self]</code>
            <code>eTangentLength: ClassVar[Self]</code>
            <code>eChordLength: ClassVar[Self]</code>
            <code>eCurveLength: ClassVar[Self]</code>
            <code>eExternalDist: ClassVar[Self]</code>
            <code>eMiddleOrdinate: ClassVar[Self]</code>
            <code>eCurveAngle: ClassVar[Self]</code>
            <code>eCurveThroughPoint: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ArcType">
        <details>
            <summary>class ArcType <span class="tag">Class</span></summary>
            <code>eCompound: ClassVar[Self]</code>
            <code>eReverse: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="BlockAttachment">
        <details>
            <summary>class BlockAttachment <span class="tag">Class</span></summary>
            <code>eBlockAttachmentTopLeft: ClassVar[Self]</code>
            <code>eBlockAttachmentTopCenter: ClassVar[Self]</code>
            <code>eBlockAttachmentTopRight: ClassVar[Self]</code>
            <code>eBlockAttachmentMiddleLeft: ClassVar[Self]</code>
            <code>eBlockAttachmentMiddleCenter: ClassVar[Self]</code>
            <code>eBlockAttachmentMiddleRight: ClassVar[Self]</code>
            <code>eBlockAttachmentBottomLeft: ClassVar[Self]</code>
            <code>eBlockAttachmentBottomCenter: ClassVar[Self]</code>
            <code>eBlockAttachmentBottomRight: ClassVar[Self]</code>
            <code>eBlockAttachmentInsertionPoint: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="BorderType">
        <details>
            <summary>class BorderType <span class="tag">Class</span></summary>
            <code>eBorderTypeRectangular: ClassVar[Self]</code>
            <code>eBorderTypeRoundedRectangular: ClassVar[Self]</code>
            <code>eBorderTypeCircular: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="BreaklineIntersectionElevation">
        <details>
            <summary>class BreaklineIntersectionElevation <span class="tag">Class</span></summary>
            <code>eTinNotAllowed: ClassVar[Self]</code>
            <code>eTinElevationMin: ClassVar[Self]</code>
            <code>eTinElevationMax: ClassVar[Self]</code>
            <code>eTinElevationMid: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Civil3dAlignmentType">
        <details>
            <summary>class Civil3dAlignmentType <span class="tag">Class</span></summary>
            <code>eNotAlignment: ClassVar[Self]</code>
            <code>eCenterline: ClassVar[Self]</code>
            <code>eOffset: ClassVar[Self]</code>
            <code>eCurbReturn: ClassVar[Self]</code>
            <code>eRail: ClassVar[Self]</code>
            <code>eMiscellaneous: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Civil3dEntityType">
        <details>
            <summary>class Civil3dEntityType <span class="tag">Class</span></summary>
            <code>eNoEntity: ClassVar[Self]</code>
            <code>eAlignment: ClassVar[Self]</code>
            <code>eProfile: ClassVar[Self]</code>
            <code>eTinSurface: ClassVar[Self]</code>
            <code>eProfileView: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Civil3dLabels">
        <details>
            <summary>class Civil3dLabels <span class="tag">Class</span></summary>
            <code>eNoLabels: ClassVar[Self]</code>
            <code>eSurfaceLabels: ClassVar[Self]</code>
            <code>eAlignmentsLabels: ClassVar[Self]</code>
            <code>eUnattachedLabels: ClassVar[Self]</code>
            <code>eDefaultLabels: ClassVar[Self]</code>
            <code>eAllLabels: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Civil3dProfileType">
        <details>
            <summary>class Civil3dProfileType <span class="tag">Class</span></summary>
            <code>eNotProfile: ClassVar[Self]</code>
            <code>eLayout: ClassVar[Self]</code>
            <code>eStaticSurface: ClassVar[Self]</code>
            <code>eDynamicSurface: ClassVar[Self]</code>
            <code>eQuick: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="CustomSymbol">
        <details>
            <summary>class CustomSymbol <span class="tag">Class</span></summary>
            <code>eCustomSymbolSpotPoint: ClassVar[Self]</code>
            <code>eCustomSymbolSpotEmpty: ClassVar[Self]</code>
            <code>eCustomSymbolSpotCross: ClassVar[Self]</code>
            <code>eCustomSymbolSpotCross45: ClassVar[Self]</code>
            <code>eCustomSymbolSpotVerticalLine: ClassVar[Self]</code>
            <code>eCustomSymbolFrameCircle: ClassVar[Self]</code>
            <code>eCustomSymbolFrameSquare: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="CvAttribVariant">
        <details>
            <summary>class CvAttribVariant <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, val: str) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, val: PyBrxCv.CvDataType) -&gt; None</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> getAngle(self) -&gt; float</code>
            <code><span class="kw">def</span> getArea(self) -&gt; float</code>
            <code><span class="kw">def</span> getAzimuth(self) -&gt; float</code>
            <code><span class="kw">def</span> getBool(self) -&gt; bool</code>
            <code><span class="kw">def</span> getDirection(self) -&gt; float</code>
            <code><span class="kw">def</span> getDistance(self) -&gt; float</code>
            <code><span class="kw">def</span> getDouble(self) -&gt; float</code>
            <code><span class="kw">def</span> getElevation(self) -&gt; float</code>
            <code><span class="kw">def</span> getInteger(self) -&gt; int</code>
            <code><span class="kw">def</span> getLatitude(self) -&gt; float</code>
            <code><span class="kw">def</span> getLinear(self) -&gt; float</code>
            <code><span class="kw">def</span> getLongitude(self) -&gt; float</code>
            <code><span class="kw">def</span> getRatio(self) -&gt; float</code>
            <code><span class="kw">def</span> getRotation(self) -&gt; float</code>
            <code><span class="kw">def</span> getSlope(self) -&gt; float</code>
            <code><span class="kw">def</span> getSpeed(self) -&gt; float</code>
            <code><span class="kw">def</span> getStation(self) -&gt; float</code>
            <code><span class="kw">def</span> getString(self) -&gt; str</code>
            <code><span class="kw">def</span> getVolume(self) -&gt; float</code>
            <code><span class="kw">def</span> isValid(self) -&gt; bool</code>
            <code><span class="kw">def</span> setAngle(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setArea(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setAzimuth(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setBool(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setDirection(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setDistance(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setElevation(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setInteger(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setLatitude(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setLinear(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setLongitude(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setRatio(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setRotation(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setSlope(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setSpeed(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setStation(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setString(self, val: str) -&gt; None</code>
            <code><span class="kw">def</span> setVolume(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> type(self) -&gt; CvDataType</code>
        </details>
    </div>

    <div class="class" id="CvCivil3dConverter">
        <details>
            <summary>class CvCivil3dConverter <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, sourceDb: PyDb.Database, targetDb: PyDb.Database, doLabels: PyBrxCv.Civil3dLabels) -&gt; None</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> attachedLabels(self, civilEntity: PyBrxCv.CvCivil3dEntityInfo) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> convert(self, entitiesToConvert: list) -&gt; list</code>
            <code><span class="kw">def</span> getCivilEntities(self) -&gt; list[PyBrxCv.CvCivil3dEntityInfo]</code>
            <code><span class="kw">def</span> getInsertedEntities(self) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> unattachedLabels(self) -&gt; list[PyDb.ObjectId]</code>
        </details>
    </div>

    <div class="class" id="CvCivil3dEntityInfo">
        <details>
            <summary>class CvCivil3dEntityInfo <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> alignmentType(self) -&gt; Civil3dAlignmentType</code>
            <code><span class="kw">def</span> baseAlignment(self) -&gt; CvCivil3dEntityInfo</code>
            <code><span class="kw">def</span> baseSurface(self) -&gt; CvCivil3dEntityInfo</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> description(self) -&gt; str</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool</code>
            <code><span class="kw">def</span> name(self) -&gt; str</code>
            <code><span class="kw">def</span> objectId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> profileType(self) -&gt; Civil3dProfileType</code>
            <code><span class="kw">def</span> profiles(self) -&gt; list[PyBrxCv.CvCivil3dEntityInfo]</code>
            <code><span class="kw">def</span> type(self) -&gt; Civil3dEntityType</code>
        </details>
    </div>

    <div class="class" id="CvDataType">
        <details>
            <summary>class CvDataType <span class="tag">Class</span></summary>
            <code>eBrxCvDataTypeNone: ClassVar[Self]</code>
            <code>eBrxCvDataTypeBool: ClassVar[Self]</code>
            <code>eBrxCvDataTypeString: ClassVar[Self]</code>
            <code>eBrxCvDataTypeInteger: ClassVar[Self]</code>
            <code>eBrxCvDataTypeDate: ClassVar[Self]</code>
            <code>eBrxCvDataTypeLinear: ClassVar[Self]</code>
            <code>eBrxCvDataTypeStation: ClassVar[Self]</code>
            <code>eBrxCvDataTypeAngle: ClassVar[Self]</code>
            <code>eBrxCvDataTypeRatio: ClassVar[Self]</code>
            <code>eBrxCvDataTypeArea: ClassVar[Self]</code>
            <code>eBrxCvDataTypeAzimuth: ClassVar[Self]</code>
            <code>eBrxCvDataTypeDirection: ClassVar[Self]</code>
            <code>eBrxCvDataTypeDistance: ClassVar[Self]</code>
            <code>eBrxCvDataTypeElevation: ClassVar[Self]</code>
            <code>eBrxCvDataTypeSlope: ClassVar[Self]</code>
            <code>eBrxCvDataTypeLatitude: ClassVar[Self]</code>
            <code>eBrxCvDataTypeLongitude: ClassVar[Self]</code>
            <code>eBrxCvDataTypeRotation: ClassVar[Self]</code>
            <code>eBrxCvDataTypeVolume: ClassVar[Self]</code>
            <code>eBrxCvDataTypeSpeed: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="CvDb3dAlignment">
        <details>
            <summary>class CvDb3dAlignment <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> baseHAlignment(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDb3dAlignment</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDb3dAlignment</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getPointsArray(self) -&gt; list[PyGe.Point3d]</code>
            <code><span class="kw">def</span> length(self) -&gt; float</code>
            <code><span class="kw">def</span> setBaseHAlignment(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> setVAlignment(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> vAlignment(self) -&gt; PyDb.ObjectId</code>
        </details>
    </div>

    <div class="class" id="CvDbCurve">
        <details>
            <summary>class CvDbCurve <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbCurve</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbCurve</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> description(self) -&gt; str</code>
            <code><span class="kw">def</span> name(self) -&gt; str</code>
            <code><span class="kw">def</span> setDescription(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> setName(self, val: str) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbCurveLabelStyleManager">
        <details>
            <summary>class CvDbCurveLabelStyleManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbCurveLabelStyleManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbCurveLabelStyleManager</code>
            <code><span class="kw">def</span> createLabelStyle(self, name: str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManagerId(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> managerId() -&gt; str</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbCurveLabelStyleManager</code>
        </details>
    </div>

    <div class="class" id="CvDbEntity">
        <details>
            <summary>class CvDbEntity <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbEntity</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbEntity</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> description(self) -&gt; str</code>
            <code><span class="kw">def</span> name(self) -&gt; str</code>
            <code><span class="kw">def</span> setDescription(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> setName(self, val: str) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbFileFormatManager">
        <details>
            <summary>class CvDbFileFormatManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> allFileFormats(self) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> applicableFileFormats(self, val: str) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbFileFormatManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbFileFormatManager</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManager(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbFileFormatManager</code>
        </details>
    </div>

    <div class="class" id="CvDbGrading">
        <details>
            <summary>class CvDbGrading <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbGrading</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbGrading</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getCalculationCurve(self) -&gt; PyGe.Curve3d</code>
            <code><span class="kw">def</span> getCalculationMethod(self) -&gt; GradingCalculationMethod</code>
            <code><span class="kw">def</span> getGradingVisualStyle(self) -&gt; GradingVisualStyle</code>
            <code><span class="kw">def</span> getInputEntityId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> getIsAssociative(self) -&gt; bool</code>
            <code><span class="kw">def</span> getIsDrawInfill(self) -&gt; bool</code>
            <code><span class="kw">def</span> getMidOrdinateDist(self) -&gt; float</code>
            <code><span class="kw">def</span> getRegionEnd(self) -&gt; float</code>
            <code><span class="kw">def</span> getRegionStart(self) -&gt; float</code>
            <code><span class="kw">def</span> getSegmentMaxAngle(self) -&gt; float</code>
            <code><span class="kw">def</span> getSegmentMaxLength(self) -&gt; float</code>
            <code><span class="kw">def</span> isClosed(self) -&gt; bool</code>
            <code><span class="kw">def</span> resultDayLight(self) -&gt; list[list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> rule(self) -&gt; CvGradingRule</code>
            <code><span class="kw">def</span> setCalculationMethod(self, val: PyBrxCv.GradingCalculationMethod) -&gt; bool</code>
            <code><span class="kw">def</span> setDrawInfill(self, val: bool) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> setGradingVisualStyle(self, val: PyBrxCv.GradingVisualStyle) -&gt; bool</code>
            <code><span class="kw">def</span> setInputData(self, curve: PyGe.Curve3d) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> setInputDataId(self, id: PyDb.ObjectId) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> setIsAssociative(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setMidOrdinateDist(self, val: float) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> setRegionEnd(self, val: float) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> setRegionStart(self, val: float) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> setRule(self, val: PyBrxCv.CvGradingRule) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> setSegmentMaxAngle(self, val: float) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> setSegmentMaxLength(self, val: float) -&gt; GradingStatus</code>
            <code><span class="kw">def</span> targetSurface(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> update(self, val: bool) -&gt; GradingStatus</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignment">
        <details>
            <summary>class CvDbHAlignment <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addArcAuto(self, prevId: int, nextId: int) -&gt; int</code>
            <code><span class="kw">def</span> addArcBetween(self, prevId: int, nextId: int, passThroughPoint: PyGe.Point2d) -&gt; int</code>
            <code><span class="kw">def</span> addArcBetween(self, prevId: int, nextId: int, parameter: float, paramType: PyBrxCv.EArcParameterType, isGreaterThan180: bool, arcType: PyBrxCv.ArcType) -&gt; int</code>
            <code><span class="kw">def</span> addArcBetween(*args) -&gt; int</code>
            <code><span class="kw">def</span> addArcFixed(self, center: PyGe.Point2d, radius: float, clockwise: bool) -&gt; int</code>
            <code><span class="kw">def</span> addArcFixed(self, startPoint: PyGe.Point2d, midPoint: PyGe.Point2d, endPoint: PyGe.Point2d) -&gt; int</code>
            <code><span class="kw">def</span> addArcFixed(*args) -&gt; int</code>
            <code><span class="kw">def</span> addArcFrom(self, prevId: int, passThroughPoint: PyGe.Point2d) -&gt; int</code>
            <code><span class="kw">def</span> addArcFrom(self, prevId: int, passThroughPoint: PyGe.Point2d, direction: PyGe.Vector2d) -&gt; int</code>
            <code><span class="kw">def</span> addArcFrom(self, prevId: int, passThroughPoint: PyGe.Point2d, radius: float, isGreaterThan180: bool, arcType: PyBrxCv.ArcType) -&gt; int</code>
            <code><span class="kw">def</span> addArcFrom(self, prevId: int, radius: float, paramValue: float, paramType: PyBrxCv.ArcType, isClockwise: bool) -&gt; int</code>
            <code><span class="kw">def</span> addArcFrom(*args) -&gt; int</code>
            <code><span class="kw">def</span> addArcTo(self, nextId: int, passThroughPoint: PyGe.Point2d) -&gt; int</code>
            <code><span class="kw">def</span> addArcTo(self, nextId: int, passThroughPoint: PyGe.Point2d, direction: PyGe.Vector2d) -&gt; int</code>
            <code><span class="kw">def</span> addArcTo(self, nextId: int, passThroughPoint: PyGe.Point2d, radius: float, isGreaterThan180: bool, arcType: PyBrxCv.ArcType) -&gt; int</code>
            <code><span class="kw">def</span> addArcTo(self, nextId: int, radius: float, paramValue: float, paramType: PyBrxCv.ArcType, isClockwise: bool) -&gt; int</code>
            <code><span class="kw">def</span> addArcTo(*args) -&gt; int</code>
            <code><span class="kw">def</span> addCSSTo(self, nextId: int, spiral1Param: float, spiral2Param: float, spiralParamType, radius: float, passThroughPoint: PyGe.Point2d, spiralDef: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addCSTo(self, nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float, passThroughPoint: PyGe.Point2d, isGreaterThan180: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addCSTo(self, nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float, arcLength: float, isClockwise: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addCSTo(*args) -&gt; int</code>
            <code><span class="kw">def</span> addLineBetween(self, prevId: int, nextId: int) -&gt; int</code>
            <code><span class="kw">def</span> addLineFixed(self, prevId: int, length: float) -&gt; int</code>
            <code><span class="kw">def</span> addLineFixed(self, start: PyGe.Point2d, end: PyGe.Point2d) -&gt; int</code>
            <code><span class="kw">def</span> addLineFixed(*args) -&gt; int</code>
            <code><span class="kw">def</span> addLineFrom(self, prevId: int, length: float) -&gt; int</code>
            <code><span class="kw">def</span> addLineFrom(self, prevId: int, to: PyGe.Point2d) -&gt; int</code>
            <code><span class="kw">def</span> addLineFrom(*args) -&gt; int</code>
            <code><span class="kw">def</span> addLineTo(self, nextId: int, length: float) -&gt; int</code>
            <code><span class="kw">def</span> addLineTo(self, nextId: int, to: PyGe.Point2d) -&gt; int</code>
            <code><span class="kw">def</span> addLineTo(*args) -&gt; int</code>
            <code><span class="kw">def</span> addSCFrom(self, prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float, passThroughPoint: PyGe.Point2d, isGreaterThan180: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSCFrom(self, prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float, arcLength: float, isClockwise: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSCFrom(*args) -&gt; int</code>
            <code><span class="kw">def</span> addSCSAuto(self, prevId: int, nextId: int) -&gt; int</code>
            <code><span class="kw">def</span> addSCSBetween(self, prevId: int, nextId: int, spiral1: float, spiral2: float, spiralType: PyBrxCv.SpiralParameterType, radius: float, spiralDef: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSSBetween(self, prevId: int, nextId: int, spiralRatio: float, spiralParamType: PyBrxCv.SpiralParameterType, spiralDef: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSSCFrom(self, prevId: int, spiral1Param: float, spiral2Param: float, spiralParamType, radius: float, passThroughPoint: PyGe.Point2d, spiralDef: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSTFrom(self, prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, passThroughPoint: PyGe.Point2d, spiralDefinition: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSTFrom(self, prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, tangentLength: float, spiralDefinition: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSTFrom(*args) -&gt; int</code>
            <code><span class="kw">def</span> addSTSBetween(self, prevId: int, nextId: int, spiral1Param: float, spiral2Param: float, spiralType: PyBrxCv.SpiralParameterType, spiralDef: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSpiralBetween(self, prevId: int, nextId: int, spiralDef: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSpiralFrom(self, prevId: int, radius: float, length: float, isClockwise: bool, spiralDef: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addSpiralTo(self, nextId: int, radius: float, length: float, isClockwise: bool, spiralDef: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addTSTo(self, nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, passThroughPoint: PyGe.Point2d, spiralDefinition: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addTSTo(self, nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, tangentLength: float, spiralDefinition: PyBrxCv.SpiralDefinitionType) -&gt; int</code>
            <code><span class="kw">def</span> addTSTo(*args) -&gt; int</code>
            <code><span class="kw">def</span> alignment3dAt(self, index: int) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> alignment3dCount(self) -&gt; int</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignment</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbHAlignment</code>
            <code><span class="kw">def</span> curveAtPI(self, pi: PyBrxCv.CvDbHAlignmentPI) -&gt; int</code>
            <code><span class="kw">def</span> curveElementColor(self) -&gt; int</code>
            <code><span class="kw">def</span> deleteElement(self, id: int) -&gt; bool</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> elementAtId(self, Id: int) -&gt; CvDbHAlignmentElement</code>
            <code><span class="kw">def</span> elementAtStation(self, station: float) -&gt; CvDbHAlignmentElement</code>
            <code><span class="kw">def</span> elementCount(self) -&gt; int</code>
            <code><span class="kw">def</span> elementExtensionColor(self) -&gt; int</code>
            <code><span class="kw">def</span> firstElementId(self) -&gt; int</code>
            <code><span class="kw">def</span> firstLineElementId(self) -&gt; int</code>
            <code><span class="kw">def</span> getElementId(self, gsMarker: int) -&gt; int</code>
            <code><span class="kw">def</span> getPIsArray(self) -&gt; list[PyBrxCv.CvDbHAlignmentPI]</code>
            <code><span class="kw">def</span> getPointAtStation(self, station: float) -&gt; tuple[bool, PyGe.Point2d]</code>
            <code><span class="kw">def</span> getRadius(self, param: float) -&gt; float</code>
            <code><span class="kw">def</span> getStationAtPoint(self, station: PyGe.Point2d) -&gt; tuple[bool, float, float]</code>
            <code><span class="kw">def</span> getStationAtPoint(self, station: PyGe.Point2d, fromStation: float, toStation: float) -&gt; tuple[bool, float, float]</code>
            <code><span class="kw">def</span> getStationAtPoint(*args) -&gt; tuple[bool, float, float]</code>
            <code><span class="kw">def</span> getUnorderedElementIds(self) -&gt; list[int]</code>
            <code><span class="kw">def</span> insertLineFixed(self, start: PyGe.Point2d, end: PyGe.Point2d, prevId: int) -&gt; int</code>
            <code><span class="kw">def</span> lastElementId(self) -&gt; int</code>
            <code><span class="kw">def</span> length(self) -&gt; float</code>
            <code><span class="kw">def</span> lineElementColor(self) -&gt; int</code>
            <code><span class="kw">def</span> nextLineElementId(self, Id: int) -&gt; int</code>
            <code><span class="kw">def</span> previousLineElementId(self, Id: int) -&gt; int</code>
            <code><span class="kw">def</span> setCurveElementColor(self, colACI: int) -&gt; bool</code>
            <code><span class="kw">def</span> setElementExtensionColor(self, colACI: int) -&gt; bool</code>
            <code><span class="kw">def</span> setLineElementColor(self, colACI: int) -&gt; bool</code>
            <code><span class="kw">def</span> setSpiralElementColor(self, colACI: int) -&gt; bool</code>
            <code><span class="kw">def</span> setStationEquations(self, val: PyBrxCv.CvStationEquations) -&gt; bool</code>
            <code><span class="kw">def</span> setStyle(self, style: int) -&gt; bool</code>
            <code><span class="kw">def</span> setTangentExtensionColor(self, colACI: int) -&gt; bool</code>
            <code><span class="kw">def</span> spiralElementColor(self) -&gt; int</code>
            <code><span class="kw">def</span> stationEquations(self) -&gt; CvStationEquations</code>
            <code><span class="kw">def</span> style(self) -&gt; int</code>
            <code><span class="kw">def</span> tangentExtensionColor(self) -&gt; int</code>
            <code><span class="kw">def</span> update(self) -&gt; bool</code>
            <code><span class="kw">def</span> verticalAlignmentAt(self, index: int) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> verticalAlignmentCount(self) -&gt; int</code>
            <code><span class="kw">def</span> verticalAlignmentViewAt(self, index: int) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> verticalAlignmentViewCount(self) -&gt; int</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentArc">
        <details>
            <summary>class CvDbHAlignmentArc <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentArc</code>
            <code><span class="kw">def</span> center(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> isClockwise(self) -&gt; bool</code>
            <code><span class="kw">def</span> isCompound(self) -&gt; bool</code>
            <code><span class="kw">def</span> isLessThan180(self) -&gt; bool</code>
            <code><span class="kw">def</span> paramLength(self) -&gt; float</code>
            <code><span class="kw">def</span> passThroughPoint1(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> passThroughPoint2(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> passThroughPoint3(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> radius(self) -&gt; float</code>
            <code><span class="kw">def</span> setCenter(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setClockwise(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setCompound(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setLessThan180(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setParamLength(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setPassThroughPoint1(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setPassThroughPoint2(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setPassThroughPoint3(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setRadius(self, val: float) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentCurve">
        <details>
            <summary>class CvDbHAlignmentCurve <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentCurve</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> endStation(self) -&gt; float</code>
            <code><span class="kw">def</span> length(self) -&gt; float</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> startStation(self) -&gt; float</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentElement">
        <details>
            <summary>class CvDbHAlignmentElement <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentElement</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> id(self) -&gt; int</code>
            <code><span class="kw">def</span> isSubentity(self) -&gt; bool</code>
            <code><span class="kw">def</span> nextId(self) -&gt; int</code>
            <code><span class="kw">def</span> parameterConstraint(self) -&gt; HAlignmentParameterConstraint</code>
            <code><span class="kw">def</span> previousId(self) -&gt; int</code>
            <code><span class="kw">def</span> setNextId(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setParameterConstraint(self, val: PyBrxCv.EParameterConstraint) -&gt; bool</code>
            <code><span class="kw">def</span> setPreviousId(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setTangencyConstraint(self, val: PyBrxCv.ETangencyConstraint) -&gt; bool</code>
            <code><span class="kw">def</span> tangencyConstraint(self) -&gt; HAlignmentTangencyConstraint</code>
            <code><span class="kw">def</span> type(self) -&gt; HAlignmentElementType</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentLine">
        <details>
            <summary>class CvDbHAlignmentLine <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentLine</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> paramLength(self) -&gt; float</code>
            <code><span class="kw">def</span> passThroughPoint1(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> passThroughPoint2(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> setParamLength(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setPassThroughPoint1(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setPassThroughPoint2(self, pt: PyGe.Point2d) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentPI">
        <details>
            <summary>class CvDbHAlignmentPI <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentPI</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> location(self) -&gt; PyGe.Point2d</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentSCS">
        <details>
            <summary>class CvDbHAlignmentSCS <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> arc(self) -&gt; CvDbHAlignmentArc</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentSCS</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> spiralIn(self) -&gt; CvDbHAlignmentSpiral</code>
            <code><span class="kw">def</span> spiralOut(self) -&gt; CvDbHAlignmentSpiral</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentSSCSS">
        <details>
            <summary>class CvDbHAlignmentSSCSS <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> arc(self) -&gt; CvDbHAlignmentArc</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentSSCSS</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> spiral1(self) -&gt; CvDbHAlignmentSpiral</code>
            <code><span class="kw">def</span> spiral2(self) -&gt; CvDbHAlignmentSpiral</code>
            <code><span class="kw">def</span> spiral3(self) -&gt; CvDbHAlignmentSpiral</code>
            <code><span class="kw">def</span> spiral4(self) -&gt; CvDbHAlignmentSpiral</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentSTS">
        <details>
            <summary>class CvDbHAlignmentSTS <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentSTS</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> line(self) -&gt; CvDbHAlignmentLine</code>
            <code><span class="kw">def</span> spiralIn(self) -&gt; CvDbHAlignmentSpiral</code>
            <code><span class="kw">def</span> spiralOut(self) -&gt; CvDbHAlignmentSpiral</code>
            <code><span class="kw">def</span> spiralRatio(self) -&gt; float</code>
        </details>
    </div>

    <div class="class" id="CvDbHAlignmentSpiral">
        <details>
            <summary>class CvDbHAlignmentSpiral <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbHAlignmentSpiral</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> endDirection(self) -&gt; float</code>
            <code><span class="kw">def</span> isCompound(self) -&gt; bool</code>
            <code><span class="kw">def</span> paramA(self) -&gt; float</code>
            <code><span class="kw">def</span> paramLength(self) -&gt; float</code>
            <code><span class="kw">def</span> radiusIn(self) -&gt; float</code>
            <code><span class="kw">def</span> radiusOut(self) -&gt; float</code>
            <code><span class="kw">def</span> setClockwise(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setCompound(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setEndDirection(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setParamA(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setParamLength(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setRadiusIn(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setRadiusOut(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setSpiralCurveType(self, val: PyBrxCv.ESpiralCurveType) -&gt; bool</code>
            <code><span class="kw">def</span> setSpiralDefinition(self, val: PyBrxCv.ESpiralDefinitionType) -&gt; bool</code>
            <code><span class="kw">def</span> spiralCurveType(self) -&gt; SpiralCurveType</code>
            <code><span class="kw">def</span> spiralDefinition(self) -&gt; SpiralDefinitionTypeSpiral</code>
            <code><span class="kw">def</span> startDirection(self) -&gt; float</code>
        </details>
    </div>

    <div class="class" id="CvDbLabelStyle">
        <details>
            <summary>class CvDbLabelStyle <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, metric: bool) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addComponent(self, val: PyBrxCv.CvDbLabelStyleComponent) -&gt; None</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbLabelStyle</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> componentAt(self, index: int) -&gt; CvDbLabelStyleComponent</code>
            <code><span class="kw">def</span> componentCount(self) -&gt; int</code>
            <code><span class="kw">def</span> components(self) -&gt; list[PyBrxCv.CvDbLabelStyleComponent]</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> draggedStateBackgroundMask(self) -&gt; bool</code>
            <code><span class="kw">def</span> draggedStateBorderAndLeaderGap(self) -&gt; float</code>
            <code><span class="kw">def</span> draggedStateBorderAndLeaderGapExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> draggedStateBorderIsVisible(self) -&gt; bool</code>
            <code><span class="kw">def</span> draggedStateBorderType(self) -&gt; BorderType</code>
            <code><span class="kw">def</span> draggedStateColor(self) -&gt; PyDb.Color</code>
            <code><span class="kw">def</span> draggedStateDisplayMode(self) -&gt; DisplayMode</code>
            <code><span class="kw">def</span> draggedStateLeaderArrowHeadSize(self) -&gt; float</code>
            <code><span class="kw">def</span> draggedStateLeaderArrowHeadSizeExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> draggedStateLeaderArrowHeadStyle(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> draggedStateLeaderAttachment(self) -&gt; LeaderAttachment</code>
            <code><span class="kw">def</span> draggedStateLeaderColor(self) -&gt; PyDb.Color</code>
            <code><span class="kw">def</span> draggedStateLeaderIsVisible(self) -&gt; bool</code>
            <code><span class="kw">def</span> draggedStateLeaderJustification(self) -&gt; bool</code>
            <code><span class="kw">def</span> draggedStateLeaderLinetype(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> draggedStateLeaderLineweight(self) -&gt; PyDb.LineWeight</code>
            <code><span class="kw">def</span> draggedStateLeaderTail(self) -&gt; bool</code>
            <code><span class="kw">def</span> draggedStateLeaderType(self) -&gt; LeaderType</code>
            <code><span class="kw">def</span> draggedStateLinetype(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> draggedStateLineweight(self) -&gt; PyDb.LineWeight</code>
            <code><span class="kw">def</span> draggedStateMaximumTextWidth(self) -&gt; float</code>
            <code><span class="kw">def</span> draggedStateMaximumTextWidthExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> draggedStateTagDisplayMode(self) -&gt; bool</code>
            <code><span class="kw">def</span> draggedStateTextHeight(self) -&gt; float</code>
            <code><span class="kw">def</span> draggedStateTextHeightExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> expressionAt(self, index: int) -&gt; tuple[str, str]</code>
            <code><span class="kw">def</span> expressionCount(self) -&gt; int</code>
            <code><span class="kw">def</span> flipAnchorsWithText(self) -&gt; bool</code>
            <code><span class="kw">def</span> forceInsideCurve(self) -&gt; bool</code>
            <code><span class="kw">def</span> forcedInsertion(self) -&gt; ForcedInsertion</code>
            <code><span class="kw">def</span> isVisible(self) -&gt; bool</code>
            <code><span class="kw">def</span> layer(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> moveComponent(self, _from: int, _to: int) -&gt; None</code>
            <code><span class="kw">def</span> orientationReference(self) -&gt; OrientationRef</code>
            <code><span class="kw">def</span> planReadable(self) -&gt; bool</code>
            <code><span class="kw">def</span> readabilityBias(self) -&gt; float</code>
            <code><span class="kw">def</span> removeComponent(self, val: int | PyBrxCv.CvDbLabelStyleComponent) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateBackgroundMask(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateBorderAndLeaderGap(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateBorderAndLeaderGapExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateBorderType(self, val: BorderType) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateBorderVisibility(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateColor(self, val: PyDb.Color) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateDisplayMode(self, val: DisplayMode) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderArrowHeadSize(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderArrowHeadSizeExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderArrowHeadStyle(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderAttachment(self, val: LeaderAttachment) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderColor(self, val: PyDb.Color) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderJustification(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderLinetype(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderLineweight(self, val: PyDb.LineWeight) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderTail(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderType(self, val: LeaderType) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLeaderVisibility(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLinetype(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateLineweight(self, val: PyDb.LineWeight) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateMaximumTextWidth(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateMaximumTextWidthExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateTagDisplayMode(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateTextHeight(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setDraggedStateTextHeightExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setExpressionAt(self, index: int, name: str, expr: str, val: PyBrxCv.DataType) -&gt; None</code>
            <code><span class="kw">def</span> setFlipAnchorsWithText(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setForceInsideCurve(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setForcedInsertion(self, val: ForcedInsertion) -&gt; None</code>
            <code><span class="kw">def</span> setLayer(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setOrientationReference(self, val: PyBrxCv.OrientationRef) -&gt; None</code>
            <code><span class="kw">def</span> setPlanReadable(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setReadabilityBias(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setTextStyle(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setVisibility(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> textStyle(self) -&gt; PyDb.ObjectId</code>
        </details>
    </div>

    <div class="class" id="CvDbLabelStyleArrow">
        <details>
            <summary>class CvDbLabelStyleArrow <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> angle(self) -&gt; float</code>
            <code><span class="kw">def</span> angleExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> arrowHeadSize(self) -&gt; float</code>
            <code><span class="kw">def</span> arrowHeadStyle(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbLabelStyleArrow</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> isFixedLength(self) -&gt; bool</code>
            <code><span class="kw">def</span> length(self) -&gt; float</code>
            <code><span class="kw">def</span> lengthExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> linetype(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> lineweight(self) -&gt; PyDb.LineWeight</code>
            <code><span class="kw">def</span> offset(self) -&gt; PyGe.Vector2d</code>
            <code><span class="kw">def</span> setAngle(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setAngleExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setArrowHeadSize(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setArrowHeadSizeExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setArrowHeadStyle(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setFixedLength(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setLength(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setLengthExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setLinetype(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setLineweight(self, val: PyDb.LineWeight) -&gt; None</code>
            <code><span class="kw">def</span> setOffset(self, val: PyGe.Vector2d) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="CvDbLabelStyleBlock">
        <details>
            <summary>class CvDbLabelStyleBlock <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> angle(self) -&gt; float</code>
            <code><span class="kw">def</span> angleExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> attachment(self) -&gt; BlockAttachment</code>
            <code><span class="kw">def</span> blockId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbLabelStyleBlock</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> height(self) -&gt; float</code>
            <code><span class="kw">def</span> heightExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> linetype(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> lineweight(self) -&gt; PyDb.LineWeight</code>
            <code><span class="kw">def</span> offset(self) -&gt; PyGe.Vector2d</code>
            <code><span class="kw">def</span> setAngle(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setAngleExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setAttachment(self, attachment: PyBrxCv.BlockAttachment) -&gt; None</code>
            <code><span class="kw">def</span> setBlockId(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setHeight(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setHeightExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setLinetype(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setLineweight(self, lineWeight: PyDb.LineWeight) -&gt; None</code>
            <code><span class="kw">def</span> setOffset(self, val: PyGe.Vector2d) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="CvDbLabelStyleComponent">
        <details>
            <summary>class CvDbLabelStyleComponent <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> anchorIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> anchorPoint(self) -&gt; LabelAnchor</code>
            <code><span class="kw">def</span> color(self) -&gt; PyDb.Color</code>
            <code><span class="kw">def</span> displaySetting(self) -&gt; bool</code>
            <code><span class="kw">def</span> setAnchorIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setAnchorPoint(self, val: PyBrxCv.LabelAnchor) -&gt; None</code>
            <code><span class="kw">def</span> setColor(self, clr: PyDb.Color) -&gt; None</code>
            <code><span class="kw">def</span> setVisible(self, val: bool) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="CvDbLabelStyleLine">
        <details>
            <summary>class CvDbLabelStyleLine <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> angle(self) -&gt; float</code>
            <code><span class="kw">def</span> angleExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbLabelStyleLine</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> endPointAnchorIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> endPointAnchorPoint(self) -&gt; LabelAnchor</code>
            <code><span class="kw">def</span> endPointOffset(self) -&gt; PyGe.Vector2d</code>
            <code><span class="kw">def</span> length(self) -&gt; float</code>
            <code><span class="kw">def</span> lengthExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> lengthPercentage(self) -&gt; float</code>
            <code><span class="kw">def</span> lengthPercentageExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> lengthType(self) -&gt; LengthType</code>
            <code><span class="kw">def</span> linetype(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> lineweight(self) -&gt; PyDb.LineWeight</code>
            <code><span class="kw">def</span> setAngle(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setAngleExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setEndPointAnchorIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setEndPointAnchorPoint(self, val: PyBrxCv.LabelAnchor) -&gt; None</code>
            <code><span class="kw">def</span> setEndPointOffset(self, val: PyGe.Vector2d) -&gt; None</code>
            <code><span class="kw">def</span> setLength(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setLengthExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setLengthPercentage(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setLengthPercentageExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setLengthType(self, val: PyBrxCv.LengthType) -&gt; None</code>
            <code><span class="kw">def</span> setLinetype(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setLineweight(self, id: PyDb.LineWeight) -&gt; None</code>
            <code><span class="kw">def</span> setStartPointOffset(self, val: PyGe.Vector2d) -&gt; None</code>
            <code><span class="kw">def</span> setUseEndPointAnchor(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> startPointOffset(self) -&gt; PyGe.Vector2d</code>
            <code><span class="kw">def</span> useEndPointAnchor(self) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbLabelStyleText">
        <details>
            <summary>class CvDbLabelStyleText <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> allowCurvedText(self) -&gt; bool</code>
            <code><span class="kw">def</span> borderBackgroudMask(self) -&gt; bool</code>
            <code><span class="kw">def</span> borderColor(self) -&gt; PyDb.Color</code>
            <code><span class="kw">def</span> borderGap(self) -&gt; float</code>
            <code><span class="kw">def</span> borderGapExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> borderIsVisible(self) -&gt; bool</code>
            <code><span class="kw">def</span> borderLinetype(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> borderLineweight(self, val: PyDb.LineWeight) -&gt; PyDb.LineWeight</code>
            <code><span class="kw">def</span> borderType(self) -&gt; BorderType</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbLabelStyleText</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> contents(self) -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setAllowCurvedText(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setBorderBackgroudMask(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setBorderColor(self, val: PyDb.Color) -&gt; None</code>
            <code><span class="kw">def</span> setBorderGap(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setBorderGapExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setBorderLinetype(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setBorderLineweight(self) -&gt; None</code>
            <code><span class="kw">def</span> setBorderType(self, val: BorderType) -&gt; None</code>
            <code><span class="kw">def</span> setBorderVisibility(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setContents(self, val: str) -&gt; None</code>
            <code><span class="kw">def</span> setTextAngle(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setTextAngleExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setTextAttachment(self, val: PyDb.MTextAttachmentPoint) -&gt; None</code>
            <code><span class="kw">def</span> setTextHeight(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setTextHeightExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setTextHorizontalAlignment(self, val: PyDb.TextHorzMode) -&gt; None</code>
            <code><span class="kw">def</span> setTextLinetype(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setTextLineweight(self, val: PyDb.LineWeight) -&gt; None</code>
            <code><span class="kw">def</span> setTextMaximumWidth(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setTextMaximumWidthExprIndex(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setTextOffset(self, val: PyGe.Vector2d) -&gt; None</code>
            <code><span class="kw">def</span> textAngle(self) -&gt; float</code>
            <code><span class="kw">def</span> textAngleExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> textAttachment(self) -&gt; PyDb.MTextAttachmentPoint</code>
            <code><span class="kw">def</span> textHeight(self) -&gt; float</code>
            <code><span class="kw">def</span> textHeightExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> textHorizontalAlignment(self) -&gt; PyDb.TextHorzMode</code>
            <code><span class="kw">def</span> textLinetype(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> textLineweight(self) -&gt; PyDb.LineWeight</code>
            <code><span class="kw">def</span> textMaximumWidth(self) -&gt; float</code>
            <code><span class="kw">def</span> textMaximumWidthExprIndex(self) -&gt; int</code>
            <code><span class="kw">def</span> textOffset(self) -&gt; PyGe.Vector2d</code>
        </details>
    </div>

    <div class="class" id="CvDbLineLabelStyleManager">
        <details>
            <summary>class CvDbLineLabelStyleManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbLineLabelStyleManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbLineLabelStyleManager</code>
            <code><span class="kw">def</span> createLabelStyle(self, name: str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManagerId(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> managerId() -&gt; str</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbLineLabelStyleManager</code>
        </details>
    </div>

    <div class="class" id="CvDbObject">
        <details>
            <summary>class CvDbObject <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbObject</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbObject</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> description(self) -&gt; str</code>
            <code><span class="kw">def</span> name(self) -&gt; str</code>
            <code><span class="kw">def</span> setDescription(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> setName(self, val: str) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbObjectManager">
        <details>
            <summary>class CvDbObjectManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __contains__(self, id: str | PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> __getitem__(self, val: int | str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbObjectManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbObjectManager</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> elementCount(self) -&gt; int</code>
            <code><span class="kw">def</span> has(self, id: str | PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> idAt(self, val: int | str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> ids(self) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> nameAt(self, val: int) -&gt; str</code>
            <code><span class="kw">def</span> names(self) -&gt; list[str]</code>
            <code><span class="kw">def</span> remove(self, id: str | PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> toDict(self) -&gt; dict</code>
        </details>
    </div>

    <div class="class" id="CvDbPoint">
        <details>
            <summary>class CvDbPoint <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addUserAttribute(self, name: str, value: PyBrxCv.CvAttribVariant) -&gt; bool</code>
            <code><span class="kw">def</span> assignPointToPointGroup(cvpoint: PyBrxCv.CvDbPoint, groupid: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> assignPointsToPointGroup(cvpoint: list[PyBrxCv.CvDbPoint], groupid: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> assignStylesToPoints(cvpoint: list[PyBrxCv.CvDbPoint], symbolStyleId: PyDb.ObjectId, labelStyleId: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbPoint</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbPoint</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> easting(self) -&gt; float</code>
            <code><span class="kw">def</span> elevation(self) -&gt; float</code>
            <code><span class="kw">def</span> fullDescription(self) -&gt; str</code>
            <code><span class="kw">def</span> importPointsFromFile(files: list[str], fmtid: PyDb.ObjectId) -&gt; list[PyBrxCv.CvDbPoint]</code>
            <code><span class="kw">def</span> isLabelDragged(self) -&gt; bool</code>
            <code><span class="kw">def</span> isLabelPinned(self) -&gt; bool</code>
            <code><span class="kw">def</span> labelId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> labelLeaderVertices(self) -&gt; list[PyGe.Point3d]</code>
            <code><span class="kw">def</span> labelPosition(self) -&gt; PyGe.Point3d</code>
            <code><span class="kw">def</span> labelRotation(self) -&gt; float</code>
            <code><span class="kw">def</span> northing(self) -&gt; float</code>
            <code><span class="kw">def</span> number(self) -&gt; int</code>
            <code><span class="kw">def</span> pointGroupsIds(self) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> pointGroupsNames(self) -&gt; list[str]</code>
            <code><span class="kw">def</span> position(self) -&gt; PyGe.Point3d</code>
            <code><span class="kw">def</span> rawDescription(self) -&gt; str</code>
            <code><span class="kw">def</span> referencedEntityAt(self, val: int) -&gt; CvDbPointReferencedEntity</code>
            <code><span class="kw">def</span> referencedEntityCount(self) -&gt; int</code>
            <code><span class="kw">def</span> removeUserAttribute(self, name: str, value: PyBrxCv.CvDataType) -&gt; bool</code>
            <code><span class="kw">def</span> resetLabel(self) -&gt; bool</code>
            <code><span class="kw">def</span> setEasting(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setElevation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setFullDescription(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> setLabelId(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> setLabelLeaderVertices(self, vertices: list[PyGe.Point3d]) -&gt; bool</code>
            <code><span class="kw">def</span> setLabelPinned(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setLabelPosition(self, pt: PyGe.Point3d) -&gt; bool</code>
            <code><span class="kw">def</span> setLabelRotation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setNorthing(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setNumber(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setPosition(self, pt: PyGe.Point3d) -&gt; bool</code>
            <code><span class="kw">def</span> setRawDescription(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> setSymbolId(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> setSymbolRotation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> symbolId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> symbolRotation(self) -&gt; float</code>
            <code><span class="kw">def</span> update(self) -&gt; bool</code>
            <code><span class="kw">def</span> userAttribute(self, name: str, value: PyBrxCv.CvDataType) -&gt; CvAttribVariant</code>
            <code><span class="kw">def</span> userAttributeAt(self, index: int) -&gt; tuple</code>
            <code><span class="kw">def</span> userAttributeCount(self) -&gt; int</code>
            <code><span class="kw">def</span> userAttributeNames(self) -&gt; list</code>
            <code><span class="kw">def</span> userAttributes(self) -&gt; list</code>
        </details>
    </div>

    <div class="class" id="CvDbPointGroup">
        <details>
            <summary>class CvDbPointGroup <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbPointGroup</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbPointGroup</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> excludeElevations(self) -&gt; str</code>
            <code><span class="kw">def</span> excludeFullDescriptions(self) -&gt; str</code>
            <code><span class="kw">def</span> excludeNames(self) -&gt; str</code>
            <code><span class="kw">def</span> excludeNumbers(self) -&gt; str</code>
            <code><span class="kw">def</span> excludeRawDescriptions(self) -&gt; str</code>
            <code><span class="kw">def</span> excludeUserAttributesKeys(self) -&gt; str</code>
            <code><span class="kw">def</span> excludeUserAttributesValues(self) -&gt; str</code>
            <code><span class="kw">def</span> hasPoint(self, val: int) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> includeElevations(self) -&gt; str</code>
            <code><span class="kw">def</span> includeFullDescriptions(self) -&gt; str</code>
            <code><span class="kw">def</span> includeNames(self) -&gt; str</code>
            <code><span class="kw">def</span> includeNumbers(self) -&gt; str</code>
            <code><span class="kw">def</span> includeRawDescriptions(self) -&gt; str</code>
            <code><span class="kw">def</span> includeUserAttributesKeys(self) -&gt; str</code>
            <code><span class="kw">def</span> includeUserAttributesValues(self) -&gt; str</code>
            <code><span class="kw">def</span> isApplicable(self) -&gt; bool</code>
            <code><span class="kw">def</span> isEditable(self) -&gt; bool</code>
            <code><span class="kw">def</span> pointCount(self) -&gt; int</code>
            <code><span class="kw">def</span> pointIds(self) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> setExcludeElevations(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setExcludeFullDescriptions(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setExcludeNames(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setExcludeNumbers(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setExcludeRawDescriptions(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setExcludeUserAttributesKeys(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setIncludeElevations(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setIncludeFullDescriptions(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setIncludeNames(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setIncludeNumbers(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setIncludeRawDescriptions(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setIncludeUserAttributesKeys(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> setIncludeUserAttributesValues(self, filter: str) -&gt; bool</code>
            <code><span class="kw">def</span> update(self) -&gt; bool</code>
            <code><span class="kw">def</span> updateNeeded(self) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbPointGroupManager">
        <details>
            <summary>class CvDbPointGroupManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbPointGroupManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbPointGroupManager</code>
            <code><span class="kw">def</span> createPointGroup(self, val: str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManagerId(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> groupsWithPoint(self, val: int) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> nextPointNumber(self) -&gt; int</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbPointGroupManager</code>
            <code><span class="kw">def</span> setNextPointNumber(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> updatePointGroups(self) -&gt; int</code>
        </details>
    </div>

    <div class="class" id="CvDbPointLabelStyleManager">
        <details>
            <summary>class CvDbPointLabelStyleManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbPointLabelStyleManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbPointLabelStyleManager</code>
            <code><span class="kw">def</span> createLabelStyle(self, name: str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManagerId(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> managerId() -&gt; str</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbPointLabelStyleManager</code>
        </details>
    </div>

    <div class="class" id="CvDbPointReferencedEntity">
        <details>
            <summary>class CvDbPointReferencedEntity <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbPointReferencedEntity</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> id(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> setId(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> type(self) -&gt; PyRx.RxClass</code>
        </details>
    </div>

    <div class="class" id="CvDbStyle">
        <details>
            <summary>class CvDbStyle <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbStyle</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> createdBy(self) -&gt; str</code>
            <code><span class="kw">def</span> createdDate(self) -&gt; PyDb.Date</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> displaySetting(self, orientation: PyBrxCv.DisplayOrientation, partName: str) -&gt; CvDbStylePartDisplaySettings</code>
            <code><span class="kw">def</span> displaySettings(self, orientation: PyBrxCv.DisplayOrientation) -&gt; list[PyBrxCv.CvDbStylePartDisplaySettings]</code>
            <code><span class="kw">def</span> lastEditedBy(self) -&gt; str</code>
            <code><span class="kw">def</span> lastEditedDate(self) -&gt; PyDb.Date</code>
            <code><span class="kw">def</span> setCreatedBy(self, filter: str) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="CvDbStyleManager">
        <details>
            <summary>class CvDbStyleManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbStyleManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbStyleManager</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManager(db: PyDb.Database, styleType: PyBrxCv.StyleManagerType) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode, styleType: PyBrxCv.StyleManagerType) -&gt; CvDbObjectManager</code>
        </details>
    </div>

    <div class="class" id="CvDbStylePartDisplaySettings">
        <details>
            <summary>class CvDbStylePartDisplaySettings <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> color(self) -&gt; PyDb.Color</code>
            <code><span class="kw">def</span> displaySetting(self) -&gt; bool</code>
            <code><span class="kw">def</span> layer(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> lineType(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> lineTypeScale(self) -&gt; float</code>
            <code><span class="kw">def</span> lineWeight(self) -&gt; PyDb.LineWeight</code>
            <code><span class="kw">def</span> plotStyleNameId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> plotStyleNameType(self) -&gt; PyDb.PlotStyleNameType</code>
            <code><span class="kw">def</span> setColor(self, clr: PyDb.Color) -&gt; None</code>
            <code><span class="kw">def</span> setLayer(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setLineType(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setLineTypeScale(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setLineWeight(self, val: PyDb.LineWeight) -&gt; None</code>
            <code><span class="kw">def</span> setPlotStyleNameId(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setPlotStyleNameType(self, val: PyDb.PlotStyleNameType) -&gt; None</code>
            <code><span class="kw">def</span> setVisible(self, val: bool) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="CvDbSubObject">
        <details>
            <summary>class CvDbSubObject <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbSubObject</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> description(self) -&gt; str</code>
            <code><span class="kw">def</span> name(self) -&gt; str</code>
            <code><span class="kw">def</span> setDescription(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> setName(self, val: str) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbSurfaceContourLabelStyleManager">
        <details>
            <summary>class CvDbSurfaceContourLabelStyleManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbSurfaceContourLabelStyleManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbSurfaceContourLabelStyleManager</code>
            <code><span class="kw">def</span> createLabelStyle(self, name: str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManagerId(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> managerId() -&gt; str</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbSurfaceContourLabelStyleManager</code>
        </details>
    </div>

    <div class="class" id="CvDbSurfaceElevationLabelStyleManager">
        <details>
            <summary>class CvDbSurfaceElevationLabelStyleManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbSurfaceElevationLabelStyleManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbSurfaceElevationLabelStyleManager</code>
            <code><span class="kw">def</span> createLabelStyle(self, name: str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManagerId(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> managerId() -&gt; str</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbSurfaceElevationLabelStyleManager</code>
        </details>
    </div>

    <div class="class" id="CvDbSurfaceSlopeLabelStyleManager">
        <details>
            <summary>class CvDbSurfaceSlopeLabelStyleManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbSurfaceSlopeLabelStyleManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbSurfaceSlopeLabelStyleManager</code>
            <code><span class="kw">def</span> createLabelStyle(self, name: str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManagerId(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> managerId() -&gt; str</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbSurfaceSlopeLabelStyleManager</code>
        </details>
    </div>

    <div class="class" id="CvDbSymbolStyle">
        <details>
            <summary>class CvDbSymbolStyle <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, metric: bool) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> asPDMODE(self) -&gt; int</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbSymbolStyle</code>
            <code><span class="kw">def</span> circleFrame(self) -&gt; bool</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> customSymbol(self) -&gt; CustomSymbol</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> fixedScale(self) -&gt; PyGe.Scale3d</code>
            <code><span class="kw">def</span> maximumSize(self) -&gt; float</code>
            <code><span class="kw">def</span> orientationReference(self) -&gt; OrientationRef</code>
            <code><span class="kw">def</span> rotationAngle(self) -&gt; float</code>
            <code><span class="kw">def</span> scalingType(self) -&gt; ScalingType</code>
            <code><span class="kw">def</span> setCircleFrame(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setCustomSymbol(self, val: PyBrxCv.CustomSymbol) -&gt; None</code>
            <code><span class="kw">def</span> setFixedScale(self, scale: PyGe.Scale3d) -&gt; None</code>
            <code><span class="kw">def</span> setMaximumSize(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setOrientationReference(self, val: PyBrxCv.OrientationRef) -&gt; None</code>
            <code><span class="kw">def</span> setPDMODE(self, val: int) -&gt; None</code>
            <code><span class="kw">def</span> setRotationAngle(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setScalingType(self, val: PyBrxCv.ScalingType) -&gt; None</code>
            <code><span class="kw">def</span> setSize(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setSquareFrame(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setSymbolBlockId(self, id: PyDb.ObjectId) -&gt; None</code>
            <code><span class="kw">def</span> setSymbolType(self, val: PyBrxCv.SymbolType) -&gt; None</code>
            <code><span class="kw">def</span> size(self) -&gt; float</code>
            <code><span class="kw">def</span> squareFrame(self) -&gt; bool</code>
            <code><span class="kw">def</span> symbolBlockId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> symbolType(self) -&gt; SymbolType</code>
        </details>
    </div>

    <div class="class" id="CvDbSymbolStyleManager">
        <details>
            <summary>class CvDbSymbolStyleManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbSymbolStyleManager</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbSymbolStyleManager</code>
            <code><span class="kw">def</span> createSymbolStyle(self, name: str) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> getManagerId(db: PyDb.Database) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> managerId() -&gt; str</code>
            <code><span class="kw">def</span> openManager(db: PyDb.Database, mode: PyDb.OpenMode) -&gt; CvDbSymbolStyleManager</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurface">
        <details>
            <summary>class CvDbTinSurface <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addConstraint(self, constraint: PyBrxCv.CvDbTinSurfaceConstraint, addReactor: bool) -&gt; bool</code>
            <code><span class="kw">def</span> addConstraints(self, constraints: list[PyBrxCv.CvDbTinSurfaceConstraint], addReactor: bool) -&gt; bool</code>
            <code><span class="kw">def</span> addDefinition(self, ref: PyBrxCv.CvDbTinSurfaceDefinition) -&gt; int</code>
            <code><span class="kw">def</span> addPoint(self, pt: PyGe.Point3d) -&gt; bool</code>
            <code><span class="kw">def</span> addPoints(self, pts: list[PyGe.Point3d]) -&gt; bool</code>
            <code><span class="kw">def</span> area2d(self, visibleOnly: bool) -&gt; float</code>
            <code><span class="kw">def</span> area3d(self, visibleOnly: bool) -&gt; float</code>
            <code><span class="kw">def</span> boundingBox(self) -&gt; tuple[PyGe.Point2d, PyGe.Point2d]</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurface</code>
            <code><span class="kw">def</span> changePointsElevations(self, pts: list[PyGe.Point3d], newZValues: list[float]) -&gt; bool</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbTinSurface</code>
            <code><span class="kw">def</span> closestPointTo(self, pt: PyGe.Point3d) -&gt; PyGe.Point3d</code>
            <code><span class="kw">def</span> contains(self, pt: PyGe.Point3d) -&gt; bool</code>
            <code><span class="kw">def</span> contoursAtElevation(self, elevation: float) -&gt; list[list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> createSnapshot(self) -&gt; int</code>
            <code><span class="kw">def</span> definitionAt(self, index: int) -&gt; CvDbTinSurfaceDefinition</code>
            <code><span class="kw">def</span> definitionCount(self) -&gt; int</code>
            <code><span class="kw">def</span> definitionIndex(self, ref: PyBrxCv.CvDbTinSurfaceDefinition) -&gt; tuple[bool, int]</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> drapeId(self, id: PyDb.ObjectId) -&gt; list[list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> drapePoints(self, pts: list[PyGe.Point3d]) -&gt; list[list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> elevationAtPoint(self, pt: PyGe.Point3d) -&gt; tuple[bool, float]</code>
            <code><span class="kw">def</span> eraseConstraint(self, id: PyDb.ObjectId | int, removeReactor: bool) -&gt; bool</code>
            <code><span class="kw">def</span> eraseConstraints(self, int64ids: list[int], removeReactor: bool) -&gt; bool</code>
            <code><span class="kw">def</span> eraseConstraintsIds(self, ids: list[PyDb.ObjectId], removeReactor: bool) -&gt; bool</code>
            <code><span class="kw">def</span> findDefinition(self, id: int) -&gt; CvDbTinSurfaceDefinition</code>
            <code><span class="kw">def</span> findTinPointAt(self, pt: PyGe.Point3d) -&gt; tuple[bool, PyBrxCv.CvTinPoint]</code>
            <code><span class="kw">def</span> findTinTrianglesAt(self, pt: PyGe.Point3d) -&gt; list[PyBrx.CvTinTriangle]</code>
            <code><span class="kw">def</span> getBorders(self) -&gt; list[list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> getConstraint(self, id: PyDb.ObjectId | int) -&gt; CvDbTinSurfaceConstraint</code>
            <code><span class="kw">def</span> getConstraints(self) -&gt; list[PyBrxCv.CvDbTinSurfaceConstraint]</code>
            <code><span class="kw">def</span> getPoints(self, visibleOnly: bool) -&gt; list[PyGe.Point3d]</code>
            <code><span class="kw">def</span> getPointsInsidePolygon(self, pts: list[PyGe.Point3d], includeOnEdge: bool) -&gt; list[PyGe.Point3d]</code>
            <code><span class="kw">def</span> getTinPoints(self) -&gt; list[PyBrx.CvTinPoint]</code>
            <code><span class="kw">def</span> hasSnapshot(self) -&gt; bool</code>
            <code><span class="kw">def</span> initialize(self, min: PyGe.Point3d, max: PyGe.Point3d, numOfPoints: int) -&gt; None</code>
            <code><span class="kw">def</span> insertDefinitionAt(self, index: int, ref: PyBrxCv.CvDbTinSurfaceDefinition) -&gt; int</code>
            <code><span class="kw">def</span> intersectionsWithLine(self, start: PyGe.Point3d, end: PyGe.Point3d, type: PyBrxCv.TinSurfaceIntersectType, visibleOnly: bool) -&gt; tuple[bool, list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> isAssociative(self) -&gt; bool</code>
            <code><span class="kw">def</span> isAutoUpdate(self) -&gt; bool</code>
            <code><span class="kw">def</span> isRebuildPossible(self) -&gt; bool</code>
            <code><span class="kw">def</span> isSnapshotUpdateNeeded(self) -&gt; bool</code>
            <code><span class="kw">def</span> isUpdateNeeded(self) -&gt; bool</code>
            <code><span class="kw">def</span> majorContours(self) -&gt; list[list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> majorContoursColor(self) -&gt; tuple[bool, int]</code>
            <code><span class="kw">def</span> majorContoursInterval(self) -&gt; tuple[bool, int]</code>
            <code><span class="kw">def</span> maxElevation(self, visibleOnly: bool) -&gt; float</code>
            <code><span class="kw">def</span> merge(self, other: PyBrxCv.CvDbTinSurface) -&gt; bool</code>
            <code><span class="kw">def</span> mergeSurfaces(theOne: PyBrxCv.CvDbTinSurface, theOther: PyBrxCv.CvDbTinSurface) -&gt; CvDbTinSurface</code>
            <code><span class="kw">def</span> minElevation(self, visibleOnly: bool) -&gt; float</code>
            <code><span class="kw">def</span> minorContours(self) -&gt; list[list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> minorContoursColor(self) -&gt; tuple[bool, int]</code>
            <code><span class="kw">def</span> minorContoursInterval(self) -&gt; tuple[bool, int]</code>
            <code><span class="kw">def</span> moveDefinition(self, _from: int, _to: int) -&gt; int</code>
            <code><span class="kw">def</span> movePoint(self, _from: PyGe.Point3d, _to: PyGe.Point3d) -&gt; bool</code>
            <code><span class="kw">def</span> movePoints(self, _from: list[PyGe.Point3d], _to: list[PyGe.Point3d]) -&gt; bool</code>
            <code><span class="kw">def</span> pointsCount(self, visibleOnly: bool) -&gt; int</code>
            <code><span class="kw">def</span> raiseSurface(self, offset: float) -&gt; bool</code>
            <code><span class="kw">def</span> rebuild(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> rebuildSnapshot(self) -&gt; bool</code>
            <code><span class="kw">def</span> removeAllDefinitions(self) -&gt; int</code>
            <code><span class="kw">def</span> removeDefinitionAt(self, index: int) -&gt; bool</code>
            <code><span class="kw">def</span> removePoint(self, pt: PyGe.Point3d) -&gt; bool</code>
            <code><span class="kw">def</span> removePoints(self, pts: list[PyGe.Point3d]) -&gt; bool</code>
            <code><span class="kw">def</span> removeSnapshot(self) -&gt; bool</code>
            <code><span class="kw">def</span> setAssociative(self, isAssociative: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setIsAutoUpdate(self, autoUpdateOn: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setMajorContoursColor(self, colorIndex: int) -&gt; bool</code>
            <code><span class="kw">def</span> setMajorContoursInterval(self, interval: float) -&gt; bool</code>
            <code><span class="kw">def</span> setMinorContoursColor(self, colorIndex: int) -&gt; bool</code>
            <code><span class="kw">def</span> setMinorContoursInterval(self, interval: float) -&gt; bool</code>
            <code><span class="kw">def</span> setStyle(self, style: PyBrxCv.TinSurfaceStyle) -&gt; bool</code>
            <code><span class="kw">def</span> setSurfaceElevation(self, elevation: float) -&gt; bool</code>
            <code><span class="kw">def</span> solid3d(self, surface: PyBrxCv.CvDbTinSurface) -&gt; PyDb.Solid3d</code>
            <code><span class="kw">def</span> solid3d(self, surfaceType: PyBrxCv.TinSurfaceMeshType, thickness: float) -&gt; PyDb.Solid3d</code>
            <code><span class="kw">def</span> solid3d(*args) -&gt; PyDb.Solid3d</code>
            <code><span class="kw">def</span> style(self) -&gt; TinSurfaceStyle</code>
            <code><span class="kw">def</span> subDMesh(self) -&gt; PyDb.SubDMesh</code>
            <code><span class="kw">def</span> subDMesh(self, surface: PyBrxCv.CvDbTinSurface) -&gt; PyDb.SubDMesh</code>
            <code><span class="kw">def</span> subDMesh(self, surfaceType: PyBrxCv.TinSurfaceMeshType, depthOrElevation: float) -&gt; PyDb.SubDMesh</code>
            <code><span class="kw">def</span> subDMesh(*args) -&gt; PyDb.SubDMesh</code>
            <code><span class="kw">def</span> swapEdge(self, pt: PyGe.Point3d) -&gt; bool</code>
            <code><span class="kw">def</span> tinTriangles(self) -&gt; list[PyBrx.CvTinTriangle]</code>
            <code><span class="kw">def</span> triangles(self, visibleOnly: bool) -&gt; list[PyBrx.CvTinTriangle]</code>
            <code><span class="kw">def</span> trianglesCount(self, visibleOnly: bool) -&gt; int</code>
            <code><span class="kw">def</span> updateConstraint(self, val: PyBrxCv.CvDbTinSurfaceConstraint) -&gt; bool</code>
            <code><span class="kw">def</span> updateObjectData(self) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceBoundary">
        <details>
            <summary>class CvDbTinSurfaceBoundary <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, type: PyBrxCv.TinBoundaryType) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> wallType(self) -&gt; TinBoundaryType</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceBreakline">
        <details>
            <summary>class CvDbTinSurfaceBreakline <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, type: PyBrxCv.TinBreaklineType) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> intersectionElevation(self) -&gt; BreaklineIntersectionElevation</code>
            <code><span class="kw">def</span> setIntersectionElevation(self, val: PyBrxCv.TinBreaklineType) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceConstraint">
        <details>
            <summary>class CvDbTinSurfaceConstraint <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, type: PyBrxCv.TinConstraintType) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> constraintType(self) -&gt; TinConstraintType</code>
            <code><span class="kw">def</span> data(self) -&gt; list[PyGe.Point3d]</code>
            <code><span class="kw">def</span> id(self) -&gt; int</code>
            <code><span class="kw">def</span> isDbResident(self) -&gt; bool</code>
            <code><span class="kw">def</span> midOrdinateDistance(self) -&gt; float</code>
            <code><span class="kw">def</span> setData(self, intId: int, pts: list[PyGe.Point3d]) -&gt; None</code>
            <code><span class="kw">def</span> setDataId(self, id: PyDb.ObjectId, midOrdinateDist: float) -&gt; None</code>
            <code><span class="kw">def</span> setIsDbResident(self, val: bool) -&gt; None</code>
            <code><span class="kw">def</span> setMidOrdinateDistance(self, val: float) -&gt; None</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinition">
        <details>
            <summary>class CvDbTinSurfaceDefinition <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinition</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> description(self) -&gt; str</code>
            <code><span class="kw">def</span> id(self) -&gt; int</code>
            <code><span class="kw">def</span> isEnabled(self) -&gt; bool</code>
            <code><span class="kw">def</span> isReadOnly(self) -&gt; bool</code>
            <code><span class="kw">def</span> isSubDefinition(self) -&gt; bool</code>
            <code><span class="kw">def</span> isUpdateNeeded(self) -&gt; bool</code>
            <code><span class="kw">def</span> isValid(self) -&gt; bool</code>
            <code><span class="kw">def</span> name(self) -&gt; str</code>
            <code><span class="kw">def</span> setDescription(self, desc: str) -&gt; bool</code>
            <code><span class="kw">def</span> setEnabled(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setName(self, name: str) -&gt; bool</code>
            <code><span class="kw">def</span> setReadOnly(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> type(self) -&gt; TinSurfaceDefinitionType</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionAddDrawingObjects">
        <details>
            <summary>class CvDbTinSurfaceDefinitionAddDrawingObjects <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addEntity(self, entity: PyDb.Entity) -&gt; bool</code>
            <code><span class="kw">def</span> addEntityId(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionAddDrawingObjects</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> crossingsElevation(self) -&gt; TinIntersectionElevation</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> drawingObjectAt(self, idx: int) -&gt; tuple[bool, PyBrx.DrawingObjectTypet, list[PyGe.Point3d]]</code>
            <code><span class="kw">def</span> drawingObjectsCount(self) -&gt; int</code>
            <code><span class="kw">def</span> isApplyEdges(self) -&gt; bool</code>
            <code><span class="kw">def</span> removeAllDrawingObjects(self) -&gt; bool</code>
            <code><span class="kw">def</span> removeDrawingObjectAt(self, idx: int) -&gt; bool</code>
            <code><span class="kw">def</span> setCrossingsElevation(self, val: PyBrxCv.TinIntersectionElevation) -&gt; bool</code>
            <code><span class="kw">def</span> setIsApplyEdges(self, val: bool) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionAddFromFiles">
        <details>
            <summary>class CvDbTinSurfaceDefinitionAddFromFiles <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionAddFromFiles</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> fileFormatId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> filesPaths(self) -&gt; list[str]</code>
            <code><span class="kw">def</span> setFileFormatId(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> setFilesPaths(self, val: list[str]) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionAddFromPointClouds">
        <details>
            <summary>class CvDbTinSurfaceDefinitionAddFromPointClouds <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionAddFromPointClouds</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> pcObjectIds(self) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> setPcObjectIds(self, val: list[PyDb.ObjectId]) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionAddLine">
        <details>
            <summary>class CvDbTinSurfaceDefinitionAddLine <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionAddLine</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> line(self) -&gt; PyGe.LineSeg2d</code>
            <code><span class="kw">def</span> setLine(self, line: PyGe.LineSeg2d) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionAddLines">
        <details>
            <summary>class CvDbTinSurfaceDefinitionAddLines <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionAddLines</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> lines(self) -&gt; list[PyGe.LineSeg3d]</code>
            <code><span class="kw">def</span> setLines(self, lines: list[PyGe.LineSeg2d]) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionAddPoint">
        <details>
            <summary>class CvDbTinSurfaceDefinitionAddPoint <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionAddPoint</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> position(self) -&gt; PyGe.Point3d</code>
            <code><span class="kw">def</span> setPosition(self, pt: PyGe.Point3d) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionAddPointGroups">
        <details>
            <summary>class CvDbTinSurfaceDefinitionAddPointGroups <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionAddPointGroups</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> pointGroupsIds(self) -&gt; list[PyDb.ObjectId]</code>
            <code><span class="kw">def</span> setPointGroupsIds(self, val: list[PyDb.ObjectId]) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionAddPoints">
        <details>
            <summary>class CvDbTinSurfaceDefinitionAddPoints <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionAddPoints</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> positions(self) -&gt; list[PyGe.Point2d]</code>
            <code><span class="kw">def</span> setPositions(self, pt: list[PyGe.Point3d]) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionCreateFromC3D">
        <details>
            <summary>class CvDbTinSurfaceDefinitionCreateFromC3D <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionCreateFromC3D</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> filePath(self) -&gt; str</code>
            <code><span class="kw">def</span> setFilePath(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> setSurfaceName(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> surfaceName(self) -&gt; str</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionCreateFromFaces">
        <details>
            <summary>class CvDbTinSurfaceDefinitionCreateFromFaces <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionCreateFromFaces</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> faceAt(self) -&gt; tuple[bool, PyDb.Face]</code>
            <code><span class="kw">def</span> facesCount(self) -&gt; int</code>
            <code><span class="kw">def</span> isApplyEdgesVisibility(self) -&gt; bool</code>
            <code><span class="kw">def</span> points(self) -&gt; list[PyGe.Point3d]</code>
            <code><span class="kw">def</span> setIsApplyEdgesVisibility(self) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionCreateFromLandXML">
        <details>
            <summary>class CvDbTinSurfaceDefinitionCreateFromLandXML <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionCreateFromLandXML</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> dwgUnits(self) -&gt; PyDb.UnitsValue</code>
            <code><span class="kw">def</span> filePath(self) -&gt; str</code>
            <code><span class="kw">def</span> scaleToDwgUnits(self) -&gt; bool</code>
            <code><span class="kw">def</span> setFilePath(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> setScaleToDwgUnits(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setSurfaceName(self, val: str) -&gt; bool</code>
            <code><span class="kw">def</span> surfaceName(self) -&gt; str</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionDeleteEdge">
        <details>
            <summary>class CvDbTinSurfaceDefinitionDeleteEdge <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionDeleteEdge</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> position(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> setPosition(self, pt: PyGe.Point2d) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionDeleteEdges">
        <details>
            <summary>class CvDbTinSurfaceDefinitionDeleteEdges <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addPolygon(self, edgePolygon: list[PyGe.Point2d], includeIntersected: bool) -&gt; bool</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionDeleteEdges</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> polygonAt(self, index: int) -&gt; tuple[bool, list[PyGe.Point2d]]</code>
            <code><span class="kw">def</span> polygonsCount(self) -&gt; int</code>
            <code><span class="kw">def</span> removeAllPolygons(self) -&gt; bool</code>
            <code><span class="kw">def</span> removePolygonAt(self, index: int) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionDeletePoint">
        <details>
            <summary>class CvDbTinSurfaceDefinitionDeletePoint <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionDeletePoint</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> position(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> setPosition(self, pt: PyGe.Point2d) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionGroupDefs">
        <details>
            <summary>class CvDbTinSurfaceDefinitionGroupDefs <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addSubDefinition(self, val: PyBrxCv.CvDbTinSurfaceDefinition) -&gt; int</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionGroupDefs</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> findSubDefinition(self, defid: int) -&gt; int</code>
            <code><span class="kw">def</span> getSubDefinitionAt(self, index: int) -&gt; CvDbTinSurfaceDefinition</code>
            <code><span class="kw">def</span> numSubDefinitions(self) -&gt; int</code>
            <code><span class="kw">def</span> removeSubDefinitionAt(self, index: int) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionModifyPointElevation">
        <details>
            <summary>class CvDbTinSurfaceDefinitionModifyPointElevation <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionModifyPointElevation</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> elevation(self) -&gt; float</code>
            <code><span class="kw">def</span> isDeltaElevation(self) -&gt; bool</code>
            <code><span class="kw">def</span> position(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> setElevation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setIsDeltaElevation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setPosition(self, pt: PyGe.Point2d) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionModifyPointsElevation">
        <details>
            <summary>class CvDbTinSurfaceDefinitionModifyPointsElevation <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionModifyPointsElevation</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> elevation(self) -&gt; float</code>
            <code><span class="kw">def</span> isDeltaElevation(self) -&gt; bool</code>
            <code><span class="kw">def</span> positions(self) -&gt; list[PyGe.Point2d]</code>
            <code><span class="kw">def</span> setElevation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setPositions(self, pt: list[PyGe.Point2d]) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionModifyPointsElevations">
        <details>
            <summary>class CvDbTinSurfaceDefinitionModifyPointsElevations <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addPointElevation(self) -&gt; bool</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionModifyPointsElevations</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> pointElevationAt(self) -&gt; tuple[bool, PyGe.Point2d]</code>
            <code><span class="kw">def</span> pointElevationsCount(self) -&gt; int</code>
            <code><span class="kw">def</span> removeAllPointElevations(self) -&gt; bool</code>
            <code><span class="kw">def</span> removePointElevationAt(self) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionMovePoint">
        <details>
            <summary>class CvDbTinSurfaceDefinitionMovePoint <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionMovePoint</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> fromPosition(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> setFromPosition(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setToPosition(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> toPosition(self) -&gt; PyGe.Point2d</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionMovePoints">
        <details>
            <summary>class CvDbTinSurfaceDefinitionMovePoints <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionMovePoints</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> displacement(self) -&gt; PyGe.Vector2d</code>
            <code><span class="kw">def</span> fromPoints(self) -&gt; list[PyGe.Point2d]</code>
            <code><span class="kw">def</span> setDisplacement(self, vec: PyGe.Vector3d) -&gt; bool</code>
            <code><span class="kw">def</span> setFromPoints(self, pt: list[PyGe.Point2d]) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionRemoveElevations">
        <details>
            <summary>class CvDbTinSurfaceDefinitionRemoveElevations <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionRemoveElevations</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> removeAbove(self) -&gt; bool</code>
            <code><span class="kw">def</span> removeAboveElevation(self) -&gt; float</code>
            <code><span class="kw">def</span> removeBelow(self) -&gt; bool</code>
            <code><span class="kw">def</span> removeBelowElevation(self) -&gt; float</code>
            <code><span class="kw">def</span> removedPointsCount(self) -&gt; int</code>
            <code><span class="kw">def</span> setRemoveAbove(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setRemoveAboveElevation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setRemoveBelow(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setRemoveBelowElevation(self, val: float) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionRemoveOuterEdges">
        <details>
            <summary>class CvDbTinSurfaceDefinitionRemoveOuterEdges <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionRemoveOuterEdges</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> maxAdjAngle(self) -&gt; float</code>
            <code><span class="kw">def</span> maxEdgeLength(self) -&gt; float</code>
            <code><span class="kw">def</span> minEdgeLength(self) -&gt; float</code>
            <code><span class="kw">def</span> setMaxAdjAngle(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setMaxEdgeLength(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setMinEdgeLength(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setUseMaxAdjAngle(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setUseMaxEdgeLength(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setUseMinEdgeLength(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> useMaxAdjAngle(self) -&gt; bool</code>
            <code><span class="kw">def</span> useMaxEdgeLength(self) -&gt; bool</code>
            <code><span class="kw">def</span> useMinEdgeLength(self) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionRiseLower">
        <details>
            <summary>class CvDbTinSurfaceDefinitionRiseLower <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionRiseLower</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> offset(self) -&gt; float</code>
            <code><span class="kw">def</span> setOffset(self, val: float) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionSwapEdge">
        <details>
            <summary>class CvDbTinSurfaceDefinitionSwapEdge <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionSwapEdge</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> position(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> setPosition(self, pt: PyGe.Point2d) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionTransform">
        <details>
            <summary>class CvDbTinSurfaceDefinitionTransform <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionTransform</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> setTransformationMatrix(self, xform: PyGe.Matrix3d) -&gt; bool</code>
            <code><span class="kw">def</span> transformationMatrix(self) -&gt; PyGe.Matrix3d</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceDefinitionTrianglesVisibility">
        <details>
            <summary>class CvDbTinSurfaceDefinitionTrianglesVisibility <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbTinSurfaceDefinitionTrianglesVisibility</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> positions(self) -&gt; list[PyGe.Point2d]</code>
            <code><span class="kw">def</span> setPositions(self, val: list[PyGe.Point2d]) -&gt; bool</code>
            <code><span class="kw">def</span> setVisible(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> visible(self) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbTinSurfaceWall">
        <details>
            <summary>class CvDbTinSurfaceWall <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, type: PyBrxCv.TinWallType) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> setHeight(self, val: float) -&gt; None</code>
            <code><span class="kw">def</span> setWallSide(self, val: PyBrxCv.TinWallSide) -&gt; None</code>
            <code><span class="kw">def</span> wallSide(self) -&gt; TinWallSide</code>
            <code><span class="kw">def</span> wallType(self) -&gt; TinWallType</code>
        </details>
    </div>

    <div class="class" id="CvDbVAlignment">
        <details>
            <summary>class CvDbVAlignment <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addArcAuto(self, prevId: int, nextId: int) -&gt; int</code>
            <code><span class="kw">def</span> addArcBetween(self, prevId: int, nextId: int, radius: float) -&gt; int</code>
            <code><span class="kw">def</span> addParabolaAuto(self, prevId: int, nextId: int) -&gt; int</code>
            <code><span class="kw">def</span> addParabolaBetween(self, prevId: int, nextId: int, radius: float) -&gt; int</code>
            <code><span class="kw">def</span> addTangentFixed(self, startPoint: PyGe.Point2d, endPoint: PyGe.Point2d) -&gt; int</code>
            <code><span class="kw">def</span> baseHAlignment(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> baseSurface(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVAlignment</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbVAlignment</code>
            <code><span class="kw">def</span> curveAtPVI(self, pvi: PyBrxCv.CvDbVAlignmentPVI) -&gt; int</code>
            <code><span class="kw">def</span> curveElementColor(self) -&gt; int</code>
            <code><span class="kw">def</span> deleteElement(self, id: int) -&gt; bool</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> elementAtId(self, id: int) -&gt; CvDbVAlignmentElement</code>
            <code><span class="kw">def</span> elementCount(self) -&gt; int</code>
            <code><span class="kw">def</span> elevationMax(self) -&gt; float</code>
            <code><span class="kw">def</span> elevationMin(self) -&gt; float</code>
            <code><span class="kw">def</span> firstElementId(self) -&gt; int</code>
            <code><span class="kw">def</span> firstTangentElementId(self) -&gt; int</code>
            <code><span class="kw">def</span> getElementId(self, gsMarker: int) -&gt; int</code>
            <code><span class="kw">def</span> getElevationAt(self, station: float) -&gt; tuple[bool, float]</code>
            <code><span class="kw">def</span> getElevations(self) -&gt; list[PyGe.Point2d]</code>
            <code><span class="kw">def</span> getPVIsArrays(self) -&gt; list[PyBrxCv.CvDbVAlignmentPVI]</code>
            <code><span class="kw">def</span> getRadius(self, param: float) -&gt; float</code>
            <code><span class="kw">def</span> getUnorderedElementIds(self) -&gt; list[int]</code>
            <code><span class="kw">def</span> insertTangentFixed(self, startPoint: PyGe.Point2d, endPoint: PyGe.Point2d, val: int) -&gt; int</code>
            <code><span class="kw">def</span> lastElementId(self) -&gt; int</code>
            <code><span class="kw">def</span> length(self) -&gt; float</code>
            <code><span class="kw">def</span> lineElementColor(self) -&gt; int</code>
            <code><span class="kw">def</span> nextTangentElementId(self, id: int) -&gt; int</code>
            <code><span class="kw">def</span> previousTangentElementId(self, id: int) -&gt; int</code>
            <code><span class="kw">def</span> pviAtCurve(self, curve: PyBrxCv.CvDbVAlignmentCurve) -&gt; CvDbVAlignmentPVI</code>
            <code><span class="kw">def</span> setBaseHAlignment(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> setBaseSurface(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> setCurveElementColor(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setLineElementColor(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setStyle(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setTangentPolygonColor(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setType(self, val: VAlignmentType) -&gt; bool</code>
            <code><span class="kw">def</span> style(self) -&gt; int</code>
            <code><span class="kw">def</span> tangentPolygonColor(self) -&gt; int</code>
            <code><span class="kw">def</span> type(self) -&gt; VAlignmentType</code>
            <code><span class="kw">def</span> update(self, updateDependencies: bool) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbVAlignmentArc">
        <details>
            <summary>class CvDbVAlignmentArc <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVAlignmentArc</code>
            <code><span class="kw">def</span> center(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> gradeIn(self) -&gt; float</code>
            <code><span class="kw">def</span> gradeOut(self) -&gt; float</code>
            <code><span class="kw">def</span> isClockwise(self) -&gt; bool</code>
            <code><span class="kw">def</span> radius(self) -&gt; float</code>
            <code><span class="kw">def</span> setCenter(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setClockwise(self, val: bool) -&gt; bool</code>
            <code><span class="kw">def</span> setRadius(self, val: float) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbVAlignmentCurve">
        <details>
            <summary>class CvDbVAlignmentCurve <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVAlignmentCurve</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> length(self) -&gt; float</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; PyGe.Point2d</code>
        </details>
    </div>

    <div class="class" id="CvDbVAlignmentElement">
        <details>
            <summary>class CvDbVAlignmentElement <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None
    &quot;&quot;&quot;Raises an exception.
This class cannot be instantiated from Python.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVAlignmentElement</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> id(self) -&gt; int</code>
            <code><span class="kw">def</span> nextId(self) -&gt; int</code>
            <code><span class="kw">def</span> parameterConstraint(self) -&gt; VAlignmentParameterConstraint</code>
            <code><span class="kw">def</span> previousId(self) -&gt; int</code>
            <code><span class="kw">def</span> setNextId(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setParameterConstraint(self, val: PyBrxCv.VAlignmentParameterConstraint) -&gt; bool</code>
            <code><span class="kw">def</span> setPreviousId(self, val: int) -&gt; bool</code>
            <code><span class="kw">def</span> setTangencyConstraint(self, val: PyBrxCv.VAlignmentTangencyConstraint) -&gt; bool</code>
            <code><span class="kw">def</span> tangencyConstraint(self) -&gt; VAlignmentTangencyConstraint</code>
            <code><span class="kw">def</span> type(self) -&gt; VAlignmentElementType</code>
        </details>
    </div>

    <div class="class" id="CvDbVAlignmentPVI">
        <details>
            <summary>class CvDbVAlignmentPVI <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVAlignmentPVI</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> location(self) -&gt; PyGe.Point2d</code>
        </details>
    </div>

    <div class="class" id="CvDbVAlignmentParabola">
        <details>
            <summary>class CvDbVAlignmentParabola <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVAlignmentParabola</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> gradeIn(self) -&gt; float</code>
            <code><span class="kw">def</span> gradeOut(self) -&gt; float</code>
            <code><span class="kw">def</span> radius(self) -&gt; float</code>
            <code><span class="kw">def</span> setRadius(self, val: float) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbVAlignmentTangent">
        <details>
            <summary>class CvDbVAlignmentTangent <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVAlignmentTangent</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> passThroughPoint1(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> passThroughPoint2(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> setPassThroughPoint1(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setPassThroughPoint2(self, pt: PyGe.Point2d) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbVAlignmentView">
        <details>
            <summary>class CvDbVAlignmentView <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVAlignmentView</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbVAlignmentView</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> update(self, bUpdateDependencies: bool, updateOrigin: bool) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvDbView">
        <details>
            <summary>class CvDbView <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addGraph(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> baseElevation(self) -&gt; float</code>
            <code><span class="kw">def</span> baseHAlignment(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbView</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbView</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> fromWCSPoint2d(self, pt: PyGe.Point2d) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> fromWCSX(self, val: float) -&gt; float</code>
            <code><span class="kw">def</span> fromWCSY(self, val: float) -&gt; float</code>
            <code><span class="kw">def</span> graphAt(self, val: int) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> graphCount(self) -&gt; int</code>
            <code><span class="kw">def</span> height(self) -&gt; float</code>
            <code><span class="kw">def</span> horizontalScale(self) -&gt; float</code>
            <code><span class="kw">def</span> length(self) -&gt; float</code>
            <code><span class="kw">def</span> origin(self) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> removeGraph(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> setBaseElevation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setBaseHAlignment(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> setHeight(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setHorizontalScale(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setLength(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setOrigin(self, pt: PyGe.Point2d) -&gt; bool</code>
            <code><span class="kw">def</span> setVerticalScale(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> toWCSPoint2d(self, pt: PyGe.Point2d) -&gt; PyGe.Point2d</code>
            <code><span class="kw">def</span> toWCSX(self, val: float) -&gt; float</code>
            <code><span class="kw">def</span> toWCSY(self, val: float) -&gt; float</code>
            <code><span class="kw">def</span> verticalScale(self) -&gt; float</code>
        </details>
    </div>

    <div class="class" id="CvDbVolumeSurface">
        <details>
            <summary>class CvDbVolumeSurface <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, id: PyDb.ObjectId, mode: PyDb.OpenMode, erased: bool) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> baseSurfaceObjectId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> boundingPolygon(self) -&gt; list[PyGe.Point3d]</code>
            <code><span class="kw">def</span> boundingPolygonObjectId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> cast(otherObject: PyRx.RxObject) -&gt; CvDbVolumeSurface</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cloneFrom(otherObject: PyRx.RxObject) -&gt; CvDbVolumeSurface</code>
            <code><span class="kw">def</span> comparisonSurfaceObjectId(self) -&gt; PyDb.ObjectId</code>
            <code><span class="kw">def</span> cutVolume(self) -&gt; float</code>
            <code><span class="kw">def</span> depthElevation(self) -&gt; float</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass
    &quot;&quot;&quot;Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.&quot;&quot;&quot;</code>
            <code><span class="kw">def</span> fillVolume(self) -&gt; float</code>
            <code><span class="kw">def</span> initialize(self, baseSurface: PyBrxCv.CvDbTinSurface, compSurface: PyBrxCv.CvDbTinSurface, boundingPolygon: list[PyGe.Poin3d]) -&gt; bool</code>
            <code><span class="kw">def</span> initialize(self, baseSurface: PyBrxCv.CvDbTinSurface, compSurface: PyBrxCv.CvDbTinSurface, boundingPolygon: list[PyGe.Poin3d], midOrdinateDist: float) -&gt; bool</code>
            <code><span class="kw">def</span> initialize(self, baseSurface: PyBrxCv.CvDbTinSurface, referenceElevation: float, vType: PyBrxCv.VolumeSurfaceType, boundingPolygon: list[PyGe.Poin3d]) -&gt; bool</code>
            <code><span class="kw">def</span> initialize(self, baseSurface: PyBrxCv.CvDbTinSurface, referenceElevation: float, vType: PyBrxCv.VolumeSurfaceType, boundingPolygonId: PyDb.ObjectId, midOrdinateDist: float) -&gt; bool</code>
            <code><span class="kw">def</span> initialize(*args) -&gt; bool</code>
            <code><span class="kw">def</span> type(self) -&gt; VolumeSurfaceType</code>
        </details>
    </div>

    <div class="class" id="CvGradingRule">
        <details>
            <summary>class CvGradingRule <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyBrxCv.CvGradingRule) -&gt; CvGradingRule</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> convertRadToSlope() -&gt; float</code>
            <code><span class="kw">def</span> convertSlopeToRad() -&gt; float</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool</code>
            <code><span class="kw">def</span> release(self) -&gt; bool</code>
            <code><span class="kw">def</span> setSide(self, format: int) -&gt; bool</code>
            <code><span class="kw">def</span> setSlopeFormat(self, format: int) -&gt; bool</code>
            <code><span class="kw">def</span> side(self) -&gt; GradingSide</code>
            <code><span class="kw">def</span> slopeFormat(self) -&gt; GradingSlopeFormat</code>
            <code><span class="kw">def</span> type(self) -&gt; GradingType</code>
        </details>
    </div>

    <div class="class" id="CvGradingSlopeOffsetRule">
        <details>
            <summary>class CvGradingSlopeOffsetRule <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyBrxCv.CvGradingRule) -&gt; CvGradingSlopeOffsetRule</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> offset(self) -&gt; float</code>
            <code><span class="kw">def</span> setOffset(self, offset: float) -&gt; bool</code>
            <code><span class="kw">def</span> setSlope(self, slope: float) -&gt; bool</code>
            <code><span class="kw">def</span> slope(self) -&gt; float</code>
        </details>
    </div>

    <div class="class" id="CvGradingSlopeSurfaceRule">
        <details>
            <summary>class CvGradingSlopeSurfaceRule <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> cast(otherObject: PyBrxCv.CvGradingRule) -&gt; CvGradingSlopeSurfaceRule</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> cutSlope(self) -&gt; float</code>
            <code><span class="kw">def</span> fillSlope(self) -&gt; float</code>
            <code><span class="kw">def</span> setCutSlope(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setFillSlope(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setSurfaceId(self, id: PyDb.ObjectId) -&gt; bool</code>
            <code><span class="kw">def</span> surfaceId(self) -&gt; PyDb.ObjectId</code>
        </details>
    </div>

    <div class="class" id="CvStationEquation">
        <details>
            <summary>class CvStationEquation <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, rawStation: float, stationForward: float, type: StationEquationType) -&gt; None</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> getRawStation(self) -&gt; float</code>
            <code><span class="kw">def</span> getStationForward(self) -&gt; float</code>
            <code><span class="kw">def</span> getType(self) -&gt; StationEquationType</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool</code>
            <code><span class="kw">def</span> setRawStation(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setStationForward(self, val: float) -&gt; bool</code>
            <code><span class="kw">def</span> setType(self, val: PyBrxCv.EStationEquationType) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvStationEquations">
        <details>
            <summary>class CvStationEquations <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __init__(self, alignment: PyBrxCv.CvDbHAlignment) -&gt; None</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> addStationEquation(self, equation: PyBrxCv.CvStationEquation) -&gt; bool</code>
            <code><span class="kw">def</span> className() -&gt; str</code>
            <code><span class="kw">def</span> getLengthFromRawStation(self, rawStation: float) -&gt; float</code>
            <code><span class="kw">def</span> getRawStation(self, station: float) -&gt; list[float]</code>
            <code><span class="kw">def</span> getRawStationFromLength(self, length: float) -&gt; float</code>
            <code><span class="kw">def</span> getRefRawStartingStation(self) -&gt; float</code>
            <code><span class="kw">def</span> getRefStartingLength(self) -&gt; float</code>
            <code><span class="kw">def</span> getStartingStation(self) -&gt; float</code>
            <code><span class="kw">def</span> getStation(self, rawStation: float) -&gt; float</code>
            <code><span class="kw">def</span> getStationBack(self, idx: int) -&gt; float</code>
            <code><span class="kw">def</span> getStationEquation(self, idx: int) -&gt; CvStationEquation</code>
            <code><span class="kw">def</span> removeAllStationEquations(self) -&gt; bool</code>
            <code><span class="kw">def</span> removeStationEquation(self, idx: int) -&gt; bool</code>
            <code><span class="kw">def</span> setRefRawStartingStation(self, rawStartingStation: float) -&gt; bool</code>
            <code><span class="kw">def</span> setRefStartingLength(self, startingStation: float) -&gt; bool</code>
            <code><span class="kw">def</span> stationEquationsCount(self) -&gt; int</code>
            <code><span class="kw">def</span> update(self) -&gt; bool</code>
        </details>
    </div>

    <div class="class" id="CvTinPoint">
        <details>
            <summary>class CvTinPoint <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> isValid(self) -&gt; bool</code>
            <code><span class="kw">def</span> location(self) -&gt; PyGe.Point3d</code>
            <code><span class="kw">def</span> triangleWithPoint(self) -&gt; CvTinTriangle</code>
        </details>
    </div>

    <div class="class" id="CvTinTriangle">
        <details>
            <summary>class CvTinTriangle <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any</code>
            <code><span class="kw">def</span> isValid(self) -&gt; bool</code>
            <code><span class="kw">def</span> isVisible(self) -&gt; bool</code>
            <code><span class="kw">def</span> locationAt(self, index: int) -&gt; PyGe.Point3d</code>
            <code><span class="kw">def</span> neighborAt(self, index: int) -&gt; CvTinTriangle</code>
            <code><span class="kw">def</span> pointAt(self, index: int) -&gt; CvTinPoint</code>
        </details>
    </div>

    <div class="class" id="DisplayMode">
        <details>
            <summary>class DisplayMode <span class="tag">Class</span></summary>
            <code>eDisplayModeAsComposed: ClassVar[Self]</code>
            <code>eDisplayModeStackedText: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="DisplayOrientation">
        <details>
            <summary>class DisplayOrientation <span class="tag">Class</span></summary>
            <code>eDisplayOrientationPlan: ClassVar[Self]</code>
            <code>eDisplayOrientationModel: ClassVar[Self]</code>
            <code>eDisplayOrientationProfile: ClassVar[Self]</code>
            <code>eDisplayOrientationSection: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="DrawingObjectType">
        <details>
            <summary>class DrawingObjectType <span class="tag">Class</span></summary>
            <code>eUnknown: ClassVar[Self]</code>
            <code>ePoint: ClassVar[Self]</code>
            <code>eBlock: ClassVar[Self]</code>
            <code>eText: ClassVar[Self]</code>
            <code>eLine: ClassVar[Self]</code>
            <code>eFace: ClassVar[Self]</code>
            <code>ePolyline: ClassVar[Self]</code>
            <code>eCivilPoint: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ForcedInsertion">
        <details>
            <summary>class ForcedInsertion <span class="tag">Class</span></summary>
            <code>eForcedInsertionNone: ClassVar[Self]</code>
            <code>eForcedInsertionTop: ClassVar[Self]</code>
            <code>eForcedInsertionBottom: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="GradingCalculationMethod">
        <details>
            <summary>class GradingCalculationMethod <span class="tag">Class</span></summary>
            <code>eGradingAccurate: ClassVar[Self]</code>
            <code>eGradingFast: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="GradingSide">
        <details>
            <summary>class GradingSide <span class="tag">Class</span></summary>
            <code>eGradingSideNone: ClassVar[Self]</code>
            <code>eGradingSideLeft: ClassVar[Self]</code>
            <code>eGradingSideRight: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="GradingSlopeFormat">
        <details>
            <summary>class GradingSlopeFormat <span class="tag">Class</span></summary>
            <code>eSlopeNoFormat: ClassVar[Self]</code>
            <code>eSlopeRiseRun: ClassVar[Self]</code>
            <code>eSlopeDegrees: ClassVar[Self]</code>
            <code>eSlopePercent: ClassVar[Self]</code>
            <code>eSlopeRadians: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="GradingStatus">
        <details>
            <summary>class GradingStatus <span class="tag">Class</span></summary>
            <code>eGradingNoStatus: ClassVar[Self]</code>
            <code>eGradingOk: ClassVar[Self]</code>
            <code>eGradingUpdateNeeded: ClassVar[Self]</code>
            <code>eGradingIncorrectInputData: ClassVar[Self]</code>
            <code>eGradingSurfaceMissing: ClassVar[Self]</code>
            <code>eGradingRuleMissing: ClassVar[Self]</code>
            <code>eGradingInputDataOutsideSurface: ClassVar[Self]</code>
            <code>eGradingGradingOutsideSurface: ClassVar[Self]</code>
            <code>eGradingOffsetFailed: ClassVar[Self]</code>
            <code>eGradingMultipleOffsetResult: ClassVar[Self]</code>
            <code>eGradingZeroGrading: ClassVar[Self]</code>
            <code>eGradingUnknownError: ClassVar[Self]</code>
            <code>eGradingInputDataMissing: ClassVar[Self]</code>
            <code>eGradingInvalidInput: ClassVar[Self]</code>
            <code>eGradingInvalidRule: ClassVar[Self]</code>
            <code>eGradingTimeout: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="GradingType">
        <details>
            <summary>class GradingType <span class="tag">Class</span></summary>
            <code>eGradingTypeNone: ClassVar[Self]</code>
            <code>eGradingTypeSlopeSurface: ClassVar[Self]</code>
            <code>eGradingTypeSlopeOffset: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="GradingVisualStyle">
        <details>
            <summary>class GradingVisualStyle <span class="tag">Class</span></summary>
            <code>eGradingDrawNothing: ClassVar[Self]</code>
            <code>eGradingDrawSurface: ClassVar[Self]</code>
            <code>eGradingDrawRays: ClassVar[Self]</code>
            <code>eGradingDrawDaylight: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="HAlignmentElementType">
        <details>
            <summary>class HAlignmentElementType <span class="tag">Class</span></summary>
            <code>eUndefined: ClassVar[Self]</code>
            <code>eLine: ClassVar[Self]</code>
            <code>eArc: ClassVar[Self]</code>
            <code>eSpiral: ClassVar[Self]</code>
            <code>eSpiralCurveSpiral: ClassVar[Self]</code>
            <code>eSpiralLineSpiral: ClassVar[Self]</code>
            <code>eSpiralLine: ClassVar[Self]</code>
            <code>eLineSpiral: ClassVar[Self]</code>
            <code>eSpiralCurve: ClassVar[Self]</code>
            <code>eCurveSpiral: ClassVar[Self]</code>
            <code>eSpiralSpiralCurveSpiralSpiral: ClassVar[Self]</code>
            <code>eMultipleSegments: ClassVar[Self]</code>
            <code>eSpiralCurveSpiralCurveSpiral: ClassVar[Self]</code>
            <code>eSpiralCurveSpiralSpiralCurveSpiral: ClassVar[Self]</code>
            <code>eSpiralSpiral: ClassVar[Self]</code>
            <code>eSpiralSpiralCurve: ClassVar[Self]</code>
            <code>eCurveSpiralSpiral: ClassVar[Self]</code>
            <code>eCurveLineCurve: ClassVar[Self]</code>
            <code>eCurveReverseCurve: ClassVar[Self]</code>
            <code>eCurveCurveReverseCurve: ClassVar[Self]</code>
            <code>ePI: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="HAlignmentParameterConstraint">
        <details>
            <summary>class HAlignmentParameterConstraint <span class="tag">Class</span></summary>
            <code>eUndefined: ClassVar[Self]</code>
            <code>eAutomatic: ClassVar[Self]</code>
            <code>eLine_TwoPoints: ClassVar[Self]</code>
            <code>eLine_ThroughPoint: ClassVar[Self]</code>
            <code>eLine_Length: ClassVar[Self]</code>
            <code>eLine_BestFit: ClassVar[Self]</code>
            <code>eArc_ThreePoints: ClassVar[Self]</code>
            <code>eArc_CenterRadius: ClassVar[Self]</code>
            <code>eArc_CenterPassThrough: ClassVar[Self]</code>
            <code>eArc_PassThroughRadius: ClassVar[Self]</code>
            <code>eArc_PassThroughAttachToEnd: ClassVar[Self]</code>
            <code>eArc_PassThroughDirection: ClassVar[Self]</code>
            <code>eArc_Radius: ClassVar[Self]</code>
            <code>eArc_PassThrough: ClassVar[Self]</code>
            <code>eArc_RadiusAndLength: ClassVar[Self]</code>
            <code>eArc_PointOnTangent: ClassVar[Self]</code>
            <code>eArc_BestFit: ClassVar[Self]</code>
            <code>eSCS_SpiralInRadiusSpiralOut: ClassVar[Self]</code>
            <code>eSCS_SpiralLengthRadiusPassThrough: ClassVar[Self]</code>
            <code>eSCS_SpiralLengthRadiusArcLength: ClassVar[Self]</code>
            <code>eSCS_SpiralLengthRadius: ClassVar[Self]</code>
            <code>eSCS_SpiralLength: ClassVar[Self]</code>
            <code>eSCS_SpiralInLengthSpiralOutLength: ClassVar[Self]</code>
            <code>eSCS_SpiralInAValSpiralOutAVal: ClassVar[Self]</code>
            <code>eSCS_SpiralInAValRadiusSpiralOutAVal: ClassVar[Self]</code>
            <code>eSCS_SpiralAValRadiusPassThrough: ClassVar[Self]</code>
            <code>eSCS_SpiralAValRadiusArcLength: ClassVar[Self]</code>
            <code>eSCS_SpiralAValRadius: ClassVar[Self]</code>
            <code>eSCS_SpiralAVal: ClassVar[Self]</code>
            <code>eSCS_PointOnTangent: ClassVar[Self]</code>
            <code>eSpiral_StartPointDirRadiusLength: ClassVar[Self]</code>
            <code>eSpiral_StartPointDirStartAndEndRadiusLength: ClassVar[Self]</code>
            <code>eSTS_SpiralInLengthSpiralOutLength: ClassVar[Self]</code>
            <code>eSTS_TangentLength: ClassVar[Self]</code>
            <code>eSTS_SpiralInAValSpiralOutAVal: ClassVar[Self]</code>
            <code>eSTS_SpiralLengthTangentPassThrough: ClassVar[Self]</code>
            <code>eSTS_SpiralLengthTangentLength: ClassVar[Self]</code>
            <code>eSTS_SpiralAValTangentPassThrough: ClassVar[Self]</code>
            <code>eSTS_SpiralAValTangentLength: ClassVar[Self]</code>
            <code>eSSCSS_Sp1LenSp2LenRadiusPt: ClassVar[Self]</code>
            <code>eSSCSS_Sp1LenSp2LenPt1Pt2: ClassVar[Self]</code>
            <code>eSSCSS_Sp1AValSp2AValRadiusPt: ClassVar[Self]</code>
            <code>eSSCSS_Sp1AValSp2AValPt1Pt2: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="HAlignmentTangencyConstraint">
        <details>
            <summary>class HAlignmentTangencyConstraint <span class="tag">Class</span></summary>
            <code>eUndefined: ClassVar[Self]</code>
            <code>eFixed: ClassVar[Self]</code>
            <code>ePrevious: ClassVar[Self]</code>
            <code>eNext: ClassVar[Self]</code>
            <code>eBoth: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="HAlignmentVisualStyle">
        <details>
            <summary>class HAlignmentVisualStyle <span class="tag">Class</span></summary>
            <code>eUndefined: ClassVar[Self]</code>
            <code>eElements: ClassVar[Self]</code>
            <code>eTangentExtensions: ClassVar[Self]</code>
            <code>eElementExtensions: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="LabelAnchor">
        <details>
            <summary>class LabelAnchor <span class="tag">Class</span></summary>
            <code>eLabelAnchors: ClassVar[Self]</code>
            <code>eLabelAnchorStart: ClassVar[Self]</code>
            <code>eLabelAnchorMiddle: ClassVar[Self]</code>
            <code>eLabelAnchorEnd: ClassVar[Self]</code>
            <code>eLabelAnchorTopLeft: ClassVar[Self]</code>
            <code>eLabelAnchorTopCenter: ClassVar[Self]</code>
            <code>eLabelAnchorTopRight: ClassVar[Self]</code>
            <code>eLabelAnchorMiddleLeft: ClassVar[Self]</code>
            <code>eLabelAnchorMiddleCenter: ClassVar[Self]</code>
            <code>eLabelAnchorMiddleRight: ClassVar[Self]</code>
            <code>eLabelAnchorBottomLeft: ClassVar[Self]</code>
            <code>eLabelAnchorBottomCenter: ClassVar[Self]</code>
            <code>eLabelAnchorBottomRight: ClassVar[Self]</code>
            <code>eLabelAnchorInsertionPoint: ClassVar[Self]</code>
            <code>eLabelAnchorCurveCenter: ClassVar[Self]</code>
            <code>eLabelAnchorCurvePI: ClassVar[Self]</code>
            <code>eLabelAnchorFeatureLocation: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="LeaderAttachment">
        <details>
            <summary>class LeaderAttachment <span class="tag">Class</span></summary>
            <code>eLeaderAttachmentTopOfTopLine: ClassVar[Self]</code>
            <code>eLeaderAttachmentMiddleOfTopLine: ClassVar[Self]</code>
            <code>eLeaderAttachmentMiddle: ClassVar[Self]</code>
            <code>eLeaderAttachmentMiddleOfBottomLine: ClassVar[Self]</code>
            <code>eLeaderAttachmentBottomOfBottomLine: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="LeaderType">
        <details>
            <summary>class LeaderType <span class="tag">Class</span></summary>
            <code>eLeaderTypeStraight: ClassVar[Self]</code>
            <code>eLeaderTypeSpline: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="LengthType">
        <details>
            <summary>class LengthType <span class="tag">Class</span></summary>
            <code>eLengthTypeFixed: ClassVar[Self]</code>
            <code>eLengthTypePercentage: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="OrientationRef">
        <details>
            <summary>class OrientationRef <span class="tag">Class</span></summary>
            <code>eOrientationReferenceObject: ClassVar[Self]</code>
            <code>eOrientationReferenceView: ClassVar[Self]</code>
            <code>eOrientationReferenceWCS: ClassVar[Self]</code>
            <code>eOrientationReferenceStartLeaderAtMarker: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ScalingType">
        <details>
            <summary>class ScalingType <span class="tag">Class</span></summary>
            <code>eScalingTypeDrawingScale: ClassVar[Self]</code>
            <code>eScalingTypeFixedScale: ClassVar[Self]</code>
            <code>eScalingTypeAbsoluteUnits: ClassVar[Self]</code>
            <code>eScalingTypeRelativeToScreen: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SpiralCurveType">
        <details>
            <summary>class SpiralCurveType <span class="tag">Class</span></summary>
            <code>eInCurve: ClassVar[Self]</code>
            <code>eOutCurve: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SpiralDefinitionType">
        <details>
            <summary>class SpiralDefinitionType <span class="tag">Class</span></summary>
            <code>eClothoid: ClassVar[Self]</code>
            <code>eCubicParabola: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SpiralDefinitionTypeSpiral">
        <details>
            <summary>class SpiralDefinitionTypeSpiral <span class="tag">Class</span></summary>
            <code>eClothoid: ClassVar[Self]</code>
            <code>eCubicParabola: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SpiralDirectionType">
        <details>
            <summary>class SpiralDirectionType <span class="tag">Class</span></summary>
            <code>eDirectionRight: ClassVar[Self]</code>
            <code>eDirectionLeft: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SpiralParameterType">
        <details>
            <summary>class SpiralParameterType <span class="tag">Class</span></summary>
            <code>eClothoid: ClassVar[Self]</code>
            <code>eCubicParabola: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SpiralParameterType2">
        <details>
            <summary>class SpiralParameterType2 <span class="tag">Class</span></summary>
            <code>eParamA: ClassVar[Self]</code>
            <code>eParamLength: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="StationEquationType">
        <details>
            <summary>class StationEquationType <span class="tag">Class</span></summary>
            <code>Increasing: ClassVar[Self]</code>
            <code>Decreasing: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="StyleManagerType">
        <details>
            <summary>class StyleManagerType <span class="tag">Class</span></summary>
            <code>eSymbolStyle: ClassVar[Self]</code>
            <code>eLineLabel: ClassVar[Self]</code>
            <code>eCurveLabel: ClassVar[Self]</code>
            <code>ePointLabel: ClassVar[Self]</code>
            <code>eContourLabel: ClassVar[Self]</code>
            <code>eSurfaceSlopeLabel: ClassVar[Self]</code>
            <code>eSurfaceElevationLabel: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SymbolType">
        <details>
            <summary>class SymbolType <span class="tag">Class</span></summary>
            <code>eSymbolTypeACADPoint: ClassVar[Self]</code>
            <code>eSymbolTypeCustom: ClassVar[Self]</code>
            <code>eSymbolTypeBlock: ClassVar[Self]</code>
            <code>eSymbolTypeVerticalLine: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinBoundaryType">
        <details>
            <summary>class TinBoundaryType <span class="tag">Class</span></summary>
            <code>eTinShow: ClassVar[Self]</code>
            <code>eTinHide: ClassVar[Self]</code>
            <code>eTinOuter: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinBreaklineType">
        <details>
            <summary>class TinBreaklineType <span class="tag">Class</span></summary>
            <code>eTinBreaklineNormal: ClassVar[Self]</code>
            <code>eTinNonDestructive: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinConstraintType">
        <details>
            <summary>class TinConstraintType <span class="tag">Class</span></summary>
            <code>eTinBreakline: ClassVar[Self]</code>
            <code>eTinBoundary: ClassVar[Self]</code>
            <code>eTinWall: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinIntersectionElevation">
        <details>
            <summary>class TinIntersectionElevation <span class="tag">Class</span></summary>
            <code>eTinNotAllowed: ClassVar[Self]</code>
            <code>eTinElevationMin: ClassVar[Self]</code>
            <code>eTinElevationMax: ClassVar[Self]</code>
            <code>eTinElevationMid: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinSurfaceDefinitionType">
        <details>
            <summary>class TinSurfaceDefinitionType <span class="tag">Class</span></summary>
            <code>eNone: ClassVar[Self]</code>
            <code>eTransform: ClassVar[Self]</code>
            <code>eAddPoint: ClassVar[Self]</code>
            <code>eAddPoints: ClassVar[Self]</code>
            <code>eDeletePoint: ClassVar[Self]</code>
            <code>eDeletePoints: ClassVar[Self]</code>
            <code>eSwapEdge: ClassVar[Self]</code>
            <code>eMovePoint: ClassVar[Self]</code>
            <code>eMovePoints: ClassVar[Self]</code>
            <code>eAddBreaklines: ClassVar[Self]</code>
            <code>eAddBoundaries: ClassVar[Self]</code>
            <code>eAddWalls: ClassVar[Self]</code>
            <code>eVolume: ClassVar[Self]</code>
            <code>eMerge: ClassVar[Self]</code>
            <code>eDeleteEdge: ClassVar[Self]</code>
            <code>eDeleteEdges: ClassVar[Self]</code>
            <code>eAddLine: ClassVar[Self]</code>
            <code>eAddLines: ClassVar[Self]</code>
            <code>eModifyPointElevation: ClassVar[Self]</code>
            <code>eModifyPointsElevation: ClassVar[Self]</code>
            <code>eModifyPointsElevations: ClassVar[Self]</code>
            <code>eCreateFromFaces: ClassVar[Self]</code>
            <code>eAddDrawingObjects: ClassVar[Self]</code>
            <code>eCreateSnapshot: ClassVar[Self]</code>
            <code>eRiseLower: ClassVar[Self]</code>
            <code>eLandXML: ClassVar[Self]</code>
            <code>eAddPointFiles: ClassVar[Self]</code>
            <code>eAddPointGroups: ClassVar[Self]</code>
            <code>eAddPointClouds: ClassVar[Self]</code>
            <code>eGroupDefinitions: ClassVar[Self]</code>
            <code>eDeform: ClassVar[Self]</code>
            <code>eSmoothen: ClassVar[Self]</code>
            <code>eCreateMerged: ClassVar[Self]</code>
            <code>eIFC: ClassVar[Self]</code>
            <code>eCreateTypedSnapshot: ClassVar[Self]</code>
            <code>eCreateFromCorridor: ClassVar[Self]</code>
            <code>eCreateFromC3D: ClassVar[Self]</code>
            <code>eRemoveOuterEdges: ClassVar[Self]</code>
            <code>eCreateFromContours: ClassVar[Self]</code>
            <code>eMinimizeFlatAreas: ClassVar[Self]</code>
            <code>eTrianglesVisibility: ClassVar[Self]</code>
            <code>eRemoveBelowAboveElevation: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinSurfaceIntersectType">
        <details>
            <summary>class TinSurfaceIntersectType <span class="tag">Class</span></summary>
            <code>eTinSurfaceFirstOnly: ClassVar[Self]</code>
            <code>eTinSurfaceAll: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinSurfaceMeshType">
        <details>
            <summary>class TinSurfaceMeshType <span class="tag">Class</span></summary>
            <code>eTinSurfaceMeshSurface: ClassVar[Self]</code>
            <code>eTinSurfaceMeshElevation: ClassVar[Self]</code>
            <code>eTinSurfaceMeshDepth: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinSurfaceSolidType">
        <details>
            <summary>class TinSurfaceSolidType <span class="tag">Class</span></summary>
            <code>eSolidTypeSurfaceSurface: ClassVar[Self]</code>
            <code>eSolidTypeSurfaceElevation: ClassVar[Self]</code>
            <code>eSolidTypeSurfaceDepth: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinSurfaceStyle">
        <details>
            <summary>class TinSurfaceStyle <span class="tag">Class</span></summary>
            <code>eTinStyleNone: ClassVar[Self]</code>
            <code>eTinStyleBoundaryLine: ClassVar[Self]</code>
            <code>eTinStylePoints: ClassVar[Self]</code>
            <code>eTinStyleTriangles: ClassVar[Self]</code>
            <code>eTinStyleContours: ClassVar[Self]</code>
            <code>eTinStyleElevationTooltip: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinWallSide">
        <details>
            <summary>class TinWallSide <span class="tag">Class</span></summary>
            <code>eTinWallLeft: ClassVar[Self]</code>
            <code>eTinWallRight: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TinWallType">
        <details>
            <summary>class TinWallType <span class="tag">Class</span></summary>
            <code>eTinWallNormal: ClassVar[Self]</code>
            <code>eTinWallProjected: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="VAlignmentElementType">
        <details>
            <summary>class VAlignmentElementType <span class="tag">Class</span></summary>
            <code>eUndefined: ClassVar[Self]</code>
            <code>eTangent: ClassVar[Self]</code>
            <code>eArc: ClassVar[Self]</code>
            <code>eParabola: ClassVar[Self]</code>
            <code>ePVI: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="VAlignmentParameterConstraint">
        <details>
            <summary>class VAlignmentParameterConstraint <span class="tag">Class</span></summary>
            <code>eUndefined: ClassVar[Self]</code>
            <code>ePassThroughPoints: ClassVar[Self]</code>
            <code>eRadius: ClassVar[Self]</code>
            <code>eLength: ClassVar[Self]</code>
            <code>eAngle: ClassVar[Self]</code>
            <code>eAutomatic: ClassVar[Self]</code>
            <code>ePointOnTangent: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="VAlignmentTangencyConstraint">
        <details>
            <summary>class VAlignmentTangencyConstraint <span class="tag">Class</span></summary>
            <code>eUndefined: ClassVar[Self]</code>
            <code>eFixed: ClassVar[Self]</code>
            <code>ePrevious: ClassVar[Self]</code>
            <code>eNext: ClassVar[Self]</code>
            <code>eBoth: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="VAlignmentType">
        <details>
            <summary>class VAlignmentType <span class="tag">Class</span></summary>
            <code>eLayout: ClassVar[Self]</code>
            <code>eStaticSurface: ClassVar[Self]</code>
            <code>eDynamicSurface: ClassVar[Self]</code>
            <code>eAutomatic: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="VAlignmentVisualStyle">
        <details>
            <summary>class VAlignmentVisualStyle <span class="tag">Class</span></summary>
            <code>eElements: ClassVar[Self]</code>
            <code>eTangents: ClassVar[Self]</code>
            <code>eExtensions: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="VolumeSurfaceType">
        <details>
            <summary>class VolumeSurfaceType <span class="tag">Class</span></summary>
            <code>eTinVolumeBaseComparison: ClassVar[Self]</code>
            <code>eTinVolumeToElevation: ClassVar[Self]</code>
            <code>eTinVolumeToDepth: ClassVar[Self]</code>
        </details>
    </div>
</body>
</html>