<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PyGi.pyi</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: Consolas, monospace;
            margin: 2em;
        }
        a {
            color: #569cd6;
        }
        .class {
            margin-bottom: 1em;
        }
        summary {
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }
        details {
            margin-left: 0.5em;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            padding: 0.5em;
        }
        code {
            display: block;
            margin: 0.3em 0;
            white-space: pre;
            background-color: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4em 0.6em;
            border-left: 4px solid #007acc;
            font-size: 1.2em;
        }
        .kw {
            color: #569cd6;
            font-weight: bold;
        }
        .ds {
            color: #FF8787;
            opacity: 0.7;
        }
        h1 {
            color: #569cd6;
        }
        .tag {
            background: #007acc;
            color: #fff;
            border-radius: 4px;
            padding: 0.1em 0.5em;
            font-size: 0.9em;
            margin-left: 0.5em;
        }
        .toc {
            margin-bottom: 2em;
        }
    </style>
</head>
<body>
    <h1>PyGi.pyi</h1>
    <div class="toc">
        <h2>Classes</h2>
        <ul>
            <li><a href="#ArcType">ArcType</a></li>
            <li><a href="#CommonDraw">CommonDraw</a></li>
            <li><a href="#DefaultLightingType">DefaultLightingType</a></li>
            <li><a href="#DrawFlags">DrawFlags</a></li>
            <li><a href="#Drawable">Drawable</a></li>
            <li><a href="#DrawableOverrule">DrawableOverrule</a></li>
            <li><a href="#DrawableTraits">DrawableTraits</a></li>
            <li><a href="#FillType">FillType</a></li>
            <li><a href="#Geometry">Geometry</a></li>
            <li><a href="#GiAttributesFlags">GiAttributesFlags</a></li>
            <li><a href="#GiDrawableType">GiDrawableType</a></li>
            <li><a href="#GiGraphicsKernel">GiGraphicsKernel</a></li>
            <li><a href="#GiKernelDescriptor">GiKernelDescriptor</a></li>
            <li><a href="#OrientationTransformBehavior">OrientationTransformBehavior</a></li>
            <li><a href="#OrientationType">OrientationType</a></li>
            <li><a href="#PixelBGRA32Array">PixelBGRA32Array</a></li>
            <li><a href="#PositionTransformBehavior">PositionTransformBehavior</a></li>
            <li><a href="#RegenType">RegenType</a></li>
            <li><a href="#ScaleTransformBehavior">ScaleTransformBehavior</a></li>
            <li><a href="#SelectionFlags">SelectionFlags</a></li>
            <li><a href="#ShadowFlags">ShadowFlags</a></li>
            <li><a href="#SubEntityTraits">SubEntityTraits</a></li>
            <li><a href="#TransientDrawingMode">TransientDrawingMode</a></li>
            <li><a href="#TransientManager">TransientManager</a></li>
            <li><a href="#TransparencyMode">TransparencyMode</a></li>
            <li><a href="#ViewportDraw">ViewportDraw</a></li>
            <li><a href="#ViewportGeometry">ViewportGeometry</a></li>
            <li><a href="#Visibility">Visibility</a></li>
            <li><a href="#WorldDraw">WorldDraw</a></li>
            <li><a href="#WorldGeometry">WorldGeometry</a></li>
        </ul>
    </div>

    <div class="class" id="ArcType">
        <details>
            <summary>class ArcType <span class="tag">Class</span></summary>
            <code>kAcGiArcSimple: ClassVar[Self]</code>
            <code>kAcGiArcSector: ClassVar[Self]</code>
            <code>kAcGiArcChord: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="CommonDraw">
        <details>
            <summary>class CommonDraw <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> isDragging(self) -&gt; bool:
    <span class="ds">Returns Adesk::kTrue if the entity is currently being dragged; otherwise, returns
Adesk::kFalse. Graphically complex entities might find that using a simpler graphical
representation during dragging enhances performance with little or no loss of
functionality.</span></code>
            <code><span class="kw">def</span> regenAbort(self) -&gt; bool:
    <span class="ds">Provides a means to find out if an immediate termination of the graphics regeneration is
requested by the system. If the return value is Adesk::kFalse, then all is well. But, if
the return value is Adesk::kTrue, then an immediate clean up and return should be
accomplished.</span></code>
            <code><span class="kw">def</span> regenType(self) -&gt; RegenType:
    <span class="ds">Returns the current elaboration mode. The current elaboration modes of type AcGiRegenType
are: kAcGiStandardDisplay The display you normally see is being generated (REGEN).
kAcGiHideOrShadeCommand The HIDE or SHADE command is being executed. kAcGRenderCommand The
RENDER command is being executed. kAcGiSaveWorldDrawForProxy The graphics will be going
into the entity&#x27;s graphics metafile in case the entity is a proxy when next loaded, so
provide graphics for proxy representation. This information allows the user to take special
action for the four different situations. Normally, you may not need to consider which mode
is in effect. However, if RENDER is running, then only geometry with filled area is
accepted (filled polygon, etc.); other geometry (polyline, unfilled polygon, etc.) is
ignored.</span></code>
            <code><span class="kw">def</span> subEntityTraits(self) -&gt; SubEntityTraits:
    <span class="ds">Returns a reference to the AcGiSubEntityTraits object. The subEntityTraits object gives the
user control of, and access to, the attribute (color, layer, linetype, etc.) settings of
the current geometry. For a description of this object, see class AcGiSubEntityTraits.</span></code>
        </details>
    </div>

    <div class="class" id="DefaultLightingType">
        <details>
            <summary>class DefaultLightingType <span class="tag">Class</span></summary>
            <code>kOneDistantLight: ClassVar[Self]</code>
            <code>kTwoDistantLights: ClassVar[Self]</code>
            <code>kBackLighting: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="DrawFlags">
        <details>
            <summary>class DrawFlags <span class="tag">Class</span></summary>
            <code>kNoDrawFlags: ClassVar[Self]</code>
            <code>kDrawHatchGroup: ClassVar[Self]</code>
            <code>kDrawFrontfacesOnly: ClassVar[Self]</code>
            <code>kDrawGradientFill: ClassVar[Self]</code>
            <code>kDrawSolidFill: ClassVar[Self]</code>
            <code>kDrawNoLineWeight: ClassVar[Self]</code>
            <code>kDrawNoOptimization: ClassVar[Self]</code>
            <code>kDrawUseAcGiEntityForDgnLineType: ClassVar[Self]</code>
            <code>kDrawFillTextBoundaryStart: ClassVar[Self]</code>
            <code>kDrawFillTextBoundaryEnd: ClassVar[Self]</code>
            <code>kDrawFillSelectionWindow: ClassVar[Self]</code>
            <code>kDrawNoForceByLayer: ClassVar[Self]</code>
            <code>kDrawIsInWCS: ClassVar[Self]</code>
            <code>kDrawNoImageFrame: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Drawable">
        <details>
            <summary>class Drawable <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> bounds(self, ext: PyDb.Extents) -&gt; bool:
    <span class="ds">This method returns reasonable, but not necessarily precise, bounds for the drawable. In
the case of nested drawables, the bounds of any child drawables are included as well. In
the case of view-dependent geometries, or other drawables with potentially varying bounds,
the union of all possible representations is returned. In the case of uncertain extents or
infinite extents (such as an infinite line or ray), the method returns False to indicate
the bounds are not available. The behavior of the drawable is undefined if the geometry
created by the drawable in its viewportDraw() and/or worldDraw() implementation extends
outside the bounds returned by AcGiDrawable::bounds().</span></code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> drawableType(self) -&gt; GiDrawableType:
    <span class="ds">Returns the type of the current drawable.</span></code>
            <code><span class="kw">def</span> id(self) -&gt; PyDb.ObjectId:
    <span class="ds">This function returns the database ID that corresponds to this drawable (if the drawable is
persistent).</span></code>
            <code><span class="kw">def</span> isPersistent(self) -&gt; bool:
    <span class="ds">This function will determine if the calling AcGiDrawable object is persistent (stored in a
database). Returns Adesk::kTrue if the AcGiDrawable object is database resident (belongs to
an AcGsModel that requires the use of open and close functions). Returns Adesk::kFalse if
the AcGiDrawable object is non-persistent (pointer-based); these drawables are accessed
directly through their AcGiDrawable pointer.</span></code>
            <code><span class="kw">def</span> rolloverHit(self, nSubentId: int, nMouseFlags: int, bReset: bool) -&gt; bool:
    <span class="ds">For internal use only.</span></code>
            <code><span class="kw">def</span> setAttributes(self, traits: PyGi.DrawableTraits) -&gt; int:
    <span class="ds">This function will take the input AcGiDrawableTraits object and set the values for the
current object&#x27;s subentity traits. The setAttributes() method is called by the GS to setup
a drawable&#x27;s default attributes. The current rendering state will employ these ambient
attributes before worldDraw() and viewportDraw() are executed (and for the 3D GS before
their cached geometry is drawn).</span></code>
            <code><span class="kw">def</span> viewportDraw(self, vpdraw: PyGi.ViewportDraw) -&gt; None:
    <span class="ds">In response to viewportDraw(), a drawable uses the passed in AcGiViewportDraw interface to
describe its view-dependent geometry. This function is called per view; the results may be
cached, but the 3D GS guarantees it will call viewportDraw() (if specified by the return
value from worldDraw()) for each view and whenever the view parameters are modified. See
AcGsView for more information.</span></code>
            <code><span class="kw">def</span> viewportDrawLogicalFlags(self, vpdraw: PyGi.ViewportDraw) -&gt; int:
    <span class="ds">Entity implementers who desire view-independent viewportDraw caching must provide a
meaningful response to this API -- the return value is a combination of the
AcGiDrawablesetAttributes flags. In particular, the graphic system is watching for the
kDrawableRegenTypeDependantGeometry flag which indicates that the entity in this logical
set employs isolines. The passed in AcGiViewportDraw context can be used by the drawable to
help determine which logical set is being regenerated.</span></code>
            <code><span class="kw">def</span> worldDraw(self, wdraw: PyGi.WorldDraw) -&gt; bool:
    <span class="ds">In response to worldDraw(), a drawable uses the passed-in AcGiWorldDraw interface to
describe its geometry that is sharable across viewports. The 3D GS guarantees that this
function will be called at least once, but subsequent display updates may be cached. Use
AcGsModel::onModified() to invalidate any cache that the GS has associated with a drawable
so that worldDraw() will again be called upon the next display update. A return value of
Adesk::kFalse indicates that the 3D GS must call viewportDraw() in order to obtain the
complete geometry and attribute set for this drawable.</span></code>
        </details>
    </div>

    <div class="class" id="DrawableOverrule">
        <details>
            <summary>class DrawableOverrule <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> baseViewportDraw(self) -&gt; None:</code>
            <code><span class="kw">def</span> baseViewportDrawLogicalFlags(self) -&gt; int:</code>
            <code><span class="kw">def</span> baseWorldDraw(self) -&gt; bool:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:</code>
            <code><span class="kw">def</span> isApplicable(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setAttributes(self) -&gt; int:</code>
            <code><span class="kw">def</span> viewportDraw(self) -&gt; None:</code>
            <code><span class="kw">def</span> viewportDrawLogicalFlags(self) -&gt; int:</code>
            <code><span class="kw">def</span> worldDraw(self) -&gt; bool:</code>
        </details>
    </div>

    <div class="class" id="DrawableTraits">
        <details>
            <summary>class DrawableTraits <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> setupForEntity(self, entity: PyDb.Entity) -&gt; None:
    <span class="ds">This call initializes the entire AcGiSubEntityTraits and AcGiDrawableTraits from the
entity. This is more efficient than setting each property individually. The default
implemetation of AcDbEntity::setAttributes() uses this method. If you are implementing AcGi
you need not implement this method since and implementation is supplied which delegates to
the setXXX methods in AcGiSubEntityTraits.</span></code>
        </details>
    </div>

    <div class="class" id="FillType">
        <details>
            <summary>class FillType <span class="tag">Class</span></summary>
            <code>kAcGiFillAlways: ClassVar[Self]</code>
            <code>kAcGiFillNever: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Geometry">
        <details>
            <summary>class Geometry <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> circle(self, center: PyGe.Point3d, radius: float, normal: PyGe.Vector3d) -&gt; bool:
    <span class="ds">Displays a circle primitive with center at center and a radius of radius. The circle is on
the plane defined by the normal vector normal and the point center. A return value of
Adesk::kFalse (that is, 0) indicates that the primitive has been successfully stored in the
graphics database. A return value of Adesk::kTrue indicates that the operation has been
terminated and the application wants to get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> circle(self, p1: PyGe.Point3d, p2: PyGe.Point3d, p3: PyGe.Point3d) -&gt; bool:
    <span class="ds">Displays a circle primitive with center at center and a radius of radius. The circle is on
the plane defined by the normal vector normal and the point center. A return value of
Adesk::kFalse (that is, 0) indicates that the primitive has been successfully stored in the
graphics database. A return value of Adesk::kTrue indicates that the operation has been
terminated and the application wants to get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> circle(*args) -&gt; bool:
    <span class="ds">Displays a circle primitive with center at center and a radius of radius. The circle is on
the plane defined by the normal vector normal and the point center. A return value of
Adesk::kFalse (that is, 0) indicates that the primitive has been successfully stored in the
graphics database. A return value of Adesk::kTrue indicates that the operation has been
terminated and the application wants to get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> circularArc(self, center: PyGe.Point3d, radius: float, normal: PyGe.Vector3d, startVector: PyGe.Vector3d, sweepAngle: float) -&gt; bool:
    <span class="ds">Displays an arc primitive defined by the arc&#x27;s center of curvature center, the radius of
curvature radius, the containment plane&#x27;s normal vector normal, the vector from the center
of curvature to the arc start point startVector, the angle that the arc spans sweepAngle,
and the arc type arcType. A return value of Adesk::kFalse (that is, 0) indicates that the
primitive has been successfully stored in the graphics database. A return value of
Adesk::kTrue indicates that the operation has been terminated and the application wants to
get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> circularArc(self, center: PyGe.Point3d, radius: float, normal: PyGe.Vector3d, startVector: PyGe.Vector3d, sweepAngle: float, arcType: PyGi.ArcType) -&gt; bool:
    <span class="ds">Displays an arc primitive defined by the arc&#x27;s center of curvature center, the radius of
curvature radius, the containment plane&#x27;s normal vector normal, the vector from the center
of curvature to the arc start point startVector, the angle that the arc spans sweepAngle,
and the arc type arcType. A return value of Adesk::kFalse (that is, 0) indicates that the
primitive has been successfully stored in the graphics database. A return value of
Adesk::kTrue indicates that the operation has been terminated and the application wants to
get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> circularArc(self, p1: PyGe.Point3d, p2: PyGe.Point3d, p3: PyGe.Point3d) -&gt; bool:
    <span class="ds">Displays an arc primitive defined by the arc&#x27;s center of curvature center, the radius of
curvature radius, the containment plane&#x27;s normal vector normal, the vector from the center
of curvature to the arc start point startVector, the angle that the arc spans sweepAngle,
and the arc type arcType. A return value of Adesk::kFalse (that is, 0) indicates that the
primitive has been successfully stored in the graphics database. A return value of
Adesk::kTrue indicates that the operation has been terminated and the application wants to
get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> circularArc(self, p1: PyGe.Point3d, p2: PyGe.Point3d, p3: PyGe.Point3d, arcType: PyGe.ArcType) -&gt; bool:
    <span class="ds">Displays an arc primitive defined by the arc&#x27;s center of curvature center, the radius of
curvature radius, the containment plane&#x27;s normal vector normal, the vector from the center
of curvature to the arc start point startVector, the angle that the arc spans sweepAngle,
and the arc type arcType. A return value of Adesk::kFalse (that is, 0) indicates that the
primitive has been successfully stored in the graphics database. A return value of
Adesk::kTrue indicates that the operation has been terminated and the application wants to
get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> circularArc(*args) -&gt; bool:
    <span class="ds">Displays an arc primitive defined by the arc&#x27;s center of curvature center, the radius of
curvature radius, the containment plane&#x27;s normal vector normal, the vector from the center
of curvature to the arc start point startVector, the angle that the arc spans sweepAngle,
and the arc type arcType. A return value of Adesk::kFalse (that is, 0) indicates that the
primitive has been successfully stored in the graphics database. A return value of
Adesk::kTrue indicates that the operation has been terminated and the application wants to
get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:</code>
            <code><span class="kw">def</span> draw(self, drawable: PyGi.Drawable) -&gt; bool:
    <span class="ds">Instructs the graphics system to regenerate pDrawable as a component of this object. For
example, a Block Definition (AcDbBlockTableRecord) uses it to draw its contained objects.
Any object that owns another AcDb object should use this method to have that subentity draw
itself (as opposed to directly calling its worldDraw() method). This allows a graphics
system to cache the graphics of the object. Calling worldDraw directly would prevent this
type of caching. To implement this method: Set up linetype, layer, color, and fill type for
the AcGiDrawable using a call to setAttributes(), passing in your implementation of
AcGiSubEntityTraits. Call worldDraw() on the drawable and record the return value. If false
is returned, call viewportDraw() once for each viewport. Returning false to the caller
indicates that you did not process the request.</span></code>
            <code><span class="kw">def</span> edge(self, edgeList: list[PyGe.Curve2d]) -&gt; bool:
    <span class="ds">Define the boundary of the fill.</span></code>
            <code><span class="kw">def</span> ellipticalArc(self, center: PyGe.Point3d, norm: PyGe.Vector3d, majAxisLen: float, minAxisLen: float, startDeg: float, endDeg: float, tilt: float, arcType: ArcType) -&gt; bool:
    <span class="ds">This method draws an elliptical arc or full ellipse, filled or unfilled.</span></code>
            <code><span class="kw">def</span> getModelToWorldTransform(self) -&gt; PyGe.Matrix3d:
    <span class="ds">This gets the net block insert transform; that is, the model-to-world coordinate transform.
The main purpose of the BLOCK entity is to transform an entity--whether to stretch, rotate,
or move it. It is possible that during the current worldDraw(), the entity is in one or
more BLOCKs. In this case, to determine the end result of the entity being transformed by
one or more BLOCKs, use the net block insert transform (model-to-world coordinate
transform) on your entity&#x27;s model coordinate geometry. This will determine the location in
world coordinate space that it occupies.</span></code>
            <code><span class="kw">def</span> getWorldToModelTransform(self) -&gt; PyGe.Matrix3d:
    <span class="ds">This gets the inverse of the net block insert transform. This can transform an entity&#x27;s
world coordinate representation back into the original model coordinates.</span></code>
            <code><span class="kw">def</span> image(self, image: wx.Image, position: PyGe.Point3d, u: PyGe.Vector3d, v: PyGe.Vector3d) -&gt; bool:
    <span class="ds">This method uses the basic transparent image parameters provided to determine where and
what size image to paint. It will stretch the image if its size is not equal to specified
size.</span></code>
            <code><span class="kw">def</span> image(self, image: PyGi.PixelBGRA32Array, width: int, height: int, position: PyGe.Point3d, u: PyGe.Vector3d, v: PyGe.Vector3d) -&gt; bool:
    <span class="ds">This method uses the basic transparent image parameters provided to determine where and
what size image to paint. It will stretch the image if its size is not equal to specified
size.</span></code>
            <code><span class="kw">def</span> image(*args) -&gt; bool:
    <span class="ds">This method uses the basic transparent image parameters provided to determine where and
what size image to paint. It will stretch the image if its size is not equal to specified
size.</span></code>
            <code><span class="kw">def</span> pline(self, p1: PyDb.Polyline, fromIndex: int, numSegs: int) -&gt; bool:
    <span class="ds">This function uses the AcDbPolylinelwBuf as the template for the geometry it draws. It
generates display geometry that duplicates the geometry of the polyline&#x27;s segments.</span></code>
            <code><span class="kw">def</span> polygon(self, vertexList: list[PyGe.Point3d]) -&gt; bool:
    <span class="ds">Draws a filled or unfilled polygon, depending on AcGiSubEntityTraits::fillType(). An edge
between the last vertex and the first vertex is automatically created in order to generate
a closed polygon. The caller is responsible for the memory used by the pVertexList array.</span></code>
            <code><span class="kw">def</span> polyline(self, vertexList: list[PyGe.Point3d], normal: PyGe.Vector3d, marker: int) -&gt; bool:
    <span class="ds">Walks down the list of vertex points pVertexList drawing line segments from point to point
(hence the requirement for a minimum of two points). If a thickness is currently specified
it will be applied to the segments of this polyline. The caller is responsible for the
memory used by the pVertexList array. The lBaseSubEntMarker argument has been added to
allow the caller to specify sequential sub-entity markers for the segments of the polyline.
If lBaseSubEntMarker&#x27;n&#x27; is greater than zero then the segments of the polyline will be
assigned markers beginning with &#x27;n&#x27; incrementing by 1 for each segment.</span></code>
            <code><span class="kw">def</span> popModelTransform(self) -&gt; bool:
    <span class="ds">The method must be called to restore the model transform after a call to
pushModelTransform(). Returns Adesk::kTrue if successful; otherwise, returns Adesk::kFalse.</span></code>
            <code><span class="kw">def</span> pushModelTransform(self, val: PyGe.Vector3d | PyGe.Matrix3d) -&gt; bool:
    <span class="ds">This function pushes a new transform onto the transform stack. It generates the input
matrix using the arbitrary axis algorithm and the supplied vector. When you have finished
with the transform, you must call popModelTransform() to leave the pipe in the same state
as before. Returns Adesk::kTrue if successful; otherwise, returns Adesk::kFalse.</span></code>
            <code><span class="kw">def</span> pushOrientationTransform(self, behavior: PyGi.AcGiOrientationTransformBehavior) -&gt; PyGe.Matrix3d:
    <span class="ds">This method places orientation transform behavior onto the current transform stack</span></code>
            <code><span class="kw">def</span> pushPositionTransform(self, behavior: PyGi.AcGiPositionTransformBehavior, offset: PyGe.Point2d | PyGe.Point2d) -&gt; PyGe.Matrix3d:
    <span class="ds">This method places position transform behavior onto the current transform stack.This method
ignores z for position if behavior implies a 2D coordinate system, such as
kAcGiViewportPosition, kAcGiScreenPosition , kAcGiScreenLocalOriginPosition, or
kAcGiWorldWithScreenOffsetPosition .</span></code>
            <code><span class="kw">def</span> pushScaleTransform(self, behavior: PyGi.AcGiScaleTransformBehavior, extents: PyGe.Point2d | PyGe.Point2d) -&gt; PyGe.Matrix3d:
    <span class="ds">This method places scale transform behavior onto the current transform stack.This method
ignores z for scale if behavior implies a 2D coordinate system, such as kAcGiViewportScale,
kAcGiScreenScale, kAcGiViewportLocalOriginScale, or kAcGiScreenLocalOriginScale.</span></code>
            <code><span class="kw">def</span> ray(self, p1: PyGe.Point3d, p2: PyGe.Point3d) -&gt; bool:
    <span class="ds">This function displays a ray that starts at raysStartingPoint and passes through
aDifferentRayPoint. A return value of Adesk::kFalse (that is, 0) indicates that the
primitive has been successfully stored in the graphics database. A return value of
Adesk::kTrue indicates that the operation has been terminated and the application wants to
get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> rowOfDots(self, count: int, start: PyGe.Point3d, step: PyGe.Vector3d) -&gt; bool:
    <span class="ds">This method draws a row of dots.</span></code>
            <code><span class="kw">def</span> text(self, pos: PyGe.Point3d, normal: PyGe.Vector3d, direction: PyGe.Vector3d, height: float, width: float, oblique: float, msg: str) -&gt; bool:
    <span class="ds">This method uses the current AcGiTextStyle when generating the text graphics primitive.
When worldDraw() is first entered, the AcGiTextStyle is set to the STANDARD text style
that&#x27;s built into the acad.exe file (not the STANDARD text style in the drawing). The
position, normal, and direction can be thought of as the foundation for a coordinate system
that orients the text in 3D world space, where the position is the origin, the direction is
the X axis, and the normal is the Z axis. The obliquing angle for oblique is the angular
slant from vertical of each character, much the way italic text is angled. A copy of the
text string is used in pMsg, so the calling application is responsible for the memory of
the string passed in. WarningThe direction and normal vectors must be mutually
perpendicular or the results will be unpredictable. Here is an example of some text drawing
code: Adesk::Boolean someEntity::worldDraw(AcGiWorldDraw *pWd){ // Position this text to
start at &#x27;origin&#x27;, draw parallel // to the XY-plane at an upward slant of 45 degrees. //
AcGePoint3d origin(2.0, 2.0, 3.0); AcGeVector3d direction(1.0, 1.0, 0.0); AcGeVector3d
normal(0.0, 0.0, 1.0); pWd-&gt;geometry().text(origin, normal, direction, 1.0, 1.0, 0.0, &#x27;some
text&#x27;); return Adesk:kTrue;}A return value of Adesk::kFalse (that is, 0) indicates that the
primitive has been successfully stored in the graphics database. A return value of
Adesk::kTrue indicates that the operation has been terminated and the application wants to
get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> worldLine(self, p1: PyGe.Point3d, p2: PyGe.Point3d) -&gt; bool:
    <span class="ds">This function draws a line between the two points in the pnts array. The points must be in
world coordinates. A return value of Adesk::kFalse (that is, 0) indicates that the
primitive has been successfully stored in the graphics database. A return value of
Adesk::kTrue indicates that the operation has been terminated, and the application wants to
get control back as soon as possible.</span></code>
            <code><span class="kw">def</span> xline(self, p1: PyGe.Point3d, p2: PyGe.Point3d) -&gt; bool:
    <span class="ds">An xline passing oneXlinePoint and a DifferentXlinePoint is displayed. A return value of
Adesk::kFalse (that is, 0) indicates that the primitive has been successfully stored in the
graphics database. A return value of Adesk::kTrue indicates that the operation has been
terminated and the application wants to get control back as soon as possible.</span></code>
        </details>
    </div>

    <div class="class" id="GiAttributesFlags">
        <details>
            <summary>class GiAttributesFlags <span class="tag">Class</span></summary>
            <code>kDrawableNone: ClassVar[Self]</code>
            <code>kDrawableIsAnEntity: ClassVar[Self]</code>
            <code>kDrawableUsesNesting: ClassVar[Self]</code>
            <code>kDrawableIsCompoundObject: ClassVar[Self]</code>
            <code>kDrawableViewIndependentViewportDraw: ClassVar[Self]</code>
            <code>kDrawableIsInvisible: ClassVar[Self]</code>
            <code>kDrawableHasAttributes: ClassVar[Self]</code>
            <code>kDrawableRegenTypeDependentGeometry: ClassVar[Self]</code>
            <code>kDrawableIsDimension: ClassVar[Self]</code>
            <code>kDrawableRegenDraw: ClassVar[Self]</code>
            <code>kDrawableStandardDisplaySingleLOD: ClassVar[Self]</code>
            <code>kDrawableShadedDisplaySingleLOD: ClassVar[Self]</code>
            <code>kDrawableViewDependentViewportDraw: ClassVar[Self]</code>
            <code>kDrawableBlockDependentViewportDraw: ClassVar[Self]</code>
            <code>kDrawableIsExternalReference: ClassVar[Self]</code>
            <code>kDrawableNotPlottable: ClassVar[Self]</code>
            <code>kDrawableNotAllowLCS: ClassVar[Self]</code>
            <code>kDrawableMergeControlOff: ClassVar[Self]</code>
            <code>kThreadedWorldDrawViewportDraw: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="GiDrawableType">
        <details>
            <summary>class GiDrawableType <span class="tag">Class</span></summary>
            <code>kGeometry: ClassVar[Self]</code>
            <code>kDistantLight: ClassVar[Self]</code>
            <code>kPointLight: ClassVar[Self]</code>
            <code>kSpotLight: ClassVar[Self]</code>
            <code>kAmbientLight: ClassVar[Self]</code>
            <code>kSolidBackground: ClassVar[Self]</code>
            <code>kGradientBackground: ClassVar[Self]</code>
            <code>kImageBackground: ClassVar[Self]</code>
            <code>kGroundPlaneBackground: ClassVar[Self]</code>
            <code>kViewport: ClassVar[Self]</code>
            <code>kWebLight: ClassVar[Self]</code>
            <code>kSkyBackground: ClassVar[Self]</code>
            <code>kImageBasedLightingBackground: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="GiGraphicsKernel">
        <details>
            <summary>class GiGraphicsKernel <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> getDescriptor(self) -&gt; GiKernelDescriptor:
    <span class="ds">This method returns the kernel descriptor for the graphics kernel. A given kernel only has
one descriptor, but it&#x27;s possible for multiple kernels to have the same descriptor.</span></code>
        </details>
    </div>

    <div class="class" id="GiKernelDescriptor">
        <details>
            <summary>class GiKernelDescriptor <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> supports(self) -&gt; bool:
    <span class="ds">This used by a consumer of an AcGsGraphicsKernel to determine which features are supported
by the kernel.</span></code>
        </details>
    </div>

    <div class="class" id="OrientationTransformBehavior">
        <details>
            <summary>class OrientationTransformBehavior <span class="tag">Class</span></summary>
            <code>kAcGiWorldOrientation: ClassVar[Self]</code>
            <code>kAcGiScreenOrientation: ClassVar[Self]</code>
            <code>kAcGiZAxisOrientation: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="OrientationType">
        <details>
            <summary>class OrientationType <span class="tag">Class</span></summary>
            <code>kAcGiCounterClockwise: ClassVar[Self]</code>
            <code>kAcGiNoOrientation: ClassVar[Self]</code>
            <code>kAcGiClockwise: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="PixelBGRA32Array">
        <details>
            <summary>class PixelBGRA32Array <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __contains__(self) -&gt; bool:</code>
            <code><span class="kw">def</span> __delitem__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __getitem__(self) -&gt; object:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __iter__(self) -&gt; object:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __setitem__(self) -&gt; None:</code>
            <code><span class="kw">def</span> append(self) -&gt; None:</code>
            <code><span class="kw">def</span> createFromWxImage(image: wx.Image, alpha: int) -&gt; PixelBGRA32Array:</code>
            <code><span class="kw">def</span> extend(self) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="PositionTransformBehavior">
        <details>
            <summary>class PositionTransformBehavior <span class="tag">Class</span></summary>
            <code>kAcGiWorldPosition: ClassVar[Self]</code>
            <code>kAcGiViewportPosition: ClassVar[Self]</code>
            <code>kAcGiScreenPosition: ClassVar[Self]</code>
            <code>kAcGiScreenLocalOriginPosition: ClassVar[Self]</code>
            <code>kAcGiWorldWithScreenOffsetPosition: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="RegenType">
        <details>
            <summary>class RegenType <span class="tag">Class</span></summary>
            <code>eAcGiRegenTypeInvalid: ClassVar[Self]</code>
            <code>kAcGiStandardDisplay: ClassVar[Self]</code>
            <code>kAcGiHideOrShadeCommand: ClassVar[Self]</code>
            <code>kAcGiShadedDisplay: ClassVar[Self]</code>
            <code>kAcGiForExplode: ClassVar[Self]</code>
            <code>kAcGiSaveWorldDrawForProxy: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ScaleTransformBehavior">
        <details>
            <summary>class ScaleTransformBehavior <span class="tag">Class</span></summary>
            <code>kAcGiWorldScale: ClassVar[Self]</code>
            <code>kAcGiViewportScale: ClassVar[Self]</code>
            <code>kAcGiScreenScale: ClassVar[Self]</code>
            <code>kAcGiViewportLocalOriginScale: ClassVar[Self]</code>
            <code>kAcGiScreenLocalOriginScale: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SelectionFlags">
        <details>
            <summary>class SelectionFlags <span class="tag">Class</span></summary>
            <code>kNoSelectionFlags: ClassVar[Self]</code>
            <code>kSelectionIgnore: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ShadowFlags">
        <details>
            <summary>class ShadowFlags <span class="tag">Class</span></summary>
            <code>kNoDrawFlags: ClassVar[Self]</code>
            <code>kShadowsDoesNotCast: ClassVar[Self]</code>
            <code>kShadowsDoesNotReceive: ClassVar[Self]</code>
            <code>kShadowsIgnore: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="SubEntityTraits">
        <details>
            <summary>class SubEntityTraits <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> color(self) -&gt; int:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> drawFlags(self) -&gt; int:</code>
            <code><span class="kw">def</span> fillType(self) -&gt; FillType:</code>
            <code><span class="kw">def</span> getPlotStyleNameId(self) -&gt; PyDb.ObjectId:</code>
            <code><span class="kw">def</span> layerId(self) -&gt; PyDb.ObjectId:</code>
            <code><span class="kw">def</span> lineTypeId(self) -&gt; PyDb.ObjectId:</code>
            <code><span class="kw">def</span> lineTypeScale(self) -&gt; float:</code>
            <code><span class="kw">def</span> lineWeight(self) -&gt; PyDb.LineWeight:</code>
            <code><span class="kw">def</span> materialId(self) -&gt; PyDb.ObjectId:</code>
            <code><span class="kw">def</span> sectionable(self) -&gt; bool:</code>
            <code><span class="kw">def</span> selectionGeom(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setColor(self, val: int) -&gt; None:</code>
            <code><span class="kw">def</span> setDrawFlags(self, flags: int) -&gt; None:</code>
            <code><span class="kw">def</span> setFillType(self, val: PyGi.FillType) -&gt; None:</code>
            <code><span class="kw">def</span> setLayer(self, id: PyDb.ObjectId) -&gt; None:</code>
            <code><span class="kw">def</span> setLineType(self, id: PyDb.ObjectId) -&gt; None:</code>
            <code><span class="kw">def</span> setLineTypeScale(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setLineWeight(self, val: PyDb.LineWeight) -&gt; None:</code>
            <code><span class="kw">def</span> setMaterial(self, id: PyDb.ObjectId) -&gt; None:</code>
            <code><span class="kw">def</span> setPlotStyleName(self, val: PyDb.PlotStyleNameType, id: PyDb.ObjectId) -&gt; None:</code>
            <code><span class="kw">def</span> setSectionable(self, val: bool) -&gt; None:</code>
            <code><span class="kw">def</span> setSelectionGeom(self, val: bool) -&gt; None:</code>
            <code><span class="kw">def</span> setSelectionMarker(self, val: int) -&gt; None:</code>
            <code><span class="kw">def</span> setShadowFlags(self, val: PyGi.ShadowFlags) -&gt; None:</code>
            <code><span class="kw">def</span> setThickness(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setTransparency(self, val: PyDb.Transparency) -&gt; None:</code>
            <code><span class="kw">def</span> setTrueColor(self, clr: PyDb.EntityColor) -&gt; None:</code>
            <code><span class="kw">def</span> setVisualStyle(self, id: PyDb.ObjectId) -&gt; None:</code>
            <code><span class="kw">def</span> shadowFlags(self) -&gt; ShadowFlags:</code>
            <code><span class="kw">def</span> thickness(self) -&gt; float:</code>
            <code><span class="kw">def</span> transparency(self) -&gt; PyDb.Transparency:</code>
            <code><span class="kw">def</span> trueColor(self) -&gt; PyDb.EntityColor:</code>
            <code><span class="kw">def</span> visualStyle(self) -&gt; PyDb.ObjectId:</code>
        </details>
    </div>

    <div class="class" id="TransientDrawingMode">
        <details>
            <summary>class TransientDrawingMode <span class="tag">Class</span></summary>
            <code>kAcGiMain: ClassVar[Self]</code>
            <code>kAcGiSprite: ClassVar[Self]</code>
            <code>kAcGiDirectShortTerm: ClassVar[Self]</code>
            <code>kAcGiHighlight: ClassVar[Self]</code>
            <code>kAcGiDirectTopmost: ClassVar[Self]</code>
            <code>kAcGiContrast: ClassVar[Self]</code>
            <code>kAcGiDrawingModeCount: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="TransientManager">
        <details>
            <summary>class TransientManager <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> addChildTransient(self, drawable: PyGi.Drawable, parentDrawable: PyGi.Drawable) -&gt; bool:
    <span class="ds">This function adds a child transient to specified parent transient. This allows for partial
updates of the parent drawable. Returns true if successful. This function doesn&#x27;t need to
specify a drawing mode, subDrawingMode or viewportNumber; these properties of the child
transient will be the same as parent transient</span></code>
            <code><span class="kw">def</span> addTransient(self, drawable: PyGi.Drawable, mode: PyGi.TransientDrawingMode, subDrawingMode: int, viewportNumbers: list[int]) -&gt; bool:
    <span class="ds">This function adds a transient to a list of viewports. Returns true if successful.</span></code>
            <code><span class="kw">def</span> current() -&gt; TransientManager:</code>
            <code><span class="kw">def</span> eraseChildTransient(self, drawable: PyGi.Drawable, parentDrawable: PyGi.Drawable) -&gt; bool:
    <span class="ds">This function erases a child transient from specified parent transient. Returns true if
successful.</span></code>
            <code><span class="kw">def</span> eraseTransient(self, drawable: PyGi.Drawable, viewportNumbers: list[int]) -&gt; bool:
    <span class="ds">This function erases a transient from a list of viewports. Returns true if successful. This
function erases a specified drawable which has been added by addTransient().</span></code>
            <code><span class="kw">def</span> eraseTransients(self, mode: PyGi.TransientDrawingMode, subDrawingMode: int, viewportNumbers: list[int]) -&gt; bool:
    <span class="ds">This function erases all transients in the specified subDrawingMode from a list of
viewports. Returns true if successful.</span></code>
            <code><span class="kw">def</span> getFreeSubDrawingMode(self, mode: PyGi.TransientDrawingMode, subDrawingMode: int, viewportNumbers: list[int]) -&gt; tuple[int, int]:
    <span class="ds">Get the free draw order in a certain transient drawing mode. Returns 0 if the input draw
order is not free and transient manager also could not get a free draw order. Returns 1 if
the inputting draw order is available. Returns 2 if the inputting draw order is
unavailable, but transient manager could return a free draw order.</span></code>
            <code><span class="kw">def</span> updateChildTransient(self, drawable: PyGi.Drawable, parentDrawable: PyGi.Drawable) -&gt; None:
    <span class="ds">This function only updates a child transient of the specified parent transient. This means
partial updates of parent drawable.</span></code>
            <code><span class="kw">def</span> updateTransient(self, drawable: PyGi.Drawable, viewportNumbers: list[int]) -&gt; None:
    <span class="ds">Update a transient via the transient manager.</span></code>
        </details>
    </div>

    <div class="class" id="TransparencyMode">
        <details>
            <summary>class TransparencyMode <span class="tag">Class</span></summary>
            <code>kTransparencyOff: ClassVar[Self]</code>
            <code>kTransparency1Bit: ClassVar[Self]</code>
            <code>kTransparency8Bit: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ViewportDraw">
        <details>
            <summary>class ViewportDraw <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> geometry(self) -&gt; ViewportGeometry:
    <span class="ds">Returns a reference to the AcGiViewportGeometry object. The viewportGeometry object allows
the user to generate geometry (polylines, arcs, meshes, etc.). For a description of this
object, see class AcGiViewportGeometry.</span></code>
        </details>
    </div>

    <div class="class" id="ViewportGeometry">
        <details>
            <summary>class ViewportGeometry <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
        </details>
    </div>

    <div class="class" id="Visibility">
        <details>
            <summary>class Visibility <span class="tag">Class</span></summary>
            <code>kAcGiInvisible: ClassVar[Self]</code>
            <code>kAcGiVisible: ClassVar[Self]</code>
            <code>kAcGiSilhouette: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="WorldDraw">
        <details>
            <summary>class WorldDraw <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> geometry(self) -&gt; WorldGeometry:
    <span class="ds">Returns a reference to the AcGiWorldGeometry object. The AcGiWorldGeometry object allows
the user to generate geometry (polylines, arcs, meshes, etc.). For a description of this
object, see class AcGiWorldGeometry.</span></code>
        </details>
    </div>

    <div class="class" id="WorldGeometry">
        <details>
            <summary>class WorldGeometry <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
        </details>
    </div>
</body>
</html>