<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PyGe.pyi</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: Consolas, monospace;
            margin: 2em;
        }
        a {
            color: #569cd6;
        }
        .class {
            margin-bottom: 1em;
        }
        summary {
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }
        details {
            margin-left: 0.5em;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            padding: 0.5em;
        }
        code {
            display: block;
            margin: 0.3em 0;
            white-space: pre;
            background-color: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4em 0.6em;
            border-left: 4px solid #007acc;
            font-size: 1.2em;
        }
        .kw {
            color: #569cd6;
            font-weight: bold;
        }
        .ds {
            color: #FF8787;
            opacity: 0.7;
        }
        h1 {
            color: #569cd6;
        }
        .tag {
            background: #007acc;
            color: #fff;
            border-radius: 4px;
            padding: 0.1em 0.5em;
            font-size: 0.9em;
            margin-left: 0.5em;
        }
        .toc {
            margin-bottom: 2em;
        }
    </style>
</head>
<body>
    <h1>PyGe.pyi</h1>
    <div class="toc">
        <h2>Classes</h2>
        <ul>
            <li><a href="#AcGeCSIConfig">AcGeCSIConfig</a></li>
            <li><a href="#AcGeError">AcGeError</a></li>
            <li><a href="#AcGeSSIConfig">AcGeSSIConfig</a></li>
            <li><a href="#AcGeSSIType">AcGeSSIType</a></li>
            <li><a href="#AcGeXConfig">AcGeXConfig</a></li>
            <li><a href="#AutoTol">AutoTol</a></li>
            <li><a href="#BoundBlock2d">BoundBlock2d</a></li>
            <li><a href="#BoundBlock3d">BoundBlock3d</a></li>
            <li><a href="#BoundedPlane">BoundedPlane</a></li>
            <li><a href="#CircArc2d">CircArc2d</a></li>
            <li><a href="#CircArc3d">CircArc3d</a></li>
            <li><a href="#ClipBoundary2d">ClipBoundary2d</a></li>
            <li><a href="#CompositeCurve2d">CompositeCurve2d</a></li>
            <li><a href="#CompositeCurve3d">CompositeCurve3d</a></li>
            <li><a href="#Cone">Cone</a></li>
            <li><a href="#CubicSplineCurve2d">CubicSplineCurve2d</a></li>
            <li><a href="#CubicSplineCurve3d">CubicSplineCurve3d</a></li>
            <li><a href="#Curve2d">Curve2d</a></li>
            <li><a href="#Curve3d">Curve3d</a></li>
            <li><a href="#CurveCurveInt2d">CurveCurveInt2d</a></li>
            <li><a href="#CurveCurveInt3d">CurveCurveInt3d</a></li>
            <li><a href="#CurveSurfInt">CurveSurfInt</a></li>
            <li><a href="#Cylinder">Cylinder</a></li>
            <li><a href="#EllipArc2d">EllipArc2d</a></li>
            <li><a href="#EllipArc3d">EllipArc3d</a></li>
            <li><a href="#Entity2d">Entity2d</a></li>
            <li><a href="#Entity3d">Entity3d</a></li>
            <li><a href="#EntityId">EntityId</a></li>
            <li><a href="#ExternalBoundedSurface">ExternalBoundedSurface</a></li>
            <li><a href="#ExternalCurve2d">ExternalCurve2d</a></li>
            <li><a href="#ExternalCurve3d">ExternalCurve3d</a></li>
            <li><a href="#ExternalEntityKind">ExternalEntityKind</a></li>
            <li><a href="#ExternalSurface">ExternalSurface</a></li>
            <li><a href="#Interval">Interval</a></li>
            <li><a href="#KnotParameterization">KnotParameterization</a></li>
            <li><a href="#KnotVector">KnotVector</a></li>
            <li><a href="#Line2d">Line2d</a></li>
            <li><a href="#Line3d">Line3d</a></li>
            <li><a href="#LineSeg2d">LineSeg2d</a></li>
            <li><a href="#LineSeg3d">LineSeg3d</a></li>
            <li><a href="#LinearEnt2d">LinearEnt2d</a></li>
            <li><a href="#LinearEnt3d">LinearEnt3d</a></li>
            <li><a href="#Matrix2d">Matrix2d</a></li>
            <li><a href="#Matrix3d">Matrix3d</a></li>
            <li><a href="#NurbCurve2d">NurbCurve2d</a></li>
            <li><a href="#NurbCurve3d">NurbCurve3d</a></li>
            <li><a href="#NurbSurface">NurbSurface</a></li>
            <li><a href="#OffsetCrvExtType">OffsetCrvExtType</a></li>
            <li><a href="#OffsetCurve2d">OffsetCurve2d</a></li>
            <li><a href="#OffsetCurve3d">OffsetCurve3d</a></li>
            <li><a href="#OffsetSurface">OffsetSurface</a></li>
            <li><a href="#PlanarEnt">PlanarEnt</a></li>
            <li><a href="#Plane">Plane</a></li>
            <li><a href="#Point2d">Point2d</a></li>
            <li><a href="#Point2dArray">Point2dArray</a></li>
            <li><a href="#Point2dTree">Point2dTree</a></li>
            <li><a href="#Point3d">Point3d</a></li>
            <li><a href="#Point3dArray">Point3dArray</a></li>
            <li><a href="#Point3dTree">Point3dTree</a></li>
            <li><a href="#PointContainment">PointContainment</a></li>
            <li><a href="#PointEnt2d">PointEnt2d</a></li>
            <li><a href="#PointEnt3d">PointEnt3d</a></li>
            <li><a href="#PointOnCurve2d">PointOnCurve2d</a></li>
            <li><a href="#PointOnCurve3d">PointOnCurve3d</a></li>
            <li><a href="#PointOnSurface">PointOnSurface</a></li>
            <li><a href="#Polyline2d">Polyline2d</a></li>
            <li><a href="#Polyline3d">Polyline3d</a></li>
            <li><a href="#Position2d">Position2d</a></li>
            <li><a href="#Position3d">Position3d</a></li>
            <li><a href="#Ray2d">Ray2d</a></li>
            <li><a href="#Ray3d">Ray3d</a></li>
            <li><a href="#Scale2d">Scale2d</a></li>
            <li><a href="#Scale3d">Scale3d</a></li>
            <li><a href="#Sphere">Sphere</a></li>
            <li><a href="#SplineEnt2d">SplineEnt2d</a></li>
            <li><a href="#SplineEnt3d">SplineEnt3d</a></li>
            <li><a href="#SurfSurfInt">SurfSurfInt</a></li>
            <li><a href="#Surface">Surface</a></li>
            <li><a href="#Tol">Tol</a></li>
            <li><a href="#Torus">Torus</a></li>
            <li><a href="#Vector2d">Vector2d</a></li>
            <li><a href="#Vector3d">Vector3d</a></li>
        </ul>
    </div>

    <div class="class" id="AcGeCSIConfig">
        <details>
            <summary>class AcGeCSIConfig <span class="tag">Class</span></summary>
            <code>kXUnknown: ClassVar[Self]</code>
            <code>kXOut: ClassVar[Self]</code>
            <code>kXIn: ClassVar[Self]</code>
            <code>kXTanOut: ClassVar[Self]</code>
            <code>kXTanIn: ClassVar[Self]</code>
            <code>kXCoincident: ClassVar[Self]</code>
            <code>kXCoincidentUnbounded: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="AcGeError">
        <details>
            <summary>class AcGeError <span class="tag">Class</span></summary>
            <code>kOk: ClassVar[Self]</code>
            <code>k0This: ClassVar[Self]</code>
            <code>k0Arg1: ClassVar[Self]</code>
            <code>k0Arg2: ClassVar[Self]</code>
            <code>kPerpendicularArg1Arg2: ClassVar[Self]</code>
            <code>kEqualArg1Arg2: ClassVar[Self]</code>
            <code>kEqualArg1Arg3: ClassVar[Self]</code>
            <code>kEqualArg2Arg3: ClassVar[Self]</code>
            <code>kLinearlyDependentArg1Arg2Arg3: ClassVar[Self]</code>
            <code>kArg1TooBig: ClassVar[Self]</code>
            <code>kArg1OnThis: ClassVar[Self]</code>
            <code>kArg1InsideThis: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="AcGeSSIConfig">
        <details>
            <summary>class AcGeSSIConfig <span class="tag">Class</span></summary>
            <code>kSSIUnknown: ClassVar[Self]</code>
            <code>kSSIOut: ClassVar[Self]</code>
            <code>kSSIIn: ClassVar[Self]</code>
            <code>kSSICoincident: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="AcGeSSIType">
        <details>
            <summary>class AcGeSSIType <span class="tag">Class</span></summary>
            <code>kSSITransverse: ClassVar[Self]</code>
            <code>kSSITangent: ClassVar[Self]</code>
            <code>kSSIAntiTangent: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="AcGeXConfig">
        <details>
            <summary>class AcGeXConfig <span class="tag">Class</span></summary>
            <code>kNotDefined: ClassVar[Self]</code>
            <code>kUnknown: ClassVar[Self]</code>
            <code>kLeftRight: ClassVar[Self]</code>
            <code>kRightLeft: ClassVar[Self]</code>
            <code>kLeftLeft: ClassVar[Self]</code>
            <code>kRightRight: ClassVar[Self]</code>
            <code>kPointLeft: ClassVar[Self]</code>
            <code>kPointRight: ClassVar[Self]</code>
            <code>kLeftOverlap: ClassVar[Self]</code>
            <code>kOverlapLeft: ClassVar[Self]</code>
            <code>kRightOverlap: ClassVar[Self]</code>
            <code>kOverlapRight: ClassVar[Self]</code>
            <code>kOverlapStart: ClassVar[Self]</code>
            <code>kOverlapEnd: ClassVar[Self]</code>
            <code>kOverlapOverlap: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="AutoTol">
        <details>
            <summary>class AutoTol <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> equalPoint(self) -&gt; float:</code>
            <code><span class="kw">def</span> equalVector(self) -&gt; float:</code>
            <code><span class="kw">def</span> setEqualPoint(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setEqualVector(self, val: float) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="BoundBlock2d">
        <details>
            <summary>class BoundBlock2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">This class provides a two-dimensional bounding volume implementation. Bounding blocks may
exist in two forms: as an ordinary coordinate-aligned bounding box and as a parallelogram.</span></code>
            <code><span class="kw">def</span> __init__(self, pt1: PyGe.Point2d, pt2: PyGe.Point2d) -&gt; None:
    <span class="ds">This class provides a two-dimensional bounding volume implementation. Bounding blocks may
exist in two forms: as an ordinary coordinate-aligned bounding box and as a parallelogram.</span></code>
            <code><span class="kw">def</span> __init__(self, base: PyGe.Point2d, dir1: PyGe.Vector2d, dir2: PyGe.Vector2d) -&gt; None:
    <span class="ds">This class provides a two-dimensional bounding volume implementation. Bounding blocks may
exist in two forms: as an ordinary coordinate-aligned bounding box and as a parallelogram.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">This class provides a two-dimensional bounding volume implementation. Bounding blocks may
exist in two forms: as an ordinary coordinate-aligned bounding box and as a parallelogram.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; BoundBlock2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> contains(self, pt: PyGe.Point2d) -&gt; bool:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; BoundBlock2d:</code>
            <code><span class="kw">def</span> extend(self, pt: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> getBasePoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> getDirection1(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> getDirection2(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> getMaxPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> getMinPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> isBox(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isDisjoint(self, block: PyGe.BoundBlock2d) -&gt; bool:</code>
            <code><span class="kw">def</span> set(self, pt1: PyGe.Point2d, pt2: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, base: PyGe.Point2d, dir1: PyGe.Vector2d, dir2: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setToBox(self, val: bool) -&gt; None:</code>
            <code><span class="kw">def</span> swell(self, val: float) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="BoundBlock3d">
        <details>
            <summary>class BoundBlock3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">This class provides spatial dimensional bounding volume implementation. Bounding blocks may
exist in two forms: as an ordinary coordinate-aligned bounding box and as a parallelepiped.</span></code>
            <code><span class="kw">def</span> __init__(self, base: PyGe.Point3d, dir1: PyGe.Vector3d, dir2: PyGe.Vector3d, dir3: PyGe.Vector3d) -&gt; None:
    <span class="ds">This class provides spatial dimensional bounding volume implementation. Bounding blocks may
exist in two forms: as an ordinary coordinate-aligned bounding box and as a parallelepiped.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">This class provides spatial dimensional bounding volume implementation. Bounding blocks may
exist in two forms: as an ordinary coordinate-aligned bounding box and as a parallelepiped.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; BoundBlock3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> contains(self, pt: PyGe.Point3d) -&gt; bool:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; BoundBlock3d:</code>
            <code><span class="kw">def</span> extend(self, pt: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> getBasePoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> getDirection1(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> getDirection3(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> getMaxPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> getMinPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> isBox(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isDisjoint(self, block: PyGe.BoundBlock3d) -&gt; bool:</code>
            <code><span class="kw">def</span> set(self, pt1: PyGe.Point3d, pt2: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, base: PyGe.Point3d, dir1: PyGe.Vector3d, dir2: PyGe.Vector3d, dir3: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setToBox(self, val: bool) -&gt; None:</code>
            <code><span class="kw">def</span> swell(self, val: float) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="BoundedPlane">
        <details>
            <summary>class BoundedPlane <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a bounded planar parametric surface.</span></code>
            <code><span class="kw">def</span> __init__(self, origin: PyGe.Point3d, uVec: PyGe.Vector3d, vVec: PyGe.Vector3d) -&gt; None:
    <span class="ds">Represents a bounded planar parametric surface.</span></code>
            <code><span class="kw">def</span> __init__(self, p1: PyGe.Point3d, origin: PyGe.Point3d, p2: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents a bounded planar parametric surface.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a bounded planar parametric surface.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; BoundedPlane:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; BoundedPlane:</code>
            <code><span class="kw">def</span> intersectWith(self, val: PyGe.LinearEnt3d | PyGe.Plane | PyGe.BoundedPlane, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.LineSeg3d]:</code>
            <code><span class="kw">def</span> set(self, origin: PyGe.Point3d, uVec: PyGe.Vector3d, vVec: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, p1: PyGe.Point3d, origin: PyGe.Point3d, p2: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="CircArc2d">
        <details>
            <summary>class CircArc2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point2d, radius: float) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point2d, radius: float, startAngle: float, endAngle: float) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point2d, radius: float, startAngle: float, endAngle: float, refVec: PyGe.Vector2d, isClockWise: bool) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point2d, pnt: PyGe.Point2d, endPoint: PyGe.Point2d) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point2d, endPoint: PyGe.Point2d, bulge: float, bulgeFlag: bool) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; CircArc2d:</code>
            <code><span class="kw">def</span> center(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; CircArc2d:</code>
            <code><span class="kw">def</span> endAng(self) -&gt; float:</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> intersectWith(self, val: PyGe.CircArc2d | PyGe.LinearEnt2d, tol: PyGe.Tol) -&gt; tuple[bool, int, PyGe.Point2d, PyGe.Point2d]:</code>
            <code><span class="kw">def</span> isClockWise(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isInside(self, pt: PyGe.Point2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> radius(self) -&gt; float:</code>
            <code><span class="kw">def</span> refVec(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> set(self, cent: PyGe.Point2d, radius: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, cent: PyGe.Point2d, radius: float, startAngle: float, endAngle: float, refVec: PyGe.Vector2d, isClockWise: bool) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point2d, pnt: PyGe.Point2d, endPoint: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point2d, endPoint: PyGe.Point2d, bulge: float, bulgeFlag: bool) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, curve1: PyGe.Curve2d, curve2: PyGe.Curve2d, radius: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, curve1: PyGe.Curve2d, curve2: PyGe.Curve2d, curve3: PyGe.Curve2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setAngles(self, startAng: float, endAng: float) -&gt; None:</code>
            <code><span class="kw">def</span> setCenter(self, pt: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> setRadius(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setRefVec(self) -&gt; None:</code>
            <code><span class="kw">def</span> setToComplement(self) -&gt; None:</code>
            <code><span class="kw">def</span> startAng(self) -&gt; float:</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> tangent(self, pt: PyGe.Point2d, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Line3d, PyGe.AcGeError]:</code>
        </details>
    </div>

    <div class="class" id="CircArc3d">
        <details>
            <summary>class CircArc3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point3d, nrm: PyGe.Vector3d, radius: float) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point3d, nrm: PyGe.Vector3d, refVec: PyGe.Vector3d, radius: float, startAngle: float, endAngle: float) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point3d, pnt: PyGe.Point3d, endPoint: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents both full circles and circular arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; CircArc3d:</code>
            <code><span class="kw">def</span> center(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> closestPointToPlane(self, plane: PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; tuple[PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; CircArc3d:</code>
            <code><span class="kw">def</span> endAng(self) -&gt; float:</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> getPlane(self) -&gt; Plane:</code>
            <code><span class="kw">def</span> intersectWith(self, other: PyGe.CircArc3d | PyGe.LinearEnt3d | PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; tuple[bool, int, PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> isInside(self, pt: PyGe.Point3d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> normal(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> projIntersectWith(self, other: PyGe.LinearEnt3d, projDir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; tuple:</code>
            <code><span class="kw">def</span> radius(self) -&gt; float:</code>
            <code><span class="kw">def</span> refVec(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> set(self, cent: PyGe.Point3d, nrm: PyGe.Vector3d, radius: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, cent: PyGe.Point3d, nrm: PyGe.Vector3d, refVec: PyGe.Vector3d, radius: float, startAngle: float, endAngle: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point3d, pnt: PyGe.Point3d, endPoint: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, curve1: PyGe.Curve3d, curve2: PyGe.Curve3d, radius: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, curve1: PyGe.Curve3d, curve2: PyGe.Curve3d, curve3: PyGe.Curve3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setAngles(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setAxes(self, vec: PyGe.Vector3d, refvec: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> setCenter(self, pt: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> setRadius(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> startAng(self) -&gt; float:</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> tangent(self, pt: PyGe.Point3d, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Line3d]:</code>
        </details>
    </div>

    <div class="class" id="ClipBoundary2d">
        <details>
            <summary>class ClipBoundary2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">This class defines a planar clipping object for clipping arbitrary 2D polygons or polylines
to 2D convex open or closed polyline curves or rectangles. The implementation is similar to
the Sutherland-Hodgman pipeline clipping algorithm. Detailed edge information can
optionally be generated to track the source of each clipped output segment. This
information can be used to control edge display or to efficiently stitch together output
from multiple clip boundaries (possibly from decomposing a non-convex clip boundary into
multiple convex boundaries). Information about the spatial relationship between the clipped
polygon or polyline and the clip region is also generated.</span></code>
            <code><span class="kw">def</span> __init__(self, cornerA: PyGe.Point2d, cornerB: PyGe.Point2d) -&gt; None:
    <span class="ds">This class defines a planar clipping object for clipping arbitrary 2D polygons or polylines
to 2D convex open or closed polyline curves or rectangles. The implementation is similar to
the Sutherland-Hodgman pipeline clipping algorithm. Detailed edge information can
optionally be generated to track the source of each clipped output segment. This
information can be used to control edge display or to efficiently stitch together output
from multiple clip boundaries (possibly from decomposing a non-convex clip boundary into
multiple convex boundaries). Information about the spatial relationship between the clipped
polygon or polyline and the clip region is also generated.</span></code>
            <code><span class="kw">def</span> __init__(self, clipBoundary: list[PyGe.Point2d]) -&gt; None:
    <span class="ds">This class defines a planar clipping object for clipping arbitrary 2D polygons or polylines
to 2D convex open or closed polyline curves or rectangles. The implementation is similar to
the Sutherland-Hodgman pipeline clipping algorithm. Detailed edge information can
optionally be generated to track the source of each clipped output segment. This
information can be used to control edge display or to efficiently stitch together output
from multiple clip boundaries (possibly from decomposing a non-convex clip boundary into
multiple convex boundaries). Information about the spatial relationship between the clipped
polygon or polyline and the clip region is also generated.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">This class defines a planar clipping object for clipping arbitrary 2D polygons or polylines
to 2D convex open or closed polyline curves or rectangles. The implementation is similar to
the Sutherland-Hodgman pipeline clipping algorithm. Detailed edge information can
optionally be generated to track the source of each clipped output segment. This
information can be used to control edge display or to efficiently stitch together output
from multiple clip boundaries (possibly from decomposing a non-convex clip boundary into
multiple convex boundaries). Information about the spatial relationship between the clipped
polygon or polyline and the clip region is also generated.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; ClipBoundary2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; ClipBoundary2d:</code>
        </details>
    </div>

    <div class="class" id="CompositeCurve2d">
        <details>
            <summary>class CompositeCurve2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a composite curve, which is a single curve that consists of any number of
component curves that are connected end-to-end. For instance, a composite curve could
consist of four straight line segments that form a square. Each of the component curves
must be bounded curves, which means that infinite lines and rays may not be used as
component curves of a composite. A composite curve object stores a list of pointers to the
component curves. The start parameter of a composite is 0.0. The parameter value at the
endpoint of the first component curve is the approximate length of the first curve (call
this value l1). The parameter value at the endpoint of the second curve is l1 plus the
approximate length of the second curve, and so forth.</span></code>
            <code><span class="kw">def</span> __init__(self, curveList: list[PyGe.Curve2d]) -&gt; None:
    <span class="ds">Represents a composite curve, which is a single curve that consists of any number of
component curves that are connected end-to-end. For instance, a composite curve could
consist of four straight line segments that form a square. Each of the component curves
must be bounded curves, which means that infinite lines and rays may not be used as
component curves of a composite. A composite curve object stores a list of pointers to the
component curves. The start parameter of a composite is 0.0. The parameter value at the
endpoint of the first component curve is the approximate length of the first curve (call
this value l1). The parameter value at the endpoint of the second curve is l1 plus the
approximate length of the second curve, and so forth.</span></code>
            <code><span class="kw">def</span> __init__(self, curveList: list[PyGe.Curve2d], isOwnerOfCurves: list[int]) -&gt; None:
    <span class="ds">Represents a composite curve, which is a single curve that consists of any number of
component curves that are connected end-to-end. For instance, a composite curve could
consist of four straight line segments that form a square. Each of the component curves
must be bounded curves, which means that infinite lines and rays may not be used as
component curves of a composite. A composite curve object stores a list of pointers to the
component curves. The start parameter of a composite is 0.0. The parameter value at the
endpoint of the first component curve is the approximate length of the first curve (call
this value l1). The parameter value at the endpoint of the second curve is l1 plus the
approximate length of the second curve, and so forth.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a composite curve, which is a single curve that consists of any number of
component curves that are connected end-to-end. For instance, a composite curve could
consist of four straight line segments that form a square. Each of the component curves
must be bounded curves, which means that infinite lines and rays may not be used as
component curves of a composite. A composite curve object stores a list of pointers to the
component curves. The start parameter of a composite is 0.0. The parameter value at the
endpoint of the first component curve is the approximate length of the first curve (call
this value l1). The parameter value at the endpoint of the second curve is l1 plus the
approximate length of the second curve, and so forth.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; CompositeCurve2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; CompositeCurve2d:</code>
            <code><span class="kw">def</span> getCurveList(self) -&gt; list[PyGe.Curve3d]:</code>
            <code><span class="kw">def</span> globalToLocalParam(self, param: float) -&gt; tuple[float, int]:</code>
            <code><span class="kw">def</span> localToGlobalParam(self, param: float, segNum: int) -&gt; float:</code>
            <code><span class="kw">def</span> setCurveList(self, curveList: list[PyGe.Curve2d]) -&gt; None:</code>
            <code><span class="kw">def</span> setCurveList(self, curveList: list[PyGe.Curve2d], isOwnerOfCurves: list[int]) -&gt; None:</code>
            <code><span class="kw">def</span> setCurveList(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="CompositeCurve3d">
        <details>
            <summary>class CompositeCurve3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a composite curve, which is a single curve that consists of any number of
component curves that are connected end-to-end. For instance, a composite curve could
consist of four straight line segments that form a square. Each of the component curves
must be bounded curves, which means that infinite lines and rays may not be used as
component curves of a composite. The component curves are not required to all lie in the
same plane. A composite curve object stores a list of pointers to the component curves. The
start parameter of a composite is 0.0. The parameter value at the endpoint of the first
component curve is the approximate length of the first curve (call this value l1). The
parameter value at the endpoint of the second curve is l1 plus the approximate length of
the second curve, etc.</span></code>
            <code><span class="kw">def</span> __init__(self, curveList: list[PyGe.Curve3d]) -&gt; None:
    <span class="ds">Represents a composite curve, which is a single curve that consists of any number of
component curves that are connected end-to-end. For instance, a composite curve could
consist of four straight line segments that form a square. Each of the component curves
must be bounded curves, which means that infinite lines and rays may not be used as
component curves of a composite. The component curves are not required to all lie in the
same plane. A composite curve object stores a list of pointers to the component curves. The
start parameter of a composite is 0.0. The parameter value at the endpoint of the first
component curve is the approximate length of the first curve (call this value l1). The
parameter value at the endpoint of the second curve is l1 plus the approximate length of
the second curve, etc.</span></code>
            <code><span class="kw">def</span> __init__(self, curveList: list[PyGe.Curve3d], isOwnerOfCurves: list[int]) -&gt; None:
    <span class="ds">Represents a composite curve, which is a single curve that consists of any number of
component curves that are connected end-to-end. For instance, a composite curve could
consist of four straight line segments that form a square. Each of the component curves
must be bounded curves, which means that infinite lines and rays may not be used as
component curves of a composite. The component curves are not required to all lie in the
same plane. A composite curve object stores a list of pointers to the component curves. The
start parameter of a composite is 0.0. The parameter value at the endpoint of the first
component curve is the approximate length of the first curve (call this value l1). The
parameter value at the endpoint of the second curve is l1 plus the approximate length of
the second curve, etc.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a composite curve, which is a single curve that consists of any number of
component curves that are connected end-to-end. For instance, a composite curve could
consist of four straight line segments that form a square. Each of the component curves
must be bounded curves, which means that infinite lines and rays may not be used as
component curves of a composite. The component curves are not required to all lie in the
same plane. A composite curve object stores a list of pointers to the component curves. The
start parameter of a composite is 0.0. The parameter value at the endpoint of the first
component curve is the approximate length of the first curve (call this value l1). The
parameter value at the endpoint of the second curve is l1 plus the approximate length of
the second curve, etc.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; CompositeCurve3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; CompositeCurve3d:</code>
            <code><span class="kw">def</span> createFromLineSeg3dArray(seg: list[PyGe.LineSeg3d]) -&gt; list:</code>
            <code><span class="kw">def</span> getCurveList(self) -&gt; list[PyGe.Curve3d]:</code>
            <code><span class="kw">def</span> globalToLocalParam(self, param: float) -&gt; tuple[float, int]:</code>
            <code><span class="kw">def</span> localToGlobalParam(self, param: float, segNum: int) -&gt; float:</code>
            <code><span class="kw">def</span> setCurveList(self, curveList: list[PyGe.Curve3d]) -&gt; None:</code>
            <code><span class="kw">def</span> setCurveList(self, curveList: list[PyGe.Curve3d], isOwnerOfCurves: list[int]) -&gt; None:</code>
            <code><span class="kw">def</span> setCurveList(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Cone">
        <details>
            <summary>class Cone <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a bounded right circular cone.</span></code>
            <code><span class="kw">def</span> __init__(self, cosineAngle: float, sineAngle: float, baseOrigin: PyGe.Point3d, baseRadius: float, axisOfSymmetry: PyGe.Vector3d) -&gt; None:
    <span class="ds">Represents a bounded right circular cone.</span></code>
            <code><span class="kw">def</span> __init__(self, cosineAngle: float, sineAngle: float, baseOrigin: PyGe.Point3d, baseRadius: float, axisOfSymmetry: PyGe.Vector3d, refAxis: PyGe.Vector3d, height: PyGe.Interval, startAngle: float, endAngle: float) -&gt; None:
    <span class="ds">Represents a bounded right circular cone.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a bounded right circular cone.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> apex(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> axisOfSymmetry(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> baseCenter(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> baseRadius(self) -&gt; float:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Cone:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Cone:</code>
            <code><span class="kw">def</span> getAngles(self) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getHalfAngle(self) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getHeight(self) -&gt; Interval:</code>
            <code><span class="kw">def</span> halfAngle(self) -&gt; float:</code>
            <code><span class="kw">def</span> heightAt(self, val: float) -&gt; float:</code>
            <code><span class="kw">def</span> intersectWith(self, val: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; tuple[bool, int, PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> isClosed(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isOuterNormal(self) -&gt; bool:</code>
            <code><span class="kw">def</span> refAxis(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> set(self, cosineAngle: float, sineAngle: float, baseOrigin: PyGe.Point3d, baseRadius: float, axisOfSymmetry: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, cosineAngle: float, sineAngle: float, baseOrigin: PyGe.Point3d, baseRadius: float, axisOfSymmetry: PyGe.Vector3d, refAxis: PyGe.Vector3d, height: PyGe.Interval, startAngle: float, endAngle: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setAngles(self, startAngle: float, endAngle: float) -&gt; None:</code>
            <code><span class="kw">def</span> setBaseRadius(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setHeight(self, val: PyGe.Interval) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="CubicSplineCurve2d">
        <details>
            <summary>class CubicSplineCurve2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represent an interpolation cubic spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve2d, epsilon: float) -&gt; None:
    <span class="ds">Represent an interpolation cubic spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPnts: list[PyGe.Point2d], tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represent an interpolation cubic spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPnts: list[PyGe.Point2d], startDeriv: PyGe.Vector2d, endDeriv: PyGe.Vector2d, tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represent an interpolation cubic spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, knots: PyGe.KnotVector, fitPnts: list[PyGe.Point2d], firstDerivs: list[PyGe.Point2d], isPeriodic: bool) -&gt; None:
    <span class="ds">Represent an interpolation cubic spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represent an interpolation cubic spline in 2D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; CubicSplineCurve2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; CubicSplineCurve2d:</code>
            <code><span class="kw">def</span> firstDerivAt(self, val: int) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> fitPointAt(self, val: int) -&gt; Point2d:</code>
            <code><span class="kw">def</span> numFitPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> setFirstDerivAt(self, val: int, pt: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> setFitPointAt(self, val: int, pt: PyGe.Point2d) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="CubicSplineCurve3d">
        <details>
            <summary>class CubicSplineCurve3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents an interpolation cubic spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve3d, epsilon: float) -&gt; None:
    <span class="ds">Represents an interpolation cubic spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPnts: list[PyGe.Point3d], tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represents an interpolation cubic spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPnts: list[PyGe.Point3d], startDeriv: PyGe.Vector3d, endDeriv: PyGe.Vector3d, tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represents an interpolation cubic spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, knots: PyGe.KnotVector, fitPnts: list[PyGe.Point3d], firstDerivs: list[PyGe.Vector3d], isPeriodic: bool) -&gt; None:
    <span class="ds">Represents an interpolation cubic spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents an interpolation cubic spline in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; CubicSplineCurve3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; CubicSplineCurve3d:</code>
            <code><span class="kw">def</span> firstDerivAt(self, idx: int) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> fitPointAt(self, idx: int) -&gt; Point3d:</code>
            <code><span class="kw">def</span> numFitPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> setFirstDerivAt(self, idx: int, vec: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> setFitPointAt(self, idx: int, pt: PyGe.Point3d) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Curve2d">
        <details>
            <summary>class Curve2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> area(self, startParam: float, endParam: float, tol: float) -&gt; float:</code>
            <code><span class="kw">def</span> boundBlock(self, range: PyGe.Interval) -&gt; BoundBlock2d:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Curve2d) -&gt; Curve2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> closestPointTo(self, other: PyGe.Point2d | PyGe.Curve2d, tol: PyGe.Tol) -&gt; Point2d:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Curve2d) -&gt; Curve2d:</code>
            <code><span class="kw">def</span> distanceTo(self, pt: PyGe.Point2d | PyGe.Curve2d, tol: PyGe.Tol) -&gt; float:</code>
            <code><span class="kw">def</span> evalPoint(self, param: float, numDeriv: int) -&gt; Point2d:</code>
            <code><span class="kw">def</span> explode(self, val: PyGe.Interval) -&gt; list[PyGe.Curve2d]:</code>
            <code><span class="kw">def</span> getClosestPointTo(self, other: PyGe.Point2d, tol: PyGe.Tol) -&gt; PointOnCurve2d:</code>
            <code><span class="kw">def</span> getClosestPointsTo(self, other: PyGe.Curve2d, tol: PyGe.Tol) -&gt; tuple[PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> getEndPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> getInterval(self) -&gt; Interval:</code>
            <code><span class="kw">def</span> getNormalPoint(self, pnt: PyGe.Point2d, tol: PyGe.Tol) -&gt; PointOnCurve2d:</code>
            <code><span class="kw">def</span> getSamplePoints(self, numSample: int) -&gt; tuple[list[PyGe.Point2d], list[float]]:</code>
            <code><span class="kw">def</span> getSamplePoints(self, fromParam: float, toParam: float, approxEps: float) -&gt; tuple[list[PyGe.Point2d], list[float]]:</code>
            <code><span class="kw">def</span> getSamplePoints(*args) -&gt; tuple[list[PyGe.Point2d], list[float]]:</code>
            <code><span class="kw">def</span> getSplitCurves(self, param: float) -&gt; tuple[PyGe.Curve2d, PyGe.Curve2d]:</code>
            <code><span class="kw">def</span> getStartPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> getTrimmedOffset(self, dist: float, extensionType: PyGe.OffsetCrvExtType, tol: PyGe.Tol) -&gt; list[PyGe.Curve2d]:</code>
            <code><span class="kw">def</span> hasEndPoint(self) -&gt; bool:</code>
            <code><span class="kw">def</span> hasStartPoint(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isClosed(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isDegenerate(self, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Entity2d]:</code>
            <code><span class="kw">def</span> isLinear(self, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Line2d]:</code>
            <code><span class="kw">def</span> isOn(self, pt: float | PyGe.Point2d, tol: PyGe.Tol) -&gt; tuple:</code>
            <code><span class="kw">def</span> isPeriodic(self) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> length(self, frm: float, to: float, tol: float) -&gt; float:</code>
            <code><span class="kw">def</span> orthoBoundBlock(self, range: PyGe.Interval) -&gt; BoundBlock2d:</code>
            <code><span class="kw">def</span> paramAtLength(self, datumParam: float, length: float, posParamDir: bool, tol: float) -&gt; float:</code>
            <code><span class="kw">def</span> paramOf(self, pt: PyGe.Point2d, tol: PyGe.Tol) -&gt; float:</code>
            <code><span class="kw">def</span> reverseParam(self) -&gt; None:</code>
            <code><span class="kw">def</span> setInterval(self, val: PyGe.Interval) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Curve3d">
        <details>
            <summary>class Curve3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> area(self, startParam: float, endParam: float, tol: float) -&gt; float:
    <span class="ds">Returns the area of the interval of the curve defined by startParam and endParam. Returns
Adesk::kTrue if area was successfully computed to within the specified tolerance. If the
curve is not planar, then the area cannot be calculated and a value of Adesk::kFalse is
returned. If the points at startParam and endParam are the same, then this function returns
the area of the closed curve. If the points are different, then this function connects the
two points with a line segment and return the signed area between the curve and the line
segment. If the line segment does not intersect the curve at any points between startParam
and endParam, then the returned area is positive. If the line segment intersects the curves
at any points between startParam and endParam, then the returned area is the sum of the
sub-areas created by the intersection of the line segment with the curve. Each sub-area has
a positive or negative area, depending on whether the curve lies above or below the line
segment. The total area returned by this function can therefore be positive, negative, or
0.</span></code>
            <code><span class="kw">def</span> boundBlock(self, range: PyGe.Interval) -&gt; BoundBlock3d:
    <span class="ds">Returns the bounding box of the curve. The sides of the returned box are parallel to the
coordinate axes.</span></code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Curve3d) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> closestPointTo(self, other: PyGe.Point3d | PyGe.Curve3d, tol: PyGe.Tol) -&gt; Point3d:
    <span class="ds">Finds the closest point on this curve to the input point. This function is the same as
closestPointTo(), except that the closest point is returned as an AcGePointOnCurve3d
object.</span></code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Curve3d) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> distanceTo(self, pt: PyGe.Point3d | PyGe.Curve3d, tol: PyGe.Tol) -&gt; float:
    <span class="ds">Returns the distance between the input point and the closest point on this curve.</span></code>
            <code><span class="kw">def</span> evalPoint(self, param: float, numDeriv: int) -&gt; Point3d:
    <span class="ds">Returns the point on the curve that corresponds to the input parameter value. Also returns
the number of derivative vectors that are specified in numDeriv. The numDeriv parameter
should not be set larger than 2.</span></code>
            <code><span class="kw">def</span> explode(self, val: PyGe.Interval) -&gt; list[PyGe.Curve3d]:
    <span class="ds">Explodes the curve into its individual components. If the curve is a composite curve, then
explodedCurves contains the list of component curves of the composite. If the curve is a
spline, then it is exploded at the points of C1 discontinuity and explodedCurves contains a
copy of each continuous sub-curve. This function returns Adesk::kTrue if the curve was
exploded (that is, the curve was a composite or a discontinuous spline) and Adesk::kFalse
otherwise. The number of entries returned in newExplodedCurves is always the same as the
number of entries in explodedCurves. Each flag in newExplodedCurves indicates whether the
corresponding curve in explodedCurves was created with the new operator. If the flag is 1,
then it is the responsibility of the caller to delete the curve. If the flag is 0, the
curve is deleted by gelib and the caller should not attempt to delete it. If no intrvl
parameter is supplied, then the interval is taken to be the entire curve.</span></code>
            <code><span class="kw">def</span> getClosestPointTo(self, other: PyGe.Point3d, tol: PyGe.Tol) -&gt; PointOnCurve3d:
    <span class="ds">Finds the closest point on this curve to the input point. This function is the same as
closestPointTo(), except that the closest point is returned as an AcGePointOnCurve3d
object.</span></code>
            <code><span class="kw">def</span> getClosestPointsTo(self, other: PyGe.Curve3d, tol: PyGe.Tol) -&gt; tuple[PyGe.Point3d, PyGe.Point3d]:
    <span class="ds">Finds the point on the curve which when projected onto a plane whose normal is
projectDirection is the closest point on the projected curve to the input point. This
function is mainly used by graphics where projectDirection is the line of sight. In this
case, this function returns the point on the curve that appears to be closest to the input
point (but may not be the actual closest point). This function is the same as
projClosestPointTo(const AcGePoint3d&amp;, ...) but returns the closest point as a
AcGePointOnCurve3d object instead of a AcGePoint3d object.</span></code>
            <code><span class="kw">def</span> getEndPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> getInterval(self) -&gt; Interval:
    <span class="ds">Returns the parametric range of the curve. The function evalPoint(double) always returns a
point on this curve when called with a value within the returned interval.</span></code>
            <code><span class="kw">def</span> getNormalPoint(self, pnt: PyGe.Point3d, tol: PyGe.Tol) -&gt; PointOnCurve3d:
    <span class="ds">Finds the point on the input curve whose normal passes through the input point. The
returned point lies on a plane that also contains the input point and is perpendicular to
the curve tangent at that point. The returned point is therefore at a local minimum or a
local maximum from the input point. The curve does not need to be planar. If the curve is
planar, the input point does not need to lie in the plane of the curve. On input, the
second parameter is assumed to contain the parameter value of an initial guess. If there is
more than one normal point on the curve, the returned point will be the one whose parameter
value is closest to the input parameter value.</span></code>
            <code><span class="kw">def</span> getProjClosestPointTo(self, pt: PyGe.Point3d, projDir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; PointOnCurve3d:
    <span class="ds">Finds the point on the curve which when projected onto a plane whose normal is
projectDirection is the closest point on the projected curve to the input point. This
function is mainly used by graphics where projectDirection is the line of sight. In this
case, this function returns the point on the curve that appears to be closest to the input
point (but may not be the actual closest point). This function is the same as
projClosestPointTo(const AcGePoint3d&amp;, ...) but returns the closest point as a
AcGePointOnCurve3d object instead of a AcGePoint3d object.</span></code>
            <code><span class="kw">def</span> getProjClosestPointsTo(self, pt: PyGe.Curve3d, projDir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; tuple[PyGe.PointOnCurve3d, PyGe.PointOnCurve3d]:
    <span class="ds">Finds the point on the curve which when projected onto a plane whose normal is
projectDirection is the closest point on the projected curve to the input point. This
function is mainly used by graphics where projectDirection is the line of sight. In this
case, this function returns the point on the curve that appears to be closest to the input
point (but may not be the actual closest point). This function is the same as
projClosestPointTo(const AcGePoint3d&amp;, ...) but returns the closest point as a
AcGePointOnCurve3d object instead of a AcGePoint3d object.</span></code>
            <code><span class="kw">def</span> getSamplePoints(self, numSample: int) -&gt; tuple[list[PyGe.Point3d], list[float]]:
    <span class="ds">Returns the specified number of points on the curve. The points are equally spaced by
parameter value. So if the interval of the curve [0,1] and numSample is 5, the parameter
values of the returned points are 0, 0.25, 0.5, 0.75, and 1.</span></code>
            <code><span class="kw">def</span> getSamplePoints(self, fromParam: float, toParam: float, approxEps: float) -&gt; tuple[list[PyGe.Point3d], list[float]]:
    <span class="ds">Returns the specified number of points on the curve. The points are equally spaced by
parameter value. So if the interval of the curve [0,1] and numSample is 5, the parameter
values of the returned points are 0, 0.25, 0.5, 0.75, and 1.</span></code>
            <code><span class="kw">def</span> getSamplePoints(*args) -&gt; tuple[list[PyGe.Point3d], list[float]]:
    <span class="ds">Returns the specified number of points on the curve. The points are equally spaced by
parameter value. So if the interval of the curve [0,1] and numSample is 5, the parameter
values of the returned points are 0, 0.25, 0.5, 0.75, and 1.</span></code>
            <code><span class="kw">def</span> getSplitCurves(self, param: float) -&gt; tuple[PyGe.Curve3d, PyGe.Curve3d]:
    <span class="ds">Returns two segments which are obtained by splitting the curve at the input parameter
value. If the specified parameter value does not lie within the parametric interval of the
curve or if it corresponds to the start point or endpoint of the curve, then piece1 and
piece2 are set to null. This function uses the new to create the curve segments whose
addresses are returned in piece1 and piece2. It is the responsibility of the caller to
delete these objects.</span></code>
            <code><span class="kw">def</span> getStartPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> getTrimmedOffset(self, dist: float, planeNormal: PyGe.Vector3d, extensionType: PyGe.OffsetCrvExtType, tol: PyGe.Tol) -&gt; list[PyGe.Curve3d]:
    <span class="ds">Returns one or more offset curves that represent the trimmed offset of the curve. The curve
must be planar and planeNormal must be perpendicular to the plane of the curve. The
positive direction of offset at a point on the curve is taken to be the cross product of
planeNormal with the tangent vector at that point. The curve may be offset in either of two
directions by specifying a positive or negative offset distance; planeNormal determines
which direction is the positive direction of offset. The returned offset curves are trimmed
so that they do not contain any points of self-intersection. Each curve that is returned in
offsetCurveList is created with the new and it is the responsibility of the caller to
delete these curves. Each curve that is returned in offsetCurveList is a connected curve
and may be a composite curve if the offset curve had to be trimmed to remove
self-intersecting loops. offsetCurveList only contains more than one curve if the offset
operation produces multiple curves which are not connected. If the original curve contains
points of C1 discontinuity and the direction of offset causes the offset curve to be
disjoint (for instance, if the original curve is a composite curve that is a rectangle and
the direction of offset is to the outside of the rectangle), then the offset curve is
closed with an arc or a line segment, or the curves are simply extended depending on the
value of extensionType.</span></code>
            <code><span class="kw">def</span> hasEndPoint(self) -&gt; bool:
    <span class="ds">Returns Adesk::kTrue if curve has an endpoint. A return value of Adesk::kFalse means that
the parametric interval of the curve does not have an upper bound. The endPnt parameter
contains meaningful data only if this function returns a value of Adesk::kTrue.</span></code>
            <code><span class="kw">def</span> hasStartPoint(self) -&gt; bool:
    <span class="ds">Returns Adesk::kTrue if curve has a start point. A return value of Adesk::kFalse means that
the parametric interval of the curve does not have a lower bound. The startPnt parameter
contains meaningful data only if this function returns a value of Adesk::kTrue.</span></code>
            <code><span class="kw">def</span> isClosed(self, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Determines if start point and endpoint of curve are the same.</span></code>
            <code><span class="kw">def</span> isCoplanarWith(self, curve: PyGe.Curve3d, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Plane]:
    <span class="ds">Returns Adesk::kTrue if both curve are planar and lie in the same plane. The plane
parameter is only valid if this function returns a value of Adesk::kTrue.</span></code>
            <code><span class="kw">def</span> isDegenerate(self, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Entity3d]:
    <span class="ds">Determines if the curve is degenerate and if so returns the type of entity which the curve
degenerates into. For example, if the curve is a circle with a radius of 0 then
degenerateType is set to AcGe::kPoint3d. If the curve is an ellipse with a minor radius of
0 and a major radius of 1, then degenerateType is set to AcGe::kLineSeg3d. The
degenerateType parameter is only set to something meaningful when this function returns a
value of Adesk::kTrue.</span></code>
            <code><span class="kw">def</span> isLinear(self, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Line3d]:
    <span class="ds">Determines if curve is linear. This function returns an infinite line even if the curve is
not infinite. The line parameter contains meaningful data only if this function returns a
value of Adesk::kTrue.</span></code>
            <code><span class="kw">def</span> isOn(self, pt: float | PyGe.Point3d, tol: PyGe.Tol) -&gt; tuple:
    <span class="ds">Determines if input parameter value is within valid parametric range of curve.</span></code>
            <code><span class="kw">def</span> isPeriodic(self) -&gt; tuple[bool, float]:
    <span class="ds">Determines if the curve is periodic. The curve is periodic if and only if it is closed and
the two points evalPoint(t) and evalPoint(t+period) are always the same point for all
values of t.</span></code>
            <code><span class="kw">def</span> isPlanar(self, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Plane]:
    <span class="ds">Determines if curve is planar. If the curve is a line, then this function returns an
arbitrary plane that contains the line. The plane parameter contains meaningful data only
if this function returns a value of Adesk::kTrue.</span></code>
            <code><span class="kw">def</span> length(self, frm: float, to: float, tol: float) -&gt; float:
    <span class="ds">Returns the arc length of the curve between the two parameter values.</span></code>
            <code><span class="kw">def</span> orthoBoundBlock(self, range: PyGe.Interval) -&gt; BoundBlock3d:
    <span class="ds">Returns the bounding box of the curve. The sides of the returned box are parallel to the
coordinate axes.</span></code>
            <code><span class="kw">def</span> orthoProject(self, projectionPlane: PyGe.Plane, tol: PyGe.Tol) -&gt; Entity3d:
    <span class="ds">Returns the entity that is the orthogonal projection of the curve onto the projection
plane. The returned entity may not be of the same type as the original curve and may not
even be a curve (for instance, a line projects into a point if it is orthogonal to the
projection plane). The returned entity is created with the new and it is the responsibility
of the caller to delete it.</span></code>
            <code><span class="kw">def</span> paramAtLength(self, datumParam: float, length: float, posParamDir: bool, tol: float) -&gt; float:
    <span class="ds">Returns the parameter value of the point whose arc length distance (from the point with
parameter value datumParam) is the input length. In other words, if t = paramAtLength
(datumParam, len, posParamDir, tol) then length (t, datumParam, tol) is (approximately)
equal to len. If posParamDir is set to Adesk::kTrue, then the returned parameter value is
greater than datumParam. Otherwise it will be less than datumParam.</span></code>
            <code><span class="kw">def</span> paramOf(self, pt: PyGe.Point3d, tol: PyGe.Tol) -&gt; float:
    <span class="ds">Returns the parameter value of pnt. This function assumes that pnt lies on the curve and
does not verify this. If pnt does not lie on the curve, this function will return
unpredictable results. If it is not known whether pnt lies on the curve, the user should
not call this function but should instead call AcGeCurve3d::isOn (pnt, param, tol).</span></code>
            <code><span class="kw">def</span> projClosestPointTo(self, pt: PyGe.Point3d, projDir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; Point3d:
    <span class="ds">Finds the point on the curve which when projected onto a plane whose normal is
projectDirection is the closest point on the projected curve to the input point. This
function is mainly used by graphics where projectDirection is the line of sight. In this
case, this function returns the point on the curve that appears to be closest to the input
point (but may not be the actual closest point). This function is the same as
projClosestPointTo(const AcGePoint3d&amp;, ...) but returns the closest point as a
AcGePointOnCurve3d object instead of a AcGePoint3d object.</span></code>
            <code><span class="kw">def</span> projClosestPointsTo(self, pt: PyGe.Curve3d, projDir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; tuple[PyGe.Point3d, PyGe.Point3d]:
    <span class="ds">Finds the point on the curve which when projected onto a plane whose normal is
projectDirection is the closest point on the projected curve to the input point. This
function is mainly used by graphics where projectDirection is the line of sight. In this
case, this function returns the point on the curve that appears to be closest to the input
point (but may not be the actual closest point). This function is the same as
projClosestPointTo(const AcGePoint3d&amp;, ...) but returns the closest point as a
AcGePointOnCurve3d object instead of a AcGePoint3d object.</span></code>
            <code><span class="kw">def</span> project(self, projectionPlane: PyGe.Plane, projDir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; Entity3d:
    <span class="ds">Returns the entity that is the projection of the curve onto the projection plane in the
specified direction. The projectDirection vector must not be parallel to the projection
plane. The returned entity may not be of the same type as the original curve and may not
even be a curve (for instance, a line projects into a point if it is parallel to
projectDirection). The returned entity is created with the new and it is the responsibility
of the caller to delete it.</span></code>
            <code><span class="kw">def</span> reverseParam(self) -&gt; None:
    <span class="ds">Reverses the parametric direction of the curve. The point set of the curve is unchanged,
but the direction of the curve is reversed.</span></code>
            <code><span class="kw">def</span> setInterval(self, val: PyGe.Interval) -&gt; None:
    <span class="ds">Sets the domain of the curve to the input interval.</span></code>
        </details>
    </div>

    <div class="class" id="CurveCurveInt2d">
        <details>
            <summary>class CurveCurveInt2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt2d, AcGeCircArc2d, and AcGeEllipArc2d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(self, curve1: PyGe.Curve2d, curve2: PyGe.Curve2d) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt2d, AcGeCircArc2d, and AcGeEllipArc2d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(self, curve1: PyGe.Curve2d, curve2: PyGe.Curve2d, tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt2d, AcGeCircArc2d, and AcGeEllipArc2d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(self, curve1: PyGe.Curve2d, curve2: PyGe.Curve2d, range1: PyGe.Interval, range2: PyGe.Interval) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt2d, AcGeCircArc2d, and AcGeEllipArc2d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(self, curve1: PyGe.Curve2d, curve2: PyGe.Curve2d, range1: PyGe.Interval, range2: PyGe.Interval, tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt2d, AcGeCircArc2d, and AcGeEllipArc2d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt2d, AcGeCircArc2d, and AcGeEllipArc2d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; CurveCurveInt2d:</code>
            <code><span class="kw">def</span> changeCurveOrder(self) -&gt; None:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; CurveCurveInt2d:</code>
            <code><span class="kw">def</span> curve1(self) -&gt; Curve2d:</code>
            <code><span class="kw">def</span> curve2(self) -&gt; Curve2d:</code>
            <code><span class="kw">def</span> getIntConfigs(self, intNum: int) -&gt; tuple:</code>
            <code><span class="kw">def</span> getIntParams(self, intNum: int) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getIntRanges(self) -&gt; tuple[PyGe.Interval, PyGe.Interval]:</code>
            <code><span class="kw">def</span> getOverlapRanges(self, intNum: int) -&gt; tuple[PyGe.Interval, PyGe.Interval]:</code>
            <code><span class="kw">def</span> getPointOnCurve1(self, intNum: int) -&gt; PointOnCurve2d:</code>
            <code><span class="kw">def</span> getPointOnCurve2(self, intNum: int) -&gt; PointOnCurve2d:</code>
            <code><span class="kw">def</span> intPoint(self, intNum: int) -&gt; Point2d:</code>
            <code><span class="kw">def</span> intPointTol(self, intNum: int) -&gt; float:</code>
            <code><span class="kw">def</span> isTangential(self, intNum: int) -&gt; bool:</code>
            <code><span class="kw">def</span> isTransversal(self, intNum: int) -&gt; bool:</code>
            <code><span class="kw">def</span> numIntPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> orderWrt1(self) -&gt; CurveCurveInt2d:</code>
            <code><span class="kw">def</span> orderWrt2(self) -&gt; CurveCurveInt2d:</code>
            <code><span class="kw">def</span> overlapCount(self) -&gt; int:</code>
            <code><span class="kw">def</span> overlapDirection(self) -&gt; bool:</code>
            <code><span class="kw">def</span> tolerance(self) -&gt; Tol:</code>
        </details>
    </div>

    <div class="class" id="CurveCurveInt3d">
        <details>
            <summary>class CurveCurveInt3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt3d, AcGeCircArc3d, and AcGeEllipArc3d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(self, curve1: PyGe.Curve3d, curve2: PyGe.Curve3d) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt3d, AcGeCircArc3d, and AcGeEllipArc3d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(self, curve1: PyGe.Curve3d, curve2: PyGe.Curve3d, planeNormal: PyGe.Vector3d, tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt3d, AcGeCircArc3d, and AcGeEllipArc3d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(self, curve1: PyGe.Curve3d, curve2: PyGe.Curve3d, range1: PyGe.Interval, range2: PyGe.Interval) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt3d, AcGeCircArc3d, and AcGeEllipArc3d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(self, curve1: PyGe.Curve3d, curve2: PyGe.Curve3d, range1: PyGe.Interval, range2: PyGe.Interval, tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt3d, AcGeCircArc3d, and AcGeEllipArc3d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents the intersection set of two curves. There are special case intersectWith()
functions in the AcGeLinearEnt3d, AcGeCircArc3d, and AcGeEllipArc3d classes to find the
points of intersection between two lines, a line and an arc, an arc and an arc, or a line
and an ellipse. However, there is no general intersectWith() function to find the points of
intersection between two general curves. This can only be done by constructing an object of
this class. Objects of this class are constructed by specifying the two curves that are to
be intersected. It is also possible to specify a specific interval of each curve that is to
be intersected. Pointers to these curves are then stored as data members of this class.
This class contains query methods that return the intersection points and intervals of
overlap between the two curves. There are also methods that return information about each
intersection point, such as whether the intersection is a tangential or transversal
intersection. Points of self-intersection of a curve can be found by passing the same curve
in both parameters of the constructor.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; CurveCurveInt3d:</code>
            <code><span class="kw">def</span> changeCurveOrder(self) -&gt; None:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; CurveCurveInt3d:</code>
            <code><span class="kw">def</span> curve1(self) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> curve2(self) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> getIntConfigs(self, intNum: int) -&gt; tuple:</code>
            <code><span class="kw">def</span> getIntParams(self, intNum: int) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getIntRanges(self) -&gt; tuple[PyGe.Interval, PyGe.Interval]:</code>
            <code><span class="kw">def</span> getOverlapRanges(self, intNum: int) -&gt; tuple[PyGe.Interval, PyGe.Interval]:</code>
            <code><span class="kw">def</span> getPointOnCurve1(self, intNum: int) -&gt; PointOnCurve3d:</code>
            <code><span class="kw">def</span> getPointOnCurve2(self, intNum: int) -&gt; PointOnCurve3d:</code>
            <code><span class="kw">def</span> intPoint(self, intNum: int) -&gt; Point3d:</code>
            <code><span class="kw">def</span> intPointTol(self, intNum: int) -&gt; float:</code>
            <code><span class="kw">def</span> isTangential(self, intNum: int) -&gt; bool:</code>
            <code><span class="kw">def</span> isTransversal(self, intNum: int) -&gt; bool:</code>
            <code><span class="kw">def</span> numIntPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> orderWrt1(self) -&gt; CurveCurveInt3d:</code>
            <code><span class="kw">def</span> orderWrt2(self) -&gt; CurveCurveInt3d:</code>
            <code><span class="kw">def</span> overlapCount(self) -&gt; int:</code>
            <code><span class="kw">def</span> overlapDirection(self) -&gt; bool:</code>
            <code><span class="kw">def</span> planeNormal(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> set(self, c1: PyGe.Curve3d, c2: PyGe.Curve3d) -&gt; None:</code>
            <code><span class="kw">def</span> tolerance(self) -&gt; Tol:</code>
        </details>
    </div>

    <div class="class" id="CurveSurfInt">
        <details>
            <summary>class CurveSurfInt <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">This class holds data for intersections of a 3D curve and a surface.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve3d, surf: PyGe.Surface) -&gt; None:
    <span class="ds">This class holds data for intersections of a 3D curve and a surface.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve3d, surf: PyGe.Surface, tol: PyGe.Tol) -&gt; None:
    <span class="ds">This class holds data for intersections of a 3D curve and a surface.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">This class holds data for intersections of a 3D curve and a surface.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; CurveSurfInt:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; CurveSurfInt:</code>
            <code><span class="kw">def</span> curve(self) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> getIntConfigs(self, intNum: int) -&gt; tuple:</code>
            <code><span class="kw">def</span> getIntParams(self, intNum: int) -&gt; tuple[float, PyGe.Point2d]:</code>
            <code><span class="kw">def</span> getPointOnCurve(self, intNum: int) -&gt; PointOnCurve3d:</code>
            <code><span class="kw">def</span> getPointOnSurface(self, intNum: int) -&gt; PointOnSurface:</code>
            <code><span class="kw">def</span> intPoint(self, intNum: int) -&gt; Point3d:</code>
            <code><span class="kw">def</span> numIntPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> set(self, curve: PyGe.Curve3d, surf: PyGe.Surface) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, curve: PyGe.Curve3d, surf: PyGe.Surface, tol: PyGe.Tol) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> surface(self) -&gt; PyGe.Surface:</code>
            <code><span class="kw">def</span> tolerance(self) -&gt; Tol:</code>
        </details>
    </div>

    <div class="class" id="Cylinder">
        <details>
            <summary>class Cylinder <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a bounded cylinder surface.</span></code>
            <code><span class="kw">def</span> __init__(self, radius: float, origin: PyGe.Point3d, axisOfSymmetry: PyGe.Vector3d) -&gt; None:
    <span class="ds">Represents a bounded cylinder surface.</span></code>
            <code><span class="kw">def</span> __init__(self, radius: float, origin: PyGe.Point3d, axisOfSymmetry: PyGe.Vector3d, refAxis: PyGe.Vector3d, height: PyGe.Interval, startAngle: float, endAngle: float) -&gt; None:
    <span class="ds">Represents a bounded cylinder surface.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a bounded cylinder surface.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> axisOfSymmetry(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Cylinder:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Cylinder:</code>
            <code><span class="kw">def</span> getAngles(self) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getHeight(self) -&gt; Interval:</code>
            <code><span class="kw">def</span> heightAt(self, u: float) -&gt; float:</code>
            <code><span class="kw">def</span> intersectWith(self, val: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; tuple[bool, int, PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> isClosed(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isOuterNormal(self) -&gt; bool:</code>
            <code><span class="kw">def</span> origin(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> radius(self) -&gt; float:</code>
            <code><span class="kw">def</span> refAxis(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> set(self, radius: float, origin: PyGe.Point3d, axisOfSymmetry: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, radius: float, origin: PyGe.Point3d, axisOfSymmetry: PyGe.Vector3d, refAxis: PyGe.Vector3d, height: PyGe.Interval, startAngle: float, endAngle: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setAngles(self, start: float, end: float) -&gt; None:</code>
            <code><span class="kw">def</span> setHeight(self, val: PyGe.Interval) -&gt; None:</code>
            <code><span class="kw">def</span> setRadius(self, val: float) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="EllipArc2d">
        <details>
            <summary>class EllipArc2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, carc: PyGe.CircArc2d) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point2d, majorAxis: PyGe.Vector2d, minorAxis: PyGe.Vector2d, majorRadius: float, minorRadius: float) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point2d, majorAxis: PyGe.Vector2d, minorAxis: PyGe.Vector2d, majorRadius: float, minorRadius: float, startAngle: float, endAngle: float) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 2D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; EllipArc2d:</code>
            <code><span class="kw">def</span> center(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; EllipArc2d:</code>
            <code><span class="kw">def</span> endAng(self) -&gt; float:</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> intersectWith(self, val: PyGe.LinearEnt2d, tol: PyGe.Tol) -&gt; tuple[bool, int, PyGe.Point2d, PyGe.Point2d]:</code>
            <code><span class="kw">def</span> isCircular(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isClockWise(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isInside(self, pt: PyGe.Point2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> majorAxis(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> majorRadius(self) -&gt; float:</code>
            <code><span class="kw">def</span> minorAxis(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> minorRadius(self) -&gt; float:</code>
            <code><span class="kw">def</span> set(self, carc: PyGe.CircArc2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, cent: PyGe.Point2d, majorAxis: PyGe.Vector2d, minorAxis: PyGe.Vector2d, majorRadius: float, minorRadius: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, cent: PyGe.Point2d, majorAxis: PyGe.Vector2d, minorAxis: PyGe.Vector2d, majorRadius: float, minorRadius: float, startAngle: float, endAngle: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setAngles(self, startAngle: float, endAngle: float) -&gt; None:</code>
            <code><span class="kw">def</span> setAxes(self, majorAxis: PyGe.Vector2d, minorAxis: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> setCenter(self, pt: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> setMajorRadius(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setMinorRadius(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> startAng(self) -&gt; float:</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; Point2d:</code>
        </details>
    </div>

    <div class="class" id="EllipArc3d">
        <details>
            <summary>class EllipArc3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, carc: PyGe.CircArc3d) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point3d, majorAxis: PyGe.Vector3d, minorAxis: PyGe.Vector3d, majorRadius: float, minorRadius: float) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, cent: PyGe.Point3d, majorAxis: PyGe.Vector3d, minorAxis: PyGe.Vector3d, majorRadius: float, minorRadius: float, startAngle: float, endAngle: float) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents both full ellipses and elliptical arcs in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; EllipArc3d:</code>
            <code><span class="kw">def</span> center(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> closestPointToPlane(self, plane: PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; tuple[PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; EllipArc3d:</code>
            <code><span class="kw">def</span> endAng(self) -&gt; float:</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> getPlane(self) -&gt; Plane:</code>
            <code><span class="kw">def</span> intersectWith(self, other: PyGe.LinearEnt3d | PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; tuple[bool, int, PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> isCircular(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isInside(self, pt: PyGe.Point3d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> majorAxis(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> majorRadius(self) -&gt; float:</code>
            <code><span class="kw">def</span> minorAxis(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> minorRadius(self) -&gt; float:</code>
            <code><span class="kw">def</span> normal(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> projIntersectWith(self, other: PyGe.LinearEnt3d, projDir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; tuple:</code>
            <code><span class="kw">def</span> set(self, carc: PyGe.CircArc3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, cent: PyGe.Point3d, majorAxis: PyGe.Vector3d, minorAxis: PyGe.Vector3d, majorRadius: float, minorRadius: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, cent: PyGe.Point3d, majorAxis: PyGe.Vector3d, minorAxis: PyGe.Vector3d, majorRadius: float, minorRadius: float, startAngle: float, endAngle: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setAngles(self, startAngle: float, endAngle: float) -&gt; None:</code>
            <code><span class="kw">def</span> setAxes(self, majorAxis: PyGe.Vector3d, minorAxis: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> setCenter(self, pt: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> setMajorRadius(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setMinorRadius(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> startAng(self) -&gt; float:</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; Point3d:</code>
        </details>
    </div>

    <div class="class" id="Entity2d">
        <details>
            <summary>class Entity2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __hash__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __ne__(self) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copy(self) -&gt; Entity2d:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; Entity2d:</code>
            <code><span class="kw">def</span> isEqualTo(self, val: PyGe.Entity2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isKindOf(self, val: PyGe.EntityId) -&gt; bool:</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(self, pt: PyGe.Point2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> mirror(self, val: PyGe.Line2d) -&gt; None:</code>
            <code><span class="kw">def</span> rotateBy(self, angle: float, pt: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> scaleBy(self, scaleFactor: float, pt: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> transformBy(self, val: PyGe.Matrix2d) -&gt; None:</code>
            <code><span class="kw">def</span> translateBy(self, vec: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> type(self) -&gt; EntityId:</code>
        </details>
    </div>

    <div class="class" id="Entity3d">
        <details>
            <summary>class Entity3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __hash__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __ne__(self) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copy(self) -&gt; Entity3d:
    <span class="ds">Returns a pointer to a copy of this entity. This copy is created using the new and it is
the responsibility of the caller to delete it.</span></code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Entity3d:</code>
            <code><span class="kw">def</span> isEqualTo(self, val: PyGe.Entity3d, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Determines if two entities are equal to each other. Two entities are considered to be equal
only if they are of the same type and they represent the same 3D point set. For instance,
if the two entities are of types AcGeCircArc3d and AcGeEllipArc3d then they are not
considered equal even if the ellipse is completely coincident with the circle. Also, two
curves are not considered equal unless they have the same parameterization. For instance,
two infinite coincident lines are not considered equal if they have different scaling in
their parameterization.</span></code>
            <code><span class="kw">def</span> isKindOf(self, val: PyGe.EntityId) -&gt; bool:</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(self, pt: PyGe.Point3d, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Returns Adesk::kTrue if pnt lies on entity; otherwise, returns Adesk::kFalse.</span></code>
            <code><span class="kw">def</span> mirror(self, val: PyGe.Plane) -&gt; None:
    <span class="ds">Transforms the entity by mirroring it across the input plane.</span></code>
            <code><span class="kw">def</span> rotateBy(self, angle: float, vec: PyGe.Vector3d, pt: PyGe.Point3d) -&gt; None:
    <span class="ds">Rotates the entity by the input angle about the line defined by the input point and vector.</span></code>
            <code><span class="kw">def</span> scaleBy(self, scaleFactor: float, pt: PyGe.Point3d) -&gt; None:
    <span class="ds">Scales the entity about the input point by the input scale factor. Input scale factor must
be greater than 0.</span></code>
            <code><span class="kw">def</span> transformBy(self, val: PyGe.Matrix3d) -&gt; None:
    <span class="ds">Transforms the entity by applying the input matrix.</span></code>
            <code><span class="kw">def</span> translateBy(self, vec: PyGe.Vector3d) -&gt; None:
    <span class="ds">Translates the entity by the input vector.</span></code>
            <code><span class="kw">def</span> type(self) -&gt; EntityId:
    <span class="ds">Returns the type of the entity.</span></code>
        </details>
    </div>

    <div class="class" id="EntityId">
        <details>
            <summary>class EntityId <span class="tag">Class</span></summary>
            <code>kEntity2d: ClassVar[Self]</code>
            <code>kEntity3d: ClassVar[Self]</code>
            <code>kPointEnt2d: ClassVar[Self]</code>
            <code>kPointEnt3d: ClassVar[Self]</code>
            <code>kPosition2d: ClassVar[Self]</code>
            <code>kPosition3d: ClassVar[Self]</code>
            <code>kPointOnCurve2d: ClassVar[Self]</code>
            <code>kPointOnCurve3d: ClassVar[Self]</code>
            <code>kPointOnSurface: ClassVar[Self]</code>
            <code>kBoundedPlane: ClassVar[Self]</code>
            <code>kCircArc2d: ClassVar[Self]</code>
            <code>kCircArc3d: ClassVar[Self]</code>
            <code>kConic2d: ClassVar[Self]</code>
            <code>kConic3d: ClassVar[Self]</code>
            <code>kCurve2d: ClassVar[Self]</code>
            <code>kCurve3d: ClassVar[Self]</code>
            <code>kEllipArc2d: ClassVar[Self]</code>
            <code>kEllipArc3d: ClassVar[Self]</code>
            <code>kLine2d: ClassVar[Self]</code>
            <code>kLine3d: ClassVar[Self]</code>
            <code>kLinearEnt2d: ClassVar[Self]</code>
            <code>kLinearEnt3d: ClassVar[Self]</code>
            <code>kLineSeg2d: ClassVar[Self]</code>
            <code>kLineSeg3d: ClassVar[Self]</code>
            <code>kPlanarEnt: ClassVar[Self]</code>
            <code>kPlane: ClassVar[Self]</code>
            <code>kRay2d: ClassVar[Self]</code>
            <code>kRay3d: ClassVar[Self]</code>
            <code>kSurface: ClassVar[Self]</code>
            <code>kSphere: ClassVar[Self]</code>
            <code>kCylinder: ClassVar[Self]</code>
            <code>kTorus: ClassVar[Self]</code>
            <code>kCone: ClassVar[Self]</code>
            <code>kSplineEnt2d: ClassVar[Self]</code>
            <code>kPolyline2d: ClassVar[Self]</code>
            <code>kAugPolyline2d: ClassVar[Self]</code>
            <code>kNurbCurve2d: ClassVar[Self]</code>
            <code>kDSpline2d: ClassVar[Self]</code>
            <code>kCubicSplineCurve2d: ClassVar[Self]</code>
            <code>kSplineEnt3d: ClassVar[Self]</code>
            <code>kPolyline3d: ClassVar[Self]</code>
            <code>kAugPolyline3d: ClassVar[Self]</code>
            <code>kNurbCurve3d: ClassVar[Self]</code>
            <code>kDSpline3d: ClassVar[Self]</code>
            <code>kCubicSplineCurve3d: ClassVar[Self]</code>
            <code>kTrimmedCrv2d: ClassVar[Self]</code>
            <code>kCompositeCrv2d: ClassVar[Self]</code>
            <code>kCompositeCrv3d: ClassVar[Self]</code>
            <code>kExternalSurface: ClassVar[Self]</code>
            <code>kNurbSurface: ClassVar[Self]</code>
            <code>kTrimmedSurface: ClassVar[Self]</code>
            <code>kOffsetSurface: ClassVar[Self]</code>
            <code>kEnvelope2d: ClassVar[Self]</code>
            <code>kCurveBoundedSurface: ClassVar[Self]</code>
            <code>kExternalCurve3d: ClassVar[Self]</code>
            <code>kExternalCurve2d: ClassVar[Self]</code>
            <code>kSurfaceCurve2dTo3d: ClassVar[Self]</code>
            <code>kSurfaceCurve3dTo2d: ClassVar[Self]</code>
            <code>kExternalBoundedSurface: ClassVar[Self]</code>
            <code>kCurveCurveInt2d: ClassVar[Self]</code>
            <code>kCurveCurveInt3d: ClassVar[Self]</code>
            <code>kBoundBlock2d: ClassVar[Self]</code>
            <code>kBoundBlock3d: ClassVar[Self]</code>
            <code>kOffsetCurve2d: ClassVar[Self]</code>
            <code>kOffsetCurve3d: ClassVar[Self]</code>
            <code>kPolynomCurve3d: ClassVar[Self]</code>
            <code>kBezierCurve3d: ClassVar[Self]</code>
            <code>kObject: ClassVar[Self]</code>
            <code>kFitData3d: ClassVar[Self]</code>
            <code>kHatch: ClassVar[Self]</code>
            <code>kTrimmedCurve2d: ClassVar[Self]</code>
            <code>kTrimmedCurve3d: ClassVar[Self]</code>
            <code>kCurveSampleData: ClassVar[Self]</code>
            <code>kEllipCone: ClassVar[Self]</code>
            <code>kEllipCylinder: ClassVar[Self]</code>
            <code>kIntervalBoundBlock: ClassVar[Self]</code>
            <code>kClipBoundary2d: ClassVar[Self]</code>
            <code>kExternalObject: ClassVar[Self]</code>
            <code>kCurveSurfaceInt: ClassVar[Self]</code>
            <code>kSurfaceSurfaceInt: ClassVar[Self]</code>
            <code>Helix: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ExternalBoundedSurface">
        <details>
            <summary>class ExternalBoundedSurface <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">AcGeExternalBoundedSurface class is a representation of a bounded surface defined outside
of the geometry library. A logical view of this class is as follows: An instance of
AcGeExternalBoundedSurface consists of an instance of AcGeExternalSurface representing the
unbounded surface geometry, together with a collection of instances of AcGeCurveBoundary,
each representing a boundary on the unbounded surface. It is important to realize that the
representation is geometric. No topological information is represented in this class. This
assertion is made explicit by deriving this class from AcGeSurface. A typical use of
AcGeExternalBoundedSurface would be to represent an ACIS FACE (that is, faces on Designer
and Autosurf models) as a bounded surface. Clearly, an instance of
AcGeExternalBoundedSurface can be used as any other AcGeSurface. Operations that are well
defined on bounded surfaces can accommodate the boundaries within the algorithms (an
example is closest point). Alternatively, a knowledge of the precise definition of the
external entity allows direct access to the external entity in its native form. This access
is more efficient because it avoids the level of indirection that is incurred when
accessing the external entity through GeLib interface.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; ExternalBoundedSurface:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; ExternalBoundedSurface:</code>
        </details>
    </div>

    <div class="class" id="ExternalCurve2d">
        <details>
            <summary>class ExternalCurve2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; ExternalCurve2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; ExternalCurve2d:</code>
        </details>
    </div>

    <div class="class" id="ExternalCurve3d">
        <details>
            <summary>class ExternalCurve3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; ExternalCurve3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; ExternalCurve3d:</code>
            <code><span class="kw">def</span> externalCurveKind(self) -&gt; ExternalEntityKind:</code>
            <code><span class="kw">def</span> getNativeCurve(self) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> isCircArc(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isDefined(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isEllipArc(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isLine(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isLineSeg(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isNurbCurve(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isOwnerOfCurve(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isRay(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setToOwnCurve(self) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="ExternalEntityKind">
        <details>
            <summary>class ExternalEntityKind <span class="tag">Class</span></summary>
            <code>kAcisEntity: ClassVar[Self]</code>
            <code>kExternalEntityUndefined: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="ExternalSurface">
        <details>
            <summary>class ExternalSurface <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">AcGeExternalSurface class is a representation for an unbounded (other than by the
parametric bounds of the surface) surface geometry that has its definition external to
GeLib. Since AcGeExternalSurface is a AcGeSurface, these external entities can be treated
as any other GeLib surface. Certain external surface points sets may have corresponding
native representations in GeLib. In such cases, it is possible to obtain such GeLib
representations. However, the surface definitions of native GeLib surfaces differ from the
definition of external entities. An example of such a difference is differing surface
parameterizations. A typical use of AcGeExternalSurface is to represent a ShapeManager
surface. Clearly, an instance of AcGeExternalSurface can be used as any other AcGeSurface.
Alternatively, a knowledge of the precise definition of the external entity allows direct
access to the external entity in its native form. This access is more efficient since it
avoids the level of indirection that is incurred when accessing the external entity through
GeLib interface.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; ExternalSurface:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; ExternalSurface:</code>
        </details>
    </div>

    <div class="class" id="Interval">
        <details>
            <summary>class Interval <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __ge__(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> __gt__(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a finite or semi-infinite interval as the real axis whose bounds are defined
with some given tolerance.</span></code>
            <code><span class="kw">def</span> __init__(self, lower: float, upper: float) -&gt; None:
    <span class="ds">Represents a finite or semi-infinite interval as the real axis whose bounds are defined
with some given tolerance.</span></code>
            <code><span class="kw">def</span> __init__(self, bounded: bool, upper: float) -&gt; None:
    <span class="ds">Represents a finite or semi-infinite interval as the real axis whose bounds are defined
with some given tolerance.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a finite or semi-infinite interval as the real axis whose bounds are defined
with some given tolerance.</span></code>
            <code><span class="kw">def</span> __le__(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> __lt__(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> __ne__(self, val: PyGe.Interval) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> contains(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> element(self) -&gt; float:</code>
            <code><span class="kw">def</span> getBounds(self) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getMerge(self, val: float) -&gt; Interval:</code>
            <code><span class="kw">def</span> intersectWith(self, val: PyGe.Interval) -&gt; tuple[bool, PyGe.Interval]:</code>
            <code><span class="kw">def</span> isBounded(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isBoundedAbove(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isBoundedBelow(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isContinuousAtUpper(self, val: PyGe.Interval) -&gt; bool:</code>
            <code><span class="kw">def</span> isDisjoint(self, val: PyGe.Interval) -&gt; bool:</code>
            <code><span class="kw">def</span> isEqualAtLower(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> isEqualAtUpper(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> isGreater(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> isGreaterOrEqual(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> isLess(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> isLessOrEqual(self, val: PyGe.Interval | float) -&gt; bool:</code>
            <code><span class="kw">def</span> isOverlapAtUpper(self, val: PyGe.Interval) -&gt; tuple[bool, PyGe.Interval]:</code>
            <code><span class="kw">def</span> isPeriodicallyOn(self, val: float) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> isSingleton(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isUnBounded(self) -&gt; bool:</code>
            <code><span class="kw">def</span> length(self) -&gt; float:</code>
            <code><span class="kw">def</span> lowerBound(self) -&gt; float:</code>
            <code><span class="kw">def</span> set(self) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, lower: float, upper: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, bounded: bool, upper: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setLower(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setTolerance(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setUpper(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> subtract(self, val: PyGe.Interval) -&gt; tuple[int, PyGe.Interval, PyGe.Interval]:</code>
            <code><span class="kw">def</span> tolerance(self) -&gt; float:</code>
            <code><span class="kw">def</span> upperBound(self) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="KnotParameterization">
        <details>
            <summary>class KnotParameterization <span class="tag">Class</span></summary>
            <code>kChord: ClassVar[Self]</code>
            <code>kSqrtChord: ClassVar[Self]</code>
            <code>kUniform: ClassVar[Self]</code>
            <code>kCustomParameterization: ClassVar[Self]</code>
            <code>kNotDefinedKnotParam: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="KnotVector">
        <details>
            <summary>class KnotVector <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents an ordered non-decreasing sequence of numbers used in several spline entities.</span></code>
            <code><span class="kw">def</span> __init__(self, size: int, growSize: int) -&gt; None:
    <span class="ds">Represents an ordered non-decreasing sequence of numbers used in several spline entities.</span></code>
            <code><span class="kw">def</span> __init__(self, data: list[float]) -&gt; None:
    <span class="ds">Represents an ordered non-decreasing sequence of numbers used in several spline entities.</span></code>
            <code><span class="kw">def</span> __init__(self, plusMult: int, other: PyGe.KnotVector) -&gt; None:
    <span class="ds">Represents an ordered non-decreasing sequence of numbers used in several spline entities.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents an ordered non-decreasing sequence of numbers used in several spline entities.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> append(self, val: float) -&gt; int:</code>
            <code><span class="kw">def</span> append(self, tail: PyGe.KnotVector) -&gt; int:</code>
            <code><span class="kw">def</span> append(self, tail: PyGe.KnotVector, knotRatio: float) -&gt; int:</code>
            <code><span class="kw">def</span> append(*args) -&gt; int:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> contains(self, param: float) -&gt; bool:</code>
            <code><span class="kw">def</span> endParam(self) -&gt; float:</code>
            <code><span class="kw">def</span> getDistinctKnots(self) -&gt; list[float]:</code>
            <code><span class="kw">def</span> getInterval(self, ord: int, param: float) -&gt; tuple[int, PyGe.Interval]:</code>
            <code><span class="kw">def</span> growLength(self) -&gt; int:</code>
            <code><span class="kw">def</span> insert(self, u: float) -&gt; None:</code>
            <code><span class="kw">def</span> insertAt(self, idx: int, u: float, multiplicity: int) -&gt; None:</code>
            <code><span class="kw">def</span> isEmpty(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isEqualTo(self, other: PyGe.KnotVector) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(self, knot: float) -&gt; bool:</code>
            <code><span class="kw">def</span> length(self) -&gt; int:</code>
            <code><span class="kw">def</span> logicalLength(self) -&gt; int:</code>
            <code><span class="kw">def</span> multiplicityAt(self, idx: int) -&gt; int:</code>
            <code><span class="kw">def</span> multiplicityAtParam(self, param: float) -&gt; int:</code>
            <code><span class="kw">def</span> numIntervals(self) -&gt; int:</code>
            <code><span class="kw">def</span> physicalLength(self) -&gt; int:</code>
            <code><span class="kw">def</span> removeAt(self, idx: int) -&gt; None:</code>
            <code><span class="kw">def</span> removeSubVector(self, start: int, end: int) -&gt; None:</code>
            <code><span class="kw">def</span> reverse(self) -&gt; None:</code>
            <code><span class="kw">def</span> setGrowLength(self, length: int) -&gt; None:</code>
            <code><span class="kw">def</span> setLogicalLength(self, length: int) -&gt; None:</code>
            <code><span class="kw">def</span> setPhysicalLength(self, length: int) -&gt; None:</code>
            <code><span class="kw">def</span> setRange(self, lower: float, upper: float) -&gt; None:</code>
            <code><span class="kw">def</span> setTolerance(self, tol: float) -&gt; None:</code>
            <code><span class="kw">def</span> split(self, param: float, multilast: int, multifirst: int) -&gt; tuple[PyGe.KnotVector, PyGe.KnotVector]:</code>
            <code><span class="kw">def</span> startParam(self) -&gt; float:</code>
            <code><span class="kw">def</span> tolerance(self) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="Line2d">
        <details>
            <summary>class Line2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents an unbounded line in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, start: PyGe.Point3d, direction: PyGe.Vector2d) -&gt; None:
    <span class="ds">Represents an unbounded line in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, start: PyGe.Point3d, end: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents an unbounded line in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents an unbounded line in 2D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; Line2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; Line2d:</code>
            <code>kXAxis: PyGe.Line2d</code>
            <code>kYAxis: PyGe.Line2d</code>
            <code><span class="kw">def</span> set(self, start: PyGe.Point3d, direction: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, start: PyGe.Point3d, end: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Line3d">
        <details>
            <summary>class Line3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents an unbounded line in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point3d, endPoint: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents an unbounded line in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point3d, direction: PyGe.Vector3d) -&gt; None:
    <span class="ds">Represents an unbounded line in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents an unbounded line in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Line3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Line3d:</code>
            <code>kXAxis: PyGe.Line3d</code>
            <code>kYAxis: PyGe.Line3d</code>
            <code>kZAxis: PyGe.Line3d</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point3d, endPoint: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point3d, direction: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="LineSeg2d">
        <details>
            <summary>class LineSeg2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a bounded line segment in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, start: PyGe.Point3d, direction: PyGe.Vector2d) -&gt; None:
    <span class="ds">Represents a bounded line segment in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, start: PyGe.Point3d, end: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents a bounded line segment in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a bounded line segment in 2D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> baryComb(self, blendCoeff: float) -&gt; Point2d:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; LineSeg2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; LineSeg2d:</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> getBisector(self) -&gt; Line2d:</code>
            <code><span class="kw">def</span> length(self) -&gt; float:</code>
            <code><span class="kw">def</span> length(self, fromParam: float, toParam: float) -&gt; float:</code>
            <code><span class="kw">def</span> length(self, fromParam: float, toParam: float, tol: float) -&gt; float:</code>
            <code><span class="kw">def</span> length(*args) -&gt; float:</code>
            <code><span class="kw">def</span> midPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> set(self, start: PyGe.Point3d, direction: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, start: PyGe.Point3d, end: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, curve1: PyGe.Curve2d, curve2: PyGe.Curve2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, curve1: PyGe.Curve2d, pnt: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; Point2d:</code>
        </details>
    </div>

    <div class="class" id="LineSeg3d">
        <details>
            <summary>class LineSeg3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a bounded line segment in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point3d, endPoint: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents a bounded line segment in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point3d, direction: PyGe.Vector3d) -&gt; None:
    <span class="ds">Represents a bounded line segment in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a bounded line segment in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> baryComb(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; LineSeg3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; LineSeg3d:</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> getBisector(self) -&gt; Plane:</code>
            <code><span class="kw">def</span> length(self) -&gt; float:</code>
            <code><span class="kw">def</span> length(self, fromParam: float, toParam: float) -&gt; float:</code>
            <code><span class="kw">def</span> length(self, fromParam: float, toParam: float, tol: float) -&gt; float:</code>
            <code><span class="kw">def</span> length(*args) -&gt; float:</code>
            <code><span class="kw">def</span> midPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point3d, endPoint: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point3d, direction: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; Point3d:</code>
        </details>
    </div>

    <div class="class" id="LinearEnt2d">
        <details>
            <summary>class LinearEnt2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; LinearEnt2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; LinearEnt2d:</code>
            <code><span class="kw">def</span> direction(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> getLine(self) -&gt; Line2d:</code>
            <code><span class="kw">def</span> getPerpLine(self, pt: PyGe.Point2d) -&gt; Line2d:</code>
            <code><span class="kw">def</span> intersectWith(self, other: PyGe.LinearEnt2d, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Point2d]:</code>
            <code><span class="kw">def</span> isColinearTo(self, other: PyGe.LinearEnt2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isParallelTo(self, other: PyGe.LinearEnt2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isPerpendicularTo(self, other: PyGe.LinearEnt2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> overlap(self, other: PyGe.LinearEnt2d, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.LinearEnt2d]:</code>
            <code><span class="kw">def</span> pointOnLine(self) -&gt; Point2d:</code>
        </details>
    </div>

    <div class="class" id="LinearEnt3d">
        <details>
            <summary>class LinearEnt3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; LinearEnt3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; LinearEnt3d:</code>
            <code><span class="kw">def</span> direction(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> getLine(self) -&gt; Line3d:</code>
            <code><span class="kw">def</span> getPerpPlane(self, pt: PyGe.Point3d) -&gt; Plane:</code>
            <code><span class="kw">def</span> intersectWith(self, other: PyGe.LinearEnt3d | PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> isColinearTo(self, pt: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(self, pnt: PyGe.Point3d) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> isOn(self, pnt: PyGe.Point3d, tol: PyGe.Tol) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> isOn(self, param: float) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> isOn(self, param: float, tol: PyGe.Tol) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> isOn(self, plane: PyGe.Plane) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> isOn(self, plane: PyGe.Plane, tol: PyGe.Tol) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> isOn(*args) -&gt; tuple[bool, float]:</code>
            <code><span class="kw">def</span> isParallelTo(self, line: PyGe.LinearEnt3d) -&gt; bool:</code>
            <code><span class="kw">def</span> isParallelTo(self, line: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isParallelTo(self, line: PyGe.PlanarEnt) -&gt; bool:</code>
            <code><span class="kw">def</span> isParallelTo(self, line: PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isParallelTo(*args) -&gt; bool:</code>
            <code><span class="kw">def</span> isPerpendicularTo(self, line: PyGe.LinearEnt3d) -&gt; bool:</code>
            <code><span class="kw">def</span> isPerpendicularTo(self, line: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isPerpendicularTo(self, line: PyGe.PlanarEnt) -&gt; bool:</code>
            <code><span class="kw">def</span> isPerpendicularTo(self, line: PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isPerpendicularTo(*args) -&gt; bool:</code>
            <code><span class="kw">def</span> overlap(self, other: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.LinearEnt3d]:</code>
            <code><span class="kw">def</span> pointOnLine(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> projIntersectWith(self, other: PyGe.LinearEnt3d, projDir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Point3d, PyGe.Point3d]:</code>
        </details>
    </div>

    <div class="class" id="Matrix2d">
        <details>
            <summary>class Matrix2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __imul__(self, xform: PyGe.Matrix2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, entry: Collection[Collection[float]]) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:</code>
            <code><span class="kw">def</span> __mul__(self, xform: PyGe.Matrix2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> __ne__(self, other: PyGe.Matrix2d) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> alignCoordSys(fo: PyGe.Point2d, fe0: PyGe.Vector2d, fe1: PyGe.Vector2d, to: PyGe.Point2d, te0: PyGe.Vector2d, te1: PyGe.Vector2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> det(self) -&gt; float:</code>
            <code><span class="kw">def</span> elementAt(self, row: int, col: int) -&gt; float:</code>
            <code><span class="kw">def</span> fromCollection(entry: Collection[Collection[float]]) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> getCoordSystem(self, origin: PyGe.Point2d, e0: PyGe.Vector2d, e1: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> getTranslation(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> inverse(self) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> invert(self) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> isEqualTo(self, xform: PyGe.Matrix2d) -&gt; bool:</code>
            <code><span class="kw">def</span> isScaledOrtho(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isSingular(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isUniScaledOrtho(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code>kIdentity: PyGe.Matrix2d</code>
            <code><span class="kw">def</span> mirroring(pt: PyGe.Point2d | PyGe.Line2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> origin(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> postMultBy(self, xform: PyGe.Matrix2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> preMultBy(self, xform: PyGe.Matrix2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> rotation(val: float, pt: PyGe.Point2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> scale(self) -&gt; float:</code>
            <code><span class="kw">def</span> scale2d(self) -&gt; Scale2d:</code>
            <code><span class="kw">def</span> scaling(scaleAll: float, center: PyGe.Point2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setCoordSystem(self, origin: PyGe.Point2d, e0: PyGe.Vector2d, e1: PyGe.Vector2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setToAlignCoordSys(self, fo: PyGe.Point2d, fe0: PyGe.Vector2d, fe1: PyGe.Vector2d, to: PyGe.Point2d, te0: PyGe.Vector2d, te1: PyGe.Vector2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setToIdentity(self) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setToMirroring(self, pt: PyGe.Point2d | PyGe.Line2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setToProduct(self, xform1: PyGe.Matrix2d, xform2: PyGe.Matrix2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setToRotation(self, val: float, pt: PyGe.Point2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setToScaling(self, val: float, pt: PyGe.Point2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setToTranslation(self, vec: PyGe.Vector2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> setTranslation(self, vec: PyGe.Vector2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> toList(self) -&gt; list:</code>
            <code><span class="kw">def</span> toString(self) -&gt; str:</code>
            <code><span class="kw">def</span> toTuple(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> translation(vec: PyGe.Vector2d) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> transpose(self) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> transposeIt(self) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> xAxis(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> yAxis(self) -&gt; Vector2d:</code>
        </details>
    </div>

    <div class="class" id="Matrix3d">
        <details>
            <summary>class Matrix3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __imul__(self, xform: PyGe.Matrix3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, entry: Collection[Collection[float]]) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:</code>
            <code><span class="kw">def</span> __mul__(self, xform: PyGe.Matrix3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> __ne__(self, other: PyGe.Matrix3d) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> alignCoordSys(fromOrigin: PyGe.Point3d, fromXAxis: PyGe.Vector3d, fromYAxis: PyGe.Vector3d, fromZAxis: PyGe.Vector3d, toOrigin: PyGe.Point3d, toXAxis: PyGe.Vector3d, toYAxis: PyGe.Vector3d, toZAxis: PyGe.Vector3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> convertToLocal(self, normal: PyGe.Vector3d, elev: float) -&gt; Matrix2d:</code>
            <code><span class="kw">def</span> det(self) -&gt; float:</code>
            <code><span class="kw">def</span> elementAt(self, row: int, col: int) -&gt; float:</code>
            <code><span class="kw">def</span> fromCollection(entry: Collection[Collection[float]]) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> getCoordSystem(self, origin: PyGe.Point3d, x: PyGe.Vector3d, y: PyGe.Vector3d, z: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> getTranslation(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> inverse(self) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> inverse(self, tol: PyGe.Tol) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> inverse(self, xform: PyGe.Matrix3d, tol: float) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> inverse(*args) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> invert(self) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> isEqualTo(self, other: PyGe.Matrix3d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isScaledOrtho(self, val: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isSingular(self, val: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isUniScaledOrtho(self, val: PyGe.Tol) -&gt; bool:</code>
            <code>kIdentity: PyGe.Matrix3d</code>
            <code><span class="kw">def</span> mirroring(val: PyGe.Point3d | PyGe.Plane | PyGe.Line3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> norm(self) -&gt; float:</code>
            <code><span class="kw">def</span> origin(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> planeToWorld(val: PyGe.Vector3d | PyGe.Plane) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> postMultBy(self, val: PyGe.Matrix3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> preMultBy(self, val: PyGe.Matrix3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> projection(projectionPlane: PyGe.Plane, projectDir: PyGe.Vector3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> rotation(angle: float, axis: PyGe.Vector3d, center: PyGe.Point3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> scale(self) -&gt; float:</code>
            <code><span class="kw">def</span> scale3d(self) -&gt; Scale3d:</code>
            <code><span class="kw">def</span> scaling(val: float, center: PyGe.Point3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setCoordSystem(self, origin: PyGe.Point3d, x: PyGe.Vector3d, y: PyGe.Vector3d, z: PyGe.Vector3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setToAlignCoordSys(self, fromOrigin: PyGe.Point3d, fromXAxis: PyGe.Vector3d, fromYAxis: PyGe.Vector3d, fromZAxis: PyGe.Vector3d, toOrigin: PyGe.Point3d, toXAxis: PyGe.Vector3d, toYAxis: PyGe.Vector3d, toZAxis: PyGe.Vector3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setToIdentity(self) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setToMirroring(self, val: PyGe.Plane) -&gt; None:</code>
            <code><span class="kw">def</span> setToMirroring(self, val: PyGe.Line3d) -&gt; None:</code>
            <code><span class="kw">def</span> setToMirroring(self, val: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> setToMirroring(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setToPlaneToWorld(self, val: PyGe.Vector3d | PyGe.Plane) -&gt; None:</code>
            <code><span class="kw">def</span> setToProduct(self, mat1: PyGe.Matrix3d, mat2: PyGe.Matrix3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setToProjection(self, projectionPlane: PyGe.Plane, projectDir: PyGe.Vector3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setToRotation(self, angle: float, axis: PyGe.Vector3d, center: PyGe.Point3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setToScaling(self, val: float, center: PyGe.Point3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setToTranslation(self, val: PyGe.Vector3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> setToWorldToPlane(self, val: PyGe.Vector3d | PyGe.Plane) -&gt; None:</code>
            <code><span class="kw">def</span> setTranslation(self, val: PyGe.Vector2d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> toList(self) -&gt; list:</code>
            <code><span class="kw">def</span> toString(self) -&gt; str:</code>
            <code><span class="kw">def</span> toTuple(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> translation(val: PyGe.Vector3d) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> transpose(self) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> transposeIt(self) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> worldToPlane(val: PyGe.Vector3d | PyGe.Plane) -&gt; Matrix3d:</code>
            <code><span class="kw">def</span> xAxis(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> yAxis(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> zAxis(self) -&gt; Vector3d:</code>
        </details>
    </div>

    <div class="class" id="NurbCurve2d">
        <details>
            <summary>class NurbCurve2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, src: PyGe.Curve2d) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, src: PyGe.LineSeg2d) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, src: PyGe.EllipArc2d) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve2d, epsilon: float) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPnts: list[PyGe.Point2d], tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, degree: int, fitPolyline: PyGe.Polyline2d, isPeriodic: bool) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, degree: int, knots: PyGe.KnotVector, cntrlPnts: list[PyGe.Point2d], isPeriodic: bool) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPoints: list[PyGe.Point2d], fitTangents: list[PyGe.Vector2d], fitTolerance: PyGe.Tol, isPeriodic: bool) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPoints: list[PyGe.Point2d], startTangent: PyGe.Vector2d, endTangent: PyGe.Vector2d, startTangentDefined: bool, endTangentDefined: bool, fitTolerance: PyGe.Tol) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPoints: list[PyGe.Point2d], startTangent: PyGe.Vector2d, endTangent: PyGe.Vector2d, startTangentDefined: bool, endTangentDefined: bool, knotParam: PyGe.KnotParameterization, fitTolerance: PyGe.Tol) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 2D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> addControlPointAt(self, newKnot: float, pt: PyGe.Point2d, weight: float) -&gt; bool:</code>
            <code><span class="kw">def</span> addFitPointAt(self, idx: int, pt: PyGe.Point2d) -&gt; bool:</code>
            <code><span class="kw">def</span> addKnot(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> buildFitData(self, val: PyGe.KnotParameterization) -&gt; bool:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; NurbCurve2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; NurbCurve2d:</code>
            <code><span class="kw">def</span> deleteControlPointAt(self, val: int) -&gt; bool:</code>
            <code><span class="kw">def</span> deleteFitPointAt(self, idx: int) -&gt; bool:</code>
            <code><span class="kw">def</span> elevateDegree(self, val: int) -&gt; None:</code>
            <code><span class="kw">def</span> evalMode(self) -&gt; bool:</code>
            <code><span class="kw">def</span> getDefinitionData(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> getFitData(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> getFitPointAt(self, idx: int) -&gt; tuple[bool, PyGe.Point2d]:</code>
            <code><span class="kw">def</span> getFitTangents(self) -&gt; tuple[bool, PyGe.Vector2d, PyGe.Vector2d]:</code>
            <code><span class="kw">def</span> getFitTolerance(self) -&gt; tuple[bool, PyGe.Tol]:</code>
            <code><span class="kw">def</span> getParamsOfC1Discontinuity(self, tol: PyGe.Tol) -&gt; tuple[bool, list[float]]:</code>
            <code><span class="kw">def</span> getParamsOfG1Discontinuity(self, tol: PyGe.Tol) -&gt; tuple[bool, list[float]]:</code>
            <code><span class="kw">def</span> hardTrimByParams(self, newStartParam: float, newEndParam: float) -&gt; None:</code>
            <code><span class="kw">def</span> insertKnot(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> joinWith(self, val: PyGe.NurbCurve2d) -&gt; None:</code>
            <code><span class="kw">def</span> makeClosed(self) -&gt; None:</code>
            <code><span class="kw">def</span> makeNonPeriodic(self) -&gt; None:</code>
            <code><span class="kw">def</span> makeOpen(self) -&gt; None:</code>
            <code><span class="kw">def</span> makePeriodic(self) -&gt; None:</code>
            <code><span class="kw">def</span> makeRational(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> numFitPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> numWeights(self) -&gt; int:</code>
            <code><span class="kw">def</span> purgeFitData(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setEvalMode(self, val: bool) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(self, degree: int, fitPoints: list[PyGe.Point2d], fitTolerance: PyGe.Tol) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(self, fitPoints: list[PyGe.Point2d], startTangent: PyGe.Vector2d, endTangent: PyGe.Vector2d, fitTolerance: PyGe.Tol) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(self, fitPoints: list[PyGe.Point2d], startTangent: PyGe.Vector2d, endTangent: PyGe.Vector2d, knotParam: PyGe.KnotParameterization, fitTolerance: PyGe.Tol) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(self, knots: PyGe.KnotVector, fitPoints: list[PyGe.Point2d], startTangent: PyGe.Vector2d, endTangent: PyGe.Vector2d, fitTolerance: PyGe.Tol, isPeriodic: bool) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setFitKnotParameterization(self, val: PyGe.KnotParameterization) -&gt; bool:</code>
            <code><span class="kw">def</span> setFitPointAt(self, idx: int, pt: PyGe.Point2d) -&gt; bool:</code>
            <code><span class="kw">def</span> setFitTangents(self, startTangent: PyGe.Vector2d, endTangent: PyGe.Vector2d) -&gt; bool:</code>
            <code><span class="kw">def</span> setFitTolerance(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> setWeightAt(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> weightAt(self, idx: int) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="NurbCurve3d">
        <details>
            <summary>class NurbCurve3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, src: PyGe.Curve3d) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, src: PyGe.LineSeg3d) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, src: PyGe.EllipArc3d) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve3d, epsilon: float) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPnts: list[PyGe.Point3d], tol: PyGe.Tol) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, degree: int, fitPolyline: PyGe.Polyline3d, isPeriodic: bool) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, degree: int, knots: PyGe.KnotVector, cntrlPnts: list[PyGe.Point3d], isPeriodic: bool) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPoints: list[PyGe.Point3d], fitTangents: list[PyGe.Vector3d], fitTolerance: PyGe.Tol, isPeriodic: bool) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPoints: list[PyGe.Point3d], startTangent: PyGe.Vector3d, endTangent: PyGe.Vector3d, startTangentDefined: bool, endTangentDefined: bool, fitTolerance: PyGe.Tol) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, fitPoints: list[PyGe.Point3d], startTangent: PyGe.Vector3d, endTangent: PyGe.Vector3d, startTangentDefined: bool, endTangentDefined: bool, knotParam: PyGe.KnotParameterization, fitTolerance: PyGe.Tol) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents non-uniform rational B-spline in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> addControlPointAt(self, newKnot: float, pt: PyGe.Point3d, weight: float) -&gt; bool:</code>
            <code><span class="kw">def</span> addFitPointAt(self, idx: int, pt: PyGe.Point3d) -&gt; bool:</code>
            <code><span class="kw">def</span> addKnot(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> buildFitData(self, val: PyGe.KnotParameterization) -&gt; bool:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; NurbCurve3d:</code>
            <code><span class="kw">def</span> className(otherObject: PyGe.Entity3d) -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; NurbCurve3d:</code>
            <code><span class="kw">def</span> deleteControlPointAt(self, idx: int) -&gt; bool:</code>
            <code><span class="kw">def</span> deleteFitPointAt(self, idx: int) -&gt; bool:</code>
            <code><span class="kw">def</span> elevateDegree(self, val: int) -&gt; None:</code>
            <code><span class="kw">def</span> evalMode(self) -&gt; bool:</code>
            <code><span class="kw">def</span> getDefinitionData(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> getFitData(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> getFitPointAt(self, idx: int) -&gt; tuple[bool, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> getFitTangents(self) -&gt; tuple[bool, PyGe.Vector3d, PyGe.Vector3d, bool, bool]:</code>
            <code><span class="kw">def</span> getFitTolerance(self) -&gt; tuple[bool, PyGe.Tol]:</code>
            <code><span class="kw">def</span> getParamsOfC1Discontinuity(self, tol: PyGe.Tol) -&gt; tuple[bool, list[float]]:</code>
            <code><span class="kw">def</span> getParamsOfG1Discontinuity(self, tol: PyGe.Tol) -&gt; tuple[bool, list[float]]:</code>
            <code><span class="kw">def</span> hardTrimByParams(self, newStartParam: float, newEndParam: float) -&gt; None:</code>
            <code><span class="kw">def</span> insertKnot(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> joinWith(self, val: PyGe.NurbCurve3d) -&gt; None:</code>
            <code><span class="kw">def</span> makeClosed(self) -&gt; None:</code>
            <code><span class="kw">def</span> makeNonPeriodic(self) -&gt; None:</code>
            <code><span class="kw">def</span> makeOpen(self) -&gt; None:</code>
            <code><span class="kw">def</span> makePeriodic(self) -&gt; None:</code>
            <code><span class="kw">def</span> makeRational(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> numFitPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> numWeights(self) -&gt; int:</code>
            <code><span class="kw">def</span> purgeFitData(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setEvalMode(self, val: bool) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(self, degree: int, fitPoints: list[PyGe.Point3d], fitTolerance: PyGe.Tol) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(self, fitPoints: list[PyGe.Point3d], startTangent: PyGe.Vector3d, endTangent: PyGe.Vector3d, fitTolerance: PyGe.Tol) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(self, fitPoints: list[PyGe.Point3d], startTangent: PyGe.Vector3d, endTangent: PyGe.Vector3d, knotParam: PyGe.KnotParameterization, fitTolerance: PyGe.Tol) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(self, knots: PyGe.KnotVector, fitPoints: list[PyGe.Point3d], startTangent: PyGe.Vector3d, endTangent: PyGe.Vector3d, fitTolerance: PyGe.Tol, isPeriodic: bool) -&gt; None:</code>
            <code><span class="kw">def</span> setFitData(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setFitKnotParameterization(self, val: PyGe.KnotParameterization) -&gt; bool:</code>
            <code><span class="kw">def</span> setFitPointAt(self, idx: int, pt: PyGe.Point3d) -&gt; bool:</code>
            <code><span class="kw">def</span> setFitTangents(self, startTangent: PyGe.Vector3d, endTangent: PyGe.Vector3d) -&gt; bool:</code>
            <code><span class="kw">def</span> setFitTangents(self, startTangent: PyGe.Vector3d, endTangent: PyGe.Vector3d, startTangentDefined: bool, endTangentDefined: bool) -&gt; bool:</code>
            <code><span class="kw">def</span> setFitTangents(*args) -&gt; bool:</code>
            <code><span class="kw">def</span> setFitTolerance(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> setWeightAt(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> weightAt(self, idx: int) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="NurbSurface">
        <details>
            <summary>class NurbSurface <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents generic NURB parametric surface.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; NurbSurface:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; NurbSurface:</code>
        </details>
    </div>

    <div class="class" id="OffsetCrvExtType">
        <details>
            <summary>class OffsetCrvExtType <span class="tag">Class</span></summary>
            <code>kFillet: ClassVar[Self]</code>
            <code>kChamfer: ClassVar[Self]</code>
            <code>kExtend: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="OffsetCurve2d">
        <details>
            <summary>class OffsetCurve2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, baseCurve: PyGe.Curve2d, offsetDistance: float) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; OffsetCurve2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; OffsetCurve2d:</code>
        </details>
    </div>

    <div class="class" id="OffsetCurve3d">
        <details>
            <summary>class OffsetCurve3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, baseCurve: PyGe.Curve3d, planeNormal: PyGe.Vector3d, offsetDistance: float) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; OffsetCurve3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; OffsetCurve3d:</code>
            <code><span class="kw">def</span> curve(self) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> normal(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> offsetDistance(self) -&gt; float:</code>
            <code><span class="kw">def</span> paramDirection(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setCurve(self, val: PyGe.Curve3d) -&gt; None:</code>
            <code><span class="kw">def</span> setNormal(self, normal: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> setOffsetDistance(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> transformation(self) -&gt; Matrix3d:</code>
        </details>
    </div>

    <div class="class" id="OffsetSurface">
        <details>
            <summary>class OffsetSurface <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents an offset object.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; OffsetSurface:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; OffsetSurface:</code>
        </details>
    </div>

    <div class="class" id="PlanarEnt">
        <details>
            <summary>class PlanarEnt <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; PlanarEnt:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> closestPointToLinearEnt(self, other: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; tuple[PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> closestPointToPlanarEnt(self, other: PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; tuple[PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; PlanarEnt:</code>
            <code><span class="kw">def</span> getCoefficients(self) -&gt; tuple[float, float, float, float]:</code>
            <code><span class="kw">def</span> getCoordSystem(self) -&gt; tuple[PyGe.Point3d, PyGe.Vector3d, PyGe.Vector3d]:</code>
            <code><span class="kw">def</span> intersectWith(self, other: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> isCoplanarTo(self, other: PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isParallelTo(self, other: PyGe.LinearEnt3d | PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isPerpendicularTo(self, other: PyGe.LinearEnt3d | PyGe.PlanarEnt, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> normal(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> pointOnPlane(self) -&gt; Point3d:</code>
        </details>
    </div>

    <div class="class" id="Plane">
        <details>
            <summary>class Plane <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Class AcGePlane represents a parameterized infinite plane in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, origin: PyGe.Point3d, normal: PyGe.Vector3d) -&gt; None:
    <span class="ds">Class AcGePlane represents a parameterized infinite plane in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, origin: PyGe.Point3d, uAxis: PyGe.Vector3d, vAxis: PyGe.Vector3d) -&gt; None:
    <span class="ds">Class AcGePlane represents a parameterized infinite plane in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, pntU: PyGe.Point3d, origin: PyGe.Point3d, pntV: PyGe.Point3d) -&gt; None:
    <span class="ds">Class AcGePlane represents a parameterized infinite plane in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, a: float, b: float, c: float, d: float) -&gt; None:
    <span class="ds">Class AcGePlane represents a parameterized infinite plane in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Class AcGePlane represents a parameterized infinite plane in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Plane:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Plane:</code>
            <code><span class="kw">def</span> intersectWith(self, val: PyGe.LinearEnt3d | PyGe.Plane | PyGe.BoundedPlane, tol: PyGe.Tol) -&gt; tuple[bool, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> set(self, origin: PyGe.Point3d, normal: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, origin: PyGe.Point3d, uAxis: PyGe.Vector3d, vAxis: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, pntU: PyGe.Point3d, origin: PyGe.Point3d, pntV: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, a: float, b: float, c: float, d: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> signedDistanceTo(self, pt: PyGe.Point3d) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="Point2d">
        <details>
            <summary>class Point2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __add__(self, vec: PyGe.Vector2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> __getinitargs__(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> __getitem__(self, idx: int) -&gt; float:</code>
            <code><span class="kw">def</span> __hash__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __iadd__(self, vec: PyGe.Vector2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> __imul__(self, val: float) -&gt; Point2d:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, x: float, y: float) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:</code>
            <code><span class="kw">def</span> __isub__(self, vec: PyGe.Vector2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> __itruediv__(self, val: float) -&gt; Point2d:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __mul__(self, val: float) -&gt; Point2d:</code>
            <code><span class="kw">def</span> __ne__(self, other: PyGe.Point2d) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __setitem__(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> __sub__(self, other: PyGe.Point2d | PyGe.Vector2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> __truediv__(self, val: float) -&gt; Point2d:</code>
            <code><span class="kw">def</span> asVector(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> distanceTo(self, pt: PyGe.Point2d) -&gt; float:</code>
            <code><span class="kw">def</span> isEqualTo(self, pt: PyGe.Point2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code>kOrigin: PyGe.Point2d</code>
            <code><span class="kw">def</span> mirror(self, pt: PyGe.Line2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> rotateBy(self, val: float, pt: PyGe.Point2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> scaleBy(self, val: float, pt: PyGe.Point2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> set(self, xx: float, yy: float) -&gt; Point2d:</code>
            <code><span class="kw">def</span> setToProduct(self, mat: PyGe.Matrix2d, pt: PyGe.Point2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> setToSum(self, pt: PyGe.Point2d, vec: PyGe.Vector2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> to3d(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> toList(self) -&gt; list[float]:</code>
            <code><span class="kw">def</span> toString(self) -&gt; str:</code>
            <code><span class="kw">def</span> toTuple(self) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> transformBy(self, xform: PyGe.Matrix2d) -&gt; Point2d:</code>
            <code><span class="kw">def</span> x(self) -&gt; float:</code>
            <code><span class="kw">def</span> y(self) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="Point2dArray">
        <details>
            <summary>class Point2dArray <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __contains__(self) -&gt; bool:</code>
            <code><span class="kw">def</span> __delitem__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __getitem__(self) -&gt; object:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __iter__(self) -&gt; object:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __setitem__(self) -&gt; None:</code>
            <code><span class="kw">def</span> append(self) -&gt; None:</code>
            <code><span class="kw">def</span> convexHull(self) -&gt; Point2dArray:</code>
            <code><span class="kw">def</span> convexHullIndexes(self) -&gt; list:</code>
            <code><span class="kw">def</span> extend(self) -&gt; None:</code>
            <code><span class="kw">def</span> sortByDistFrom(self, basePnt: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> sortByX(self) -&gt; None:</code>
            <code><span class="kw">def</span> sortByY(self) -&gt; None:</code>
            <code><span class="kw">def</span> to3d(self) -&gt; Point3dArray:</code>
            <code><span class="kw">def</span> transformBy(self, mat: PyGe.Matrix2d) -&gt; None:
    <span class="ds">Transform this pre-multiplying it the matrix leftSide. Returns the reference to this point.
Result is the same as setToProduct(leftSide, *this).</span></code>
        </details>
    </div>

    <div class="class" id="Point2dTree">
        <details>
            <summary>class Point2dTree <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, points: Collection[PyGe.Point2d]) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> inputPoints(self) -&gt; Point2dArray:</code>
            <code><span class="kw">def</span> knnSearch(self, point: PyGe.Point2d, num_closest: int) -&gt; tuple:</code>
            <code><span class="kw">def</span> radiusSearch(self, point: PyGe.Point2d, radius: float) -&gt; tuple:</code>
        </details>
    </div>

    <div class="class" id="Point3d">
        <details>
            <summary>class Point3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __add__(self, vec: PyGe.Vector3d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> __getinitargs__(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> __getitem__(self, idx: int) -&gt; float:</code>
            <code><span class="kw">def</span> __hash__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __iadd__(self, vec: PyGe.Vector3d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> __imul__(self, val: float) -&gt; Point3d:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, floats: tuple[float] | list[float]) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, x: float, y: float, z: float) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, pln: PyGe.PlanarEnt, pnt2d: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:</code>
            <code><span class="kw">def</span> __isub__(self, vec: PyGe.Vector3d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> __itruediv__(self, val: float) -&gt; Point3d:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __mul__(self, val: float) -&gt; Point3d:</code>
            <code><span class="kw">def</span> __ne__(self, pt: PyGe.Point3d) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __rmul__(self, val: float | PyGe.Matrix3d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> __setitem__(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> __sub__(self, val: PyGe.Vector3d | PyGe.Point3d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __truediv__(self, val: float) -&gt; Point3d:</code>
            <code><span class="kw">def</span> asVector(self) -&gt; Vector3d:
    <span class="ds">Converts 3D point into 3D vector with the same set of coordinates ( see AcGeVector3d ).
Return value is a class AcGeVector3d.</span></code>
            <code><span class="kw">def</span> convert2d(self, pln: PyGe.PlanarEnt) -&gt; Point2d:
    <span class="ds">Returns 2D point with the coordinates corresponding to the decomposition of the vector
*this - p in the basis uAxis, vAxis in the planar entity, where p, uAxis, and vAxis can
found by function call pln.get(p, uAxis, vAxis). Contract: This 3D point assumed to be on
the planar entity pln.</span></code>
            <code><span class="kw">def</span> distanceTo(self, pnt: PyGe.Point3d) -&gt; float:
    <span class="ds">Evaluates and returns distance from this point to the point pnt.</span></code>
            <code><span class="kw">def</span> isEqualTo(self, pnt: PyGe.Point3d, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Checks if this point is within the distance tol.equalPoint() from the point pnt. The
default value of the tolerance class tol is AcGeContext::gTol. Returns Adesk::kTrue if this
condition is met and Adesk::kFalse otherwise.</span></code>
            <code>kOrigin: PyGe.Point3d</code>
            <code><span class="kw">def</span> mirror(self, pln: PyGe.Plane) -&gt; Point3d:
    <span class="ds">Returns the 3D point that is the result of mirroring of this point with respect to the
plane pln.</span></code>
            <code><span class="kw">def</span> orthoProject(self, pln: PyGe.Plane) -&gt; Point3d:
    <span class="ds">Returns 3D point that is the result of the orthogonal projection of this point into the
plane pln.</span></code>
            <code><span class="kw">def</span> project(self, pln: PyGe.Plane, vec: PyGe.Vector3d) -&gt; Point3d:
    <span class="ds">Returns 3D point that is the result of the parallel projection of this point into the plane
pln. The direction of projection is defined by vector vec.</span></code>
            <code><span class="kw">def</span> rotateBy(self, angle: float, vec: PyGe.Vector3d, wrtPoint: PyGe.Point3d) -&gt; Point3d:
    <span class="ds">Returns 3D point that is the result of rotation of this point around the line with
direction vector vec passing through the point wrtPoint. Rotation angle is given by the
argument angle, where positive direction of rotation is defined by the right-hand rule.</span></code>
            <code><span class="kw">def</span> scaleBy(self, factor: float, pnt: PyGe.Point3d) -&gt; Point3d:
    <span class="ds">Returns 3D point that is the result of scaling of this point with respect to the 3D point
wrtPoint by scale factor scaleFactor.</span></code>
            <code><span class="kw">def</span> set(self, x: float, y: float, z: float) -&gt; Point3d:</code>
            <code><span class="kw">def</span> set(self, pl: PyGe.PlanarEnt, pt2d: PyGe.Point2d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> set(*args) -&gt; Point3d:</code>
            <code><span class="kw">def</span> setToProduct(self, mat: PyGe.Matrix3d, pnt: PyGe.Point3d) -&gt; Point3d:
    <span class="ds">Sets this point to the product of matrix mat and point pnt. The order of multiplication is
mat*pnt, where points are considered as columns. Returns the reference to this point.</span></code>
            <code><span class="kw">def</span> setToSum(self, pnt: PyGe.Point3d, vec: PyGe.Vector3d) -&gt; Point3d:
    <span class="ds">Sets this point to the sum of the pnt and vector vec. Returns the reference to this point.</span></code>
            <code><span class="kw">def</span> to2d(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> toList(self) -&gt; list[float]:</code>
            <code><span class="kw">def</span> toString(self) -&gt; str:</code>
            <code><span class="kw">def</span> toTuple(self) -&gt; tuple[float, float, float]:</code>
            <code><span class="kw">def</span> transformBy(self, mat: PyGe.Matrix3d) -&gt; Point3d:
    <span class="ds">Transform this pre-multiplying it the matrix leftSide. Returns the reference to this point.
Result is the same as setToProduct(leftSide, *this).</span></code>
            <code><span class="kw">def</span> x(self) -&gt; float:</code>
            <code><span class="kw">def</span> y(self) -&gt; float:</code>
            <code><span class="kw">def</span> z(self) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="Point3dArray">
        <details>
            <summary>class Point3dArray <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __contains__(self) -&gt; bool:</code>
            <code><span class="kw">def</span> __delitem__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __getitem__(self) -&gt; object:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __iter__(self) -&gt; object:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __setitem__(self) -&gt; None:</code>
            <code><span class="kw">def</span> append(self) -&gt; None:</code>
            <code><span class="kw">def</span> convexHull(self) -&gt; Point3dArray:</code>
            <code><span class="kw">def</span> convexHullIndexes(self) -&gt; list:</code>
            <code><span class="kw">def</span> extend(self) -&gt; None:</code>
            <code><span class="kw">def</span> isPlanar(self) -&gt; tuple[bool, PyGe.Plane]:</code>
            <code><span class="kw">def</span> sortByDistFrom(self, basePnt: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> sortByX(self) -&gt; None:</code>
            <code><span class="kw">def</span> sortByY(self) -&gt; None:</code>
            <code><span class="kw">def</span> sortByZ(self) -&gt; None:</code>
            <code><span class="kw">def</span> to2d(self) -&gt; Point2dArray:</code>
            <code><span class="kw">def</span> transformBy(self, mat: PyGe.Matrix3d) -&gt; None:
    <span class="ds">Transform this pre-multiplying it the matrix leftSide. Returns the reference to this point.
Result is the same as setToProduct(leftSide, *this).</span></code>
        </details>
    </div>

    <div class="class" id="Point3dTree">
        <details>
            <summary>class Point3dTree <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, points: Collection[PyGe.Point3d]) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> inputPoints(self) -&gt; Point3dArray:</code>
            <code><span class="kw">def</span> knnSearch(self, point: PyGe.Point3d, num_closest: int) -&gt; tuple:</code>
            <code><span class="kw">def</span> radiusSearch(self, point: PyGe.Point3d, radius: float) -&gt; tuple:</code>
        </details>
    </div>

    <div class="class" id="PointContainment">
        <details>
            <summary>class PointContainment <span class="tag">Class</span></summary>
            <code>kInside: ClassVar[Self]</code>
            <code>kOutside: ClassVar[Self]</code>
            <code>kOnBoundary: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="PointEnt2d">
        <details>
            <summary>class PointEnt2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; PointEnt2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; PointEnt2d:</code>
            <code><span class="kw">def</span> point2d(self) -&gt; Point2d:</code>
        </details>
    </div>

    <div class="class" id="PointEnt3d">
        <details>
            <summary>class PointEnt3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; PointEnt3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; PointEnt3d:</code>
            <code><span class="kw">def</span> point3d(self) -&gt; Point3d:</code>
        </details>
    </div>

    <div class="class" id="PointOnCurve2d">
        <details>
            <summary>class PointOnCurve2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a point on a 2D parametric curve. This class encapsulates all of the geometric
information of a point on a 2D curve, including its parameter value, 2D coordinates, and
derivatives.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve2d) -&gt; None:
    <span class="ds">Represents a point on a 2D parametric curve. This class encapsulates all of the geometric
information of a point on a 2D curve, including its parameter value, 2D coordinates, and
derivatives.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve2d, param: float) -&gt; None:
    <span class="ds">Represents a point on a 2D parametric curve. This class encapsulates all of the geometric
information of a point on a 2D curve, including its parameter value, 2D coordinates, and
derivatives.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a point on a 2D parametric curve. This class encapsulates all of the geometric
information of a point on a 2D curve, including its parameter value, 2D coordinates, and
derivatives.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; PointEnt2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; PointOnCurve2d:</code>
            <code><span class="kw">def</span> curve(self) -&gt; Curve2d:</code>
            <code><span class="kw">def</span> deriv(self, order: int) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> deriv(self, order: int, param: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> deriv(self, order: int, curve: PyGe.Curve2d, param: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> deriv(*args) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> parameter(self) -&gt; float:</code>
            <code><span class="kw">def</span> point(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> point(self, param: float) -&gt; Point2d:</code>
            <code><span class="kw">def</span> point(self, curve: PyGe.Curve2d, param: float) -&gt; Point2d:</code>
            <code><span class="kw">def</span> point(*args) -&gt; Point2d:</code>
            <code><span class="kw">def</span> setCurve(self, val: PyGe.Curve2d) -&gt; None:</code>
            <code><span class="kw">def</span> setParameter(self, val: float) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="PointOnCurve3d">
        <details>
            <summary>class PointOnCurve3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a point on a 3D parametric curve. This class encapsulates all of the geometric
information of a point on a 3D curve including its parameter value, 3D coordinates, and
derivatives.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve3d) -&gt; None:
    <span class="ds">Represents a point on a 3D parametric curve. This class encapsulates all of the geometric
information of a point on a 3D curve including its parameter value, 3D coordinates, and
derivatives.</span></code>
            <code><span class="kw">def</span> __init__(self, curve: PyGe.Curve3d, param: float) -&gt; None:
    <span class="ds">Represents a point on a 3D parametric curve. This class encapsulates all of the geometric
information of a point on a 3D curve including its parameter value, 3D coordinates, and
derivatives.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a point on a 3D parametric curve. This class encapsulates all of the geometric
information of a point on a 3D curve including its parameter value, 3D coordinates, and
derivatives.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; PointOnCurve3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; PointOnCurve3d:</code>
            <code><span class="kw">def</span> curvature(self, param: float) -&gt; float:</code>
            <code><span class="kw">def</span> curve(self) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> deriv(self, order: int) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> deriv(self, order: int, param: float) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> deriv(self, order: int, curve: PyGe.Curve3d, param: float) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> deriv(*args) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> isSingular(self) -&gt; bool:</code>
            <code><span class="kw">def</span> parameter(self) -&gt; float:</code>
            <code><span class="kw">def</span> point(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> point(self, param: float) -&gt; Point3d:</code>
            <code><span class="kw">def</span> point(self, curve: PyGe.Curve3d, param: float) -&gt; Point3d:</code>
            <code><span class="kw">def</span> point(*args) -&gt; Point3d:</code>
            <code><span class="kw">def</span> setCurve(self, curve: PyGe.Curve3d) -&gt; None:</code>
            <code><span class="kw">def</span> setParameter(self, param: float) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="PointOnSurface">
        <details>
            <summary>class PointOnSurface <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a point on a surface. This class encapsulates all of the geometric information
of a point on a surface, including its parameter value, 3D coordinates, derivatives, and
normal vector.</span></code>
            <code><span class="kw">def</span> __init__(self, surface: PyGe.Surface) -&gt; None:
    <span class="ds">Represents a point on a surface. This class encapsulates all of the geometric information
of a point on a surface, including its parameter value, 3D coordinates, derivatives, and
normal vector.</span></code>
            <code><span class="kw">def</span> __init__(self, surface: PyGe.Surface, pnt: PyGe.Point2d) -&gt; None:
    <span class="ds">Represents a point on a surface. This class encapsulates all of the geometric information
of a point on a surface, including its parameter value, 3D coordinates, derivatives, and
normal vector.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a point on a surface. This class encapsulates all of the geometric information
of a point on a surface, including its parameter value, 3D coordinates, derivatives, and
normal vector.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; PointOnSurface:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; PointOnSurface:</code>
            <code><span class="kw">def</span> inverseTangentVector(self, vec: PyGe.Vector2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> inverseTangentVector(self, vec: PyGe.Vector2d, param: PyGe.Vector2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> inverseTangentVector(self, vec: PyGe.Vector2d, surface: PyGe.Surface, param: PyGe.Vector2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> inverseTangentVector(*args) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> mixedPartial(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> mixedPartial(self, param: PyGe.Point2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> mixedPartial(self, surface: PyGe.Surface, param: PyGe.Point2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> mixedPartial(*args) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> normal(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> normal(self, param: PyGe.Point2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> normal(self, surface: PyGe.Surface, param: PyGe.Point2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> normal(*args) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> parameter(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> point(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> point(self, param: PyGe.Point2d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> point(self, surface: PyGe.Surface, param: PyGe.Point2d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> point(*args) -&gt; Point3d:</code>
            <code><span class="kw">def</span> setParameter(self, param: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> setSurface(self, val: PyGe.Surface) -&gt; None:</code>
            <code><span class="kw">def</span> surface(self) -&gt; PyGe.Surface:</code>
            <code><span class="kw">def</span> tangentVector(self, vec: PyGe.Vector2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> tangentVector(self, vec: PyGe.Vector2d, param: PyGe.Vector2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> tangentVector(self, vec: PyGe.Vector2d, surface: PyGe.Surface, param: PyGe.Vector2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> tangentVector(*args) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> uDeriv(self, order: int) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> uDeriv(self, order: int, param: PyGe.Point2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> uDeriv(self, order: int, surface: PyGe.Surface, param: PyGe.Point2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> uDeriv(*args) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> vDeriv(self, order: int) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> vDeriv(self, order: int, param: PyGe.Point2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> vDeriv(self, order: int, surface: PyGe.Surface, param: PyGe.Point2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> vDeriv(*args) -&gt; Vector3d:</code>
        </details>
    </div>

    <div class="class" id="Polyline2d">
        <details>
            <summary>class Polyline2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, points: list[PyGe.Point2d]) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, knots: PyGe.KnotVector, points: list[PyGe.Point2d]) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, crv: PyGe.Curve2d, apprEps: float) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 2D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; Polyline2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; Polyline2d:</code>
            <code><span class="kw">def</span> fitPointAt(self, idx: int) -&gt; Point2d:</code>
            <code><span class="kw">def</span> numFitPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> setFitPointAt(self, idx: int, pt: PyGe.Point2d) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Polyline3d">
        <details>
            <summary>class Polyline3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, points: list[PyGe.Point3d]) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, knots: PyGe.KnotVector, points: list[PyGe.Point3d]) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, crv: PyGe.Curve3d, apprEps: float) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a piecewise linear spline entity in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Polyline3d:</code>
            <code><span class="kw">def</span> className(otherObject: PyGe.Entity3d) -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Polyline3d:</code>
            <code><span class="kw">def</span> fitPointAt(self, idx: int) -&gt; Point3d:</code>
            <code><span class="kw">def</span> numFitPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> setFitPointAt(self, idx: int, pt: PyGe.Point3d) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Position2d">
        <details>
            <summary>class Position2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a point in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, pnt: PyGe.Point2d) -&gt; None:
    <span class="ds">Represents a point in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(self, x: float, y: float) -&gt; None:
    <span class="ds">Represents a point in 2D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a point in 2D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; Position2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; Position2d:</code>
            <code><span class="kw">def</span> set(self, pnt: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, x: float, y: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Position3d">
        <details>
            <summary>class Position3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a point in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, pnt: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents a point in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(self, x: float, y: float, z: float) -&gt; None:
    <span class="ds">Represents a point in 3D space.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a point in 3D space.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Position3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Position3d:</code>
            <code><span class="kw">def</span> set(self, pnt: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, x: float, y: float, z: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Ray2d">
        <details>
            <summary>class Ray2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a half-bounded line in 2D space. An AcGeRay2d object either has a start point
but no endpoint, or has an endpoint but no start point.</span></code>
            <code><span class="kw">def</span> __init__(self, start: PyGe.Point3d, direction: PyGe.Vector2d) -&gt; None:
    <span class="ds">Represents a half-bounded line in 2D space. An AcGeRay2d object either has a start point
but no endpoint, or has an endpoint but no start point.</span></code>
            <code><span class="kw">def</span> __init__(self, start: PyGe.Point3d, end: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents a half-bounded line in 2D space. An AcGeRay2d object either has a start point
but no endpoint, or has an endpoint but no start point.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a half-bounded line in 2D space. An AcGeRay2d object either has a start point
but no endpoint, or has an endpoint but no start point.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; Ray2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; Ray2d:</code>
            <code><span class="kw">def</span> set(self, start: PyGe.Point3d, direction: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, start: PyGe.Point3d, end: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Ray3d">
        <details>
            <summary>class Ray3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a half-bounded line in 3D space. An AcGeRay3 object either has a start point but
no endpoint, or has an endpoint but no start point.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point3d, endPoint: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents a half-bounded line in 3D space. An AcGeRay3 object either has a start point but
no endpoint, or has an endpoint but no start point.</span></code>
            <code><span class="kw">def</span> __init__(self, startPoint: PyGe.Point3d, direction: PyGe.Vector3d) -&gt; None:
    <span class="ds">Represents a half-bounded line in 3D space. An AcGeRay3 object either has a start point but
no endpoint, or has an endpoint but no start point.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a half-bounded line in 3D space. An AcGeRay3 object either has a start point but
no endpoint, or has an endpoint but no start point.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Ray3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Ray3d:</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point3d, endPoint: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, startPoint: PyGe.Point3d, direction: PyGe.Vector3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Scale2d">
        <details>
            <summary>class Scale2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __getitem__(self, idx: int) -&gt; float:</code>
            <code><span class="kw">def</span> __imul__(self, val: float) -&gt; Scale2d:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, factor: float) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, xFactor: float, yFactor: float) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __mul__(self, val: float) -&gt; Scale2d:</code>
            <code><span class="kw">def</span> __ne__(self, other: PyGe.Scale2d) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __setitem__(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> postMultBy(self, right: PyGe.Scale2d) -&gt; Scale2d:</code>
            <code><span class="kw">def</span> preMultBy(self, left: PyGe.Scale2d) -&gt; Scale2d:</code>
            <code><span class="kw">def</span> setToProduct(self, sclVec1: PyGe.Scale2d, s: float) -&gt; Scale2d:</code>
            <code><span class="kw">def</span> setToProduct(self, sclVec1: PyGe.Scale2d, ssclVec2: PyGe.Scale2d) -&gt; Scale2d:</code>
            <code><span class="kw">def</span> setToProduct(*args) -&gt; Scale2d:</code>
            <code><span class="kw">def</span> sx(self) -&gt; float:</code>
            <code><span class="kw">def</span> sy(self) -&gt; float:</code>
            <code><span class="kw">def</span> toString(self) -&gt; str:</code>
        </details>
    </div>

    <div class="class" id="Scale3d">
        <details>
            <summary>class Scale3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __getitem__(self, idx: int) -&gt; float:</code>
            <code><span class="kw">def</span> __imul__(self, val: float) -&gt; Scale3d:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, factor: float) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, sx: float, sy: float, sz: float) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __mul__(self, val: float) -&gt; Scale3d:</code>
            <code><span class="kw">def</span> __ne__(self, other: PyGe.Scale3d) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __setitem__(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> postMultBy(self, vec: PyGe.Vector3d) -&gt; Scale3d:</code>
            <code><span class="kw">def</span> preMultBy(self, vec: PyGe.Vector3d) -&gt; Scale3d:</code>
            <code><span class="kw">def</span> setToProduct(self, sc: PyGe.Scale3d, s: float) -&gt; Scale3d:</code>
            <code><span class="kw">def</span> setToProduct(self, sc1: PyGe.Scale3d, sc2: PyGe.Scale3d) -&gt; Scale3d:</code>
            <code><span class="kw">def</span> setToProduct(*args) -&gt; Scale3d:</code>
            <code><span class="kw">def</span> sx(self) -&gt; float:</code>
            <code><span class="kw">def</span> sy(self) -&gt; float:</code>
            <code><span class="kw">def</span> sz(self) -&gt; float:</code>
            <code><span class="kw">def</span> toString(self) -&gt; str:</code>
        </details>
    </div>

    <div class="class" id="Sphere">
        <details>
            <summary>class Sphere <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents a spherical surface.</span></code>
            <code><span class="kw">def</span> __init__(self, radius: float, center: PyGe.Point3d) -&gt; None:
    <span class="ds">Represents a spherical surface.</span></code>
            <code><span class="kw">def</span> __init__(self, radius: float, center: PyGe.Point3d, northAxis: PyGe.Vector3d, refAxis: PyGe.Vector3d, startAngleU: float, endAngleU: float, startAngleV: float, endAngleV: float) -&gt; None:
    <span class="ds">Represents a spherical surface.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">Represents a spherical surface.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Sphere:</code>
            <code><span class="kw">def</span> center(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Sphere:</code>
            <code><span class="kw">def</span> getAnglesInU(self) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getAnglesInV(self) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> intersectWith(self, val: PyGe.LinearEnt3d, tol: PyGe.Tol) -&gt; tuple[int, PyGe.Point3d, PyGe.Point3d]:</code>
            <code><span class="kw">def</span> isClosed(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isOuterNormal(self) -&gt; bool:</code>
            <code><span class="kw">def</span> northAxis(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> northPole(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> radius(self) -&gt; float:</code>
            <code><span class="kw">def</span> refAxis(self) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> set(self, radius: float, center: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> set(self, radius: float, center: PyGe.Point3d, northAxis: PyGe.Vector3d, refAxis: PyGe.Vector3d, startAngleU: float, endAngleU: float, startAngleV: float, endAngleV: float) -&gt; None:</code>
            <code><span class="kw">def</span> set(*args) -&gt; None:</code>
            <code><span class="kw">def</span> setAnglesInU(self, start: float, end: float) -&gt; None:</code>
            <code><span class="kw">def</span> setAnglesInV(self, start: float, end: float) -&gt; None:</code>
            <code><span class="kw">def</span> setRadius(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> southPole(self) -&gt; Point3d:</code>
        </details>
    </div>

    <div class="class" id="SplineEnt2d">
        <details>
            <summary>class SplineEnt2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity2d) -&gt; SplineEnt2d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> continuityAtKnot(self, idx: int, tol: PyGe.Tol) -&gt; int:</code>
            <code><span class="kw">def</span> controlPointAt(self, idx: int) -&gt; Point2d:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity2d) -&gt; SplineEnt2d:</code>
            <code><span class="kw">def</span> degree(self) -&gt; int:</code>
            <code><span class="kw">def</span> endParam(self) -&gt; float:</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; Point2d:</code>
            <code><span class="kw">def</span> hasFitData(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isRational(self) -&gt; bool:</code>
            <code><span class="kw">def</span> knotAt(self, idx: int) -&gt; float:</code>
            <code><span class="kw">def</span> knots(self) -&gt; KnotVector:</code>
            <code><span class="kw">def</span> numControlPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> numKnots(self) -&gt; int:</code>
            <code><span class="kw">def</span> order(self) -&gt; int:</code>
            <code><span class="kw">def</span> setControlPointAt(self, idx: int, val: PyGe.Point2d) -&gt; None:</code>
            <code><span class="kw">def</span> setKnotAt(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> startParam(self) -&gt; float:</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; Point2d:</code>
        </details>
    </div>

    <div class="class" id="SplineEnt3d">
        <details>
            <summary>class SplineEnt3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; SplineEnt3d:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> continuityAtKnot(self, idx: int, tol: PyGe.Tol) -&gt; int:</code>
            <code><span class="kw">def</span> controlPointAt(self, idx: int) -&gt; Point3d:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; SplineEnt3d:</code>
            <code><span class="kw">def</span> degree(self) -&gt; int:</code>
            <code><span class="kw">def</span> endParam(self) -&gt; float:</code>
            <code><span class="kw">def</span> endPoint(self) -&gt; Point3d:</code>
            <code><span class="kw">def</span> hasFitData(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isRational(self) -&gt; bool:</code>
            <code><span class="kw">def</span> knotAt(self, idx: int) -&gt; float:</code>
            <code><span class="kw">def</span> knots(self) -&gt; KnotVector:</code>
            <code><span class="kw">def</span> numControlPoints(self) -&gt; int:</code>
            <code><span class="kw">def</span> numKnots(self) -&gt; int:</code>
            <code><span class="kw">def</span> order(self) -&gt; int:</code>
            <code><span class="kw">def</span> setControlPointAt(self, idx: int, val: PyGe.Point3d) -&gt; None:</code>
            <code><span class="kw">def</span> setKnotAt(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> startParam(self) -&gt; float:</code>
            <code><span class="kw">def</span> startPoint(self) -&gt; Point3d:</code>
        </details>
    </div>

    <div class="class" id="SurfSurfInt">
        <details>
            <summary>class SurfSurfInt <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">This class holds data for intersections of two surfaces.</span></code>
            <code><span class="kw">def</span> __init__(self, srf1: PyGe.Surface, srf2: PyGe.Surface) -&gt; None:
    <span class="ds">This class holds data for intersections of two surfaces.</span></code>
            <code><span class="kw">def</span> __init__(self, srf1: PyGe.Surface, srf2: PyGe.Surface, tol: PyGe.Tol) -&gt; None:
    <span class="ds">This class holds data for intersections of two surfaces.</span></code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:
    <span class="ds">This class holds data for intersections of two surfaces.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; SurfSurfInt:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; SurfSurfInt:</code>
            <code><span class="kw">def</span> getDimension(self, intNum: int) -&gt; int:</code>
            <code><span class="kw">def</span> getIntConfigs(self, intNum: int) -&gt; tuple:</code>
            <code><span class="kw">def</span> getIntPointParams(self, intNum: int) -&gt; tuple[PyGe.Point2d, PyGe.Point2d]:</code>
            <code><span class="kw">def</span> getType(self, intNum: int) -&gt; int:</code>
            <code><span class="kw">def</span> intCurve(self, intNum: int, isExternal: bool) -&gt; Curve3d:</code>
            <code><span class="kw">def</span> intParamCurve(self, intNum: int, isExternal: bool, isFirst: bool) -&gt; Curve2d:</code>
            <code><span class="kw">def</span> intPoint(self, intNum: int) -&gt; Point3d:</code>
            <code><span class="kw">def</span> numResults(self) -&gt; int:</code>
            <code><span class="kw">def</span> set(self, srf1: PyGe.Surface, srf2: PyGe.Surface, tol: PyGe.Tol) -&gt; None:</code>
            <code><span class="kw">def</span> surface1(self) -&gt; PyGe.Surface:</code>
            <code><span class="kw">def</span> surface2(self) -&gt; PyGe.Surface:</code>
            <code><span class="kw">def</span> tolerance(self) -&gt; Tol:</code>
        </details>
    </div>

    <div class="class" id="Surface">
        <details>
            <summary>class Surface <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; PyGe.Surface:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> closestPointTo(self, pt: PyGe.Point3d, tol: PyGe.Tol) -&gt; Point3d:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; PyGe.Surface:</code>
            <code><span class="kw">def</span> distanceTo(self, pt: PyGe.Point3d, tol: PyGe.Tol) -&gt; float:</code>
            <code><span class="kw">def</span> evalPoint(self, param: PyGe.Point2d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> evalPoint(self, param: PyGe.Point3d, derivOrd: int, vecs: list[PyGe.Vector3d]) -&gt; Point3d:</code>
            <code><span class="kw">def</span> evalPoint(self, param: PyGe.Point3d, derivOrd: int, vecs: list[PyGe.Vector3d], normal: PyGe.Vector3d) -&gt; Point3d:</code>
            <code><span class="kw">def</span> evalPoint(*args) -&gt; Point3d:</code>
            <code><span class="kw">def</span> isClosedInU(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isClosedInV(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isNormalReversed(self) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(self, pnt: PyGe.Point3d) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(self, pnt: PyGe.Point3d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(self, pnt: PyGe.Point3d, paramPoint: PyGe.Point2d) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(self, pnt: PyGe.Point3d, paramPoint: PyGe.Point2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isOn(*args) -&gt; bool:</code>
            <code><span class="kw">def</span> paramOf(self, pt: PyGe.Point3d, tol: PyGe.Tol) -&gt; Point2d:</code>
            <code><span class="kw">def</span> reverseNormal(self) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Tol">
        <details>
            <summary>class Tol <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> current() -&gt; Tol:</code>
            <code><span class="kw">def</span> equalPoint(self) -&gt; float:</code>
            <code><span class="kw">def</span> equalVector(self) -&gt; float:</code>
            <code><span class="kw">def</span> setEqualPoint(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setEqualVector(self, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> setGlobalTol(val: PyGe.Tol) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Torus">
        <details>
            <summary>class Torus <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:
    <span class="ds">Represents toroidal segment.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> cast(otherObject: PyGe.Entity3d) -&gt; Torus:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> copycast(otherObject: PyGe.Entity3d) -&gt; Torus:</code>
        </details>
    </div>

    <div class="class" id="Vector2d">
        <details>
            <summary>class Vector2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __add__(self, vec: PyGe.Vector2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __getinitargs__(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> __getitem__(self, idx: int) -&gt; float:</code>
            <code><span class="kw">def</span> __hash__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __iadd__(self, vec: PyGe.Vector2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __imul__(self, val: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, x: float, y: float) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:</code>
            <code><span class="kw">def</span> __isub__(self, vec: PyGe.Vector2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __itruediv__(self, val: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __mul__(self, val: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __ne__(self, other: PyGe.Vector2d) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __rmul__(self, val: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __rmul__(self, xform: PyGe.Matrix2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __rmul__(*args) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __setitem__(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> __sub__(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> __truediv__(self, val: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> angle(self) -&gt; float:</code>
            <code><span class="kw">def</span> angleTo(self, vec: PyGe.Vector2d) -&gt; float:</code>
            <code><span class="kw">def</span> dotProduct(self, vec: PyGe.Vector2d) -&gt; float:</code>
            <code><span class="kw">def</span> isCodirectionalTo(self, vec: PyGe.Vector2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isEqualTo(self, vec: PyGe.Vector3d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isParallelTo(self, vec: PyGe.Vector2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isPerpendicularTo(self, vec: PyGe.Vector2d, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isUnitLength(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code><span class="kw">def</span> isZeroLength(self, tol: PyGe.Tol) -&gt; bool:</code>
            <code>kIdentity: PyGe.Vector2d</code>
            <code>kXAxis: PyGe.Vector2d</code>
            <code>kYAxis: PyGe.Vector2d</code>
            <code><span class="kw">def</span> length(self) -&gt; float:</code>
            <code><span class="kw">def</span> lengthSqrd(self) -&gt; float:</code>
            <code><span class="kw">def</span> mirror(self, vec: PyGe.Vector2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> negate(self) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> normal(self, tol: PyGe.Tol) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> normalize(self, tol: PyGe.Tol) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> rotateBy(self, val: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> set(self, xx: float, yy: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> setToProduct(self, vec: PyGe.Vector2d, s: float) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> setToProduct(self, xform: PyGe.Matrix2d, vec: PyGe.Vector3d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> setToProduct(*args) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> setToSum(self, v1: PyGe.Vector2d, v2: PyGe.Vector2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> toList(self) -&gt; list[float]:</code>
            <code><span class="kw">def</span> toString(self) -&gt; str:</code>
            <code><span class="kw">def</span> toTuple(self) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> transformBy(self, xform: PyGe.Matrix2d) -&gt; Vector2d:</code>
            <code><span class="kw">def</span> x(self) -&gt; float:</code>
            <code><span class="kw">def</span> y(self) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="Vector3d">
        <details>
            <summary>class Vector3d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __add__(self, vec: PyGe.Vector3d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __getinitargs__(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> __getitem__(self, idx: int) -&gt; float:</code>
            <code><span class="kw">def</span> __hash__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __iadd__(self, vec: PyGe.Vector3d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __imul__(self, val: float) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, floats: tuple[float] | list[float]) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, x: float, y: float, z: float) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(self, pln: PyGe.PlanarEnt, pnt2d: PyGe.Vector2d) -&gt; None:</code>
            <code><span class="kw">def</span> __init__(*args) -&gt; None:</code>
            <code><span class="kw">def</span> __isub__(self, vec: PyGe.Vector3d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __itruediv__(self, val: float) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __len__(self) -&gt; int:</code>
            <code><span class="kw">def</span> __mul__(self, val: float) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __ne__(self, vec: PyGe.Vector3d) -&gt; bool:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> __rmul__(self, val: float | PyGe.Matrix3d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __setitem__(self, idx: int, val: float) -&gt; None:</code>
            <code><span class="kw">def</span> __sub__(self, vec: PyGe.Vector3d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> __truediv__(self, val: float) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> angleOnPlane(self, pln: PyGe.PlanarEnt) -&gt; float:
    <span class="ds">Returns the angle between the orthogonal projection of this vector into the plane through
the origin with the same normal as planar entity pln and the zeroth basis vector v0 of the
planar entity pln provided by the function pln.getCoordSystem (p, v0, v1).</span></code>
            <code><span class="kw">def</span> angleTo(self, vec: PyGe.Vector3d, ref: PyGe.Vector3d) -&gt; float:
    <span class="ds">Returns the angle between this vector and the vector vec in the range [0, Pi].</span></code>
            <code><span class="kw">def</span> convert2d(self, pln: PyGe.PlanarEnt) -&gt; Vector2d:
    <span class="ds">Returns 2D vector with the coordinates corresponding to the decomposition of this vector in
the basis uAxis, vAxis in the planar entity pln, where uAxis and vAxis can be found by
function call pln.get(p, uAxis, vAxis). Contract: This 3D vector is assumed to be parallel
to the planar entity pln.</span></code>
            <code><span class="kw">def</span> crossProduct(self, vec: PyGe.Vector3d) -&gt; Vector3d:
    <span class="ds">Returns the cross product of this vector and vector vec.</span></code>
            <code><span class="kw">def</span> dotProduct(self, vec: PyGe.Vector3d) -&gt; float:
    <span class="ds">Returns the dot product of this vector and vector v.</span></code>
            <code><span class="kw">def</span> isCodirectionalTo(self, vec: PyGe.Vector3d, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Checks if this vector is codirectional to the vector vec. Namely, it checks if after
normalization this vector is within the distance tol.equalVector() from the normalization
of the vector vec. Returns Adesk::kTrue if this condition is met and Adesk::kFalse
otherwise.</span></code>
            <code><span class="kw">def</span> isEqualTo(self, vec: PyGe.Vector3d, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Checks if this vector is within the distance tol.equalVector() from the vector vec. The
default value of the tolerance class tol is AcGeContext::gTol. Returns Adesk::kTrue if this
condition is met and Adesk::kFalse otherwise.</span></code>
            <code><span class="kw">def</span> isParallelTo(self, vec: PyGe.Vector3d, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Checks if this vector is parallel to the vector vec. Namely, it checks if after
normalization (and negation, in the case of negative dot product with the vector vec), this
vector is within the distance tol.equalVector() from the normalization of the vector vec.
Returns Adesk::kTrue if this condition is met and Adesk::kFalse otherwise.</span></code>
            <code><span class="kw">def</span> isPerpendicularTo(self, vec: PyGe.Vector3d, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Checks if this vector is perpendicular to the vector vec. Namely, it checks if after
normalization the dot product of this vector with the normalization of the vector vec is
less than tol.equalVector() in absolute value. Returns Adesk::kTrue if this condition is
met and Adesk::kFalse otherwise.</span></code>
            <code><span class="kw">def</span> isUnitLength(self, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Returns Adesk::kTrue if this vector is equal to its normalization. Returns Adesk::kFalse
otherwise.</span></code>
            <code><span class="kw">def</span> isZeroLength(self, tol: PyGe.Tol) -&gt; bool:
    <span class="ds">Returns Adesk::kTrue if this vector is a zero length vector, Adesk::kFalse otherwise.</span></code>
            <code>kIdentity: PyGe.Vector3d</code>
            <code>kXAxis: PyGe.Vector3d</code>
            <code>kYAxis: PyGe.Vector3d</code>
            <code>kZAxis: PyGe.Vector3d</code>
            <code><span class="kw">def</span> largestElement(self) -&gt; int:
    <span class="ds">Returns the index of the largest absolute value coordinate of this vector.</span></code>
            <code><span class="kw">def</span> length(self) -&gt; float:
    <span class="ds">Returns the Euclidean length of this vector.</span></code>
            <code><span class="kw">def</span> lengthSqrd(self) -&gt; float:
    <span class="ds">Returns the square of the Euclidean length of this vector.</span></code>
            <code><span class="kw">def</span> mirror(self, normalToPlane: PyGe.Vector3d) -&gt; Vector3d:
    <span class="ds">Returns the 3D vector which is the result of mirroring of this vector with respect to the
plane with the normal normalToPlane passing through the origin.</span></code>
            <code><span class="kw">def</span> negate(self) -&gt; Vector3d:
    <span class="ds">Negates this vector, namely sets it to be equal to the vector (-x,-y). Returns the
reference to this vector.</span></code>
            <code><span class="kw">def</span> normal(self, tol: PyGe.Tol) -&gt; Vector3d:
    <span class="ds">Returns the unit vector codirectional to this vector. The vector is not normalized if its
length is less than tol.equalVector(), in which case the returned vector is the same as
this vector.</span></code>
            <code><span class="kw">def</span> normalize(self) -&gt; Vector3d:
    <span class="ds">Sets this vector to the unit vector codirectional to this vector. Returns the reference to
this vector. This vector is not normalized if its length is less than tol.equalVector(), in
which case it remains unchanged. The flag argument will be set to the following value to
indicate if a failure may have occurred: k0This.</span></code>
            <code><span class="kw">def</span> orthoProject(self, planeNormal: PyGe.Vector3d, tol: PyGe.Tol) -&gt; Vector3d:
    <span class="ds">Returns a 3D vector which is the result of the orthogonal projection of this point into the
plane with normal planeNormal passing through the origin.</span></code>
            <code><span class="kw">def</span> perpVector(self) -&gt; Vector3d:
    <span class="ds">Returns a vector orthogonal to this vector. The choice of the orthogonal vector is
determined by the function AcGeContext::gOrthoVector.</span></code>
            <code><span class="kw">def</span> project(self, pln: PyGe.Vector3d, dir: PyGe.Vector3d, tol: PyGe.Tol) -&gt; Vector3d:
    <span class="ds">Returns the 3D vector that is the result of the parallel projection of this vector into the
plane with normal planeNormal passing through the origin. The direction of projection is
defined by vector projectDirection.</span></code>
            <code><span class="kw">def</span> rotateBy(self, angle: float, axis: PyGe.Vector3d) -&gt; Vector3d:
    <span class="ds">Returns 3D point which is the result of rotation of this vector around the line with axis
passing through the origin. Rotation angle is given by the argument ang, where positive
direction of rotation is defined by the right-hand rule.</span></code>
            <code><span class="kw">def</span> rotateTo(self, vec: PyGe.Vector3d, axis: PyGe.Vector3d) -&gt; Matrix3d:
    <span class="ds">Returns a matrix mat such that matX this vector yields the argument vector vec. There is no
unique matrix to represent a rotation from this vector to vec when they are parallel and in
opposite directions. In this case, the argument axis is used (if it is perpendicular to
this vector) to uniquely determine the resultant matrix. axis defaults to the zero-length
vector, in which case an arbitrary (but correct) matrix will be returned that rotates this
vector to vec. Contract: This vector and vec must be non-zero length.</span></code>
            <code><span class="kw">def</span> set(self, x: float, y: float, z: float) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> set(self, pln: PyGe.PlanarEnt, pnt2d: PyGe.Vector2d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> set(*args) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> setToProduct(self, vec: PyGe.Vector3d, s: float) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> setToProduct(self, xform: PyGe.Matrix3d, vec: PyGe.Vector3d) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> setToProduct(*args) -&gt; Vector3d:</code>
            <code><span class="kw">def</span> setToSum(self, v1: PyGe.Vector3d, v2: PyGe.Vector3d) -&gt; Vector3d:
    <span class="ds">Sets this vector to the sum of the vector v1 and vector v2. Returns the reference to this
vector.</span></code>
            <code><span class="kw">def</span> toList(self) -&gt; list[float]:</code>
            <code><span class="kw">def</span> toString(self) -&gt; str:</code>
            <code><span class="kw">def</span> toTuple(self) -&gt; tuple[float, float, float]:</code>
            <code><span class="kw">def</span> transformBy(self, xform: PyGe.Matrix3d) -&gt; Vector3d:
    <span class="ds">Transform this vector by pre-multiplying it by the matrix leftSide. Returns the reference
to this vector. Result is the same as setToProduct(leftSide, *this).</span></code>
            <code><span class="kw">def</span> x(self) -&gt; float:</code>
            <code><span class="kw">def</span> y(self) -&gt; float:</code>
            <code><span class="kw">def</span> z(self) -&gt; float:</code>
        </details>
    </div>
</body>
</html>