<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PyBr.pyi</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: Consolas, monospace;
            margin: 2em;
        }
        a {
            color: #569cd6;
        }
        .class {
            margin-bottom: 1em;
        }
        summary {
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }
        details {
            margin-left: 0.5em;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            padding: 0.5em;
        }
        code {
            display: block;
            margin: 0.3em 0;
            white-space: pre;
            background-color: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4em 0.6em;
            border-left: 4px solid #007acc;
            font-size: 1.2em;
        }
        .kw {
            color: #569cd6;
            font-weight: bold;
        }
        .ds {
            color: #FF8787;
            opacity: 0.7;
        }
        h1 {
            color: #569cd6;
        }
        .tag {
            background: #007acc;
            color: #fff;
            border-radius: 4px;
            padding: 0.1em 0.5em;
            font-size: 0.9em;
            margin-left: 0.5em;
        }
        .toc {
            margin-bottom: 2em;
        }
    </style>
</head>
<body>
    <h1>PyBr.pyi</h1>
    <div class="toc">
        <h2>Classes</h2>
        <ul>
            <li><a href="#Brep">Brep</a></li>
            <li><a href="#Complex">Complex</a></li>
            <li><a href="#ComplexShellTraverser">ComplexShellTraverser</a></li>
            <li><a href="#ComplexTraverser">ComplexTraverser</a></li>
            <li><a href="#Edge">Edge</a></li>
            <li><a href="#EdgeLoopTraverser">EdgeLoopTraverser</a></li>
            <li><a href="#EdgeTraverser">EdgeTraverser</a></li>
            <li><a href="#Element">Element</a></li>
            <li><a href="#Element2d">Element2d</a></li>
            <li><a href="#Element2dNodeTraverser">Element2dNodeTraverser</a></li>
            <li><a href="#Element2dShape">Element2dShape</a></li>
            <li><a href="#Entity">Entity</a></li>
            <li><a href="#ErrorStatus">ErrorStatus</a></li>
            <li><a href="#Face">Face</a></li>
            <li><a href="#FaceLoopTraverser">FaceLoopTraverser</a></li>
            <li><a href="#FaceTraverser">FaceTraverser</a></li>
            <li><a href="#Hit">Hit</a></li>
            <li><a href="#Loop">Loop</a></li>
            <li><a href="#LoopEdgeTraverser">LoopEdgeTraverser</a></li>
            <li><a href="#LoopType">LoopType</a></li>
            <li><a href="#LoopVertexTraverser">LoopVertexTraverser</a></li>
            <li><a href="#MassProps">MassProps</a></li>
            <li><a href="#Mesh">Mesh</a></li>
            <li><a href="#Mesh2d">Mesh2d</a></li>
            <li><a href="#Mesh2dElement2dTraverser">Mesh2dElement2dTraverser</a></li>
            <li><a href="#MeshEntity">MeshEntity</a></li>
            <li><a href="#Node">Node</a></li>
            <li><a href="#Relation">Relation</a></li>
            <li><a href="#Shell">Shell</a></li>
            <li><a href="#ShellFaceTraverser">ShellFaceTraverser</a></li>
            <li><a href="#ShellTraverser">ShellTraverser</a></li>
            <li><a href="#ShellType">ShellType</a></li>
            <li><a href="#Traverser">Traverser</a></li>
            <li><a href="#ValidationLevel">ValidationLevel</a></li>
            <li><a href="#Vertex">Vertex</a></li>
            <li><a href="#VertexEdgeTraverser">VertexEdgeTraverser</a></li>
            <li><a href="#VertexLoopTraverser">VertexLoopTraverser</a></li>
            <li><a href="#VertexTraverser">VertexTraverser</a></li>
        </ul>
    </div>

    <div class="class" id="Brep">
        <details>
            <summary>class Brep <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, entity: PyDb.Entity) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getSolid(self) -&gt; PyDb.Solid3d:</code>
            <code><span class="kw">def</span> getSurface(self) -&gt; PyGe.Surface:</code>
            <code><span class="kw">def</span> set(self, entity: PyDb.Entity) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Complex">
        <details>
            <summary>class Complex <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
        </details>
    </div>

    <div class="class" id="ComplexShellTraverser">
        <details>
            <summary>class ComplexShellTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getComplex(self) -&gt; Complex:</code>
            <code><span class="kw">def</span> getShell(self) -&gt; Shell:</code>
            <code><span class="kw">def</span> setComplex(self, val: PyBr.Complex) -&gt; None:</code>
            <code><span class="kw">def</span> setComplexAndShell(self, val: PyBr.Shell) -&gt; None:</code>
            <code><span class="kw">def</span> setComplexTraverser(self, val: PyBr.BrepComplexTraverser) -&gt; None:</code>
            <code><span class="kw">def</span> setShell(self, val: PyBr.Shell) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="ComplexTraverser">
        <details>
            <summary>class ComplexTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getBrep(self) -&gt; Brep:</code>
            <code><span class="kw">def</span> getComplex(self) -&gt; Complex:</code>
            <code><span class="kw">def</span> getComplexs(self) -&gt; list[PyBr.Complex]:</code>
            <code><span class="kw">def</span> setBrep(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> setBrepAndComplex(self, val: PyBr.Complex) -&gt; None:</code>
            <code><span class="kw">def</span> setComplex(self, val: PyBr.Complex) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Edge">
        <details>
            <summary>class Edge <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getCurve(self) -&gt; PyGe.ExternalCurve3d:</code>
            <code><span class="kw">def</span> getCurveType(self) -&gt; PyGe.EntityId:</code>
            <code><span class="kw">def</span> getOrientToCurve(self) -&gt; bool:</code>
            <code><span class="kw">def</span> getVertex1(self) -&gt; PyBr.Vertex:</code>
            <code><span class="kw">def</span> getVertex2(self) -&gt; PyBr.Vertex:</code>
        </details>
    </div>

    <div class="class" id="EdgeLoopTraverser">
        <details>
            <summary>class EdgeLoopTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getEdge(self) -&gt; Edge:</code>
            <code><span class="kw">def</span> getLoop(self) -&gt; Loop:</code>
            <code><span class="kw">def</span> setEdge(self, val: PyBr.Edge) -&gt; None:</code>
            <code><span class="kw">def</span> setEdgeAndLoop(self, val: PyBr.LoopEdgeTraverser) -&gt; None:</code>
            <code><span class="kw">def</span> setLoop(self, val: PyBr.Loop) -&gt; None:</code>
            <code><span class="kw">def</span> setVertexAndEdge(self, val: PyBr.VertexEdgeTraverser) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="EdgeTraverser">
        <details>
            <summary>class EdgeTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getBrep(self) -&gt; Brep:</code>
            <code><span class="kw">def</span> getEdge(self) -&gt; Edge:</code>
            <code><span class="kw">def</span> getEdges(self) -&gt; list[PyBr.Edge]:</code>
            <code><span class="kw">def</span> setBrep(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> setBrepAndEdge(self, val: PyBr.Edge) -&gt; None:</code>
            <code><span class="kw">def</span> setEdge(self, val: PyBr.Edge) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Element">
        <details>
            <summary>class Element <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
        </details>
    </div>

    <div class="class" id="Element2d">
        <details>
            <summary>class Element2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getNormal(self) -&gt; PyGe.Vector3d:</code>
        </details>
    </div>

    <div class="class" id="Element2dNodeTraverser">
        <details>
            <summary>class Element2dNodeTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getElement(self) -&gt; Element2d:</code>
            <code><span class="kw">def</span> getNode(self) -&gt; Node:</code>
            <code><span class="kw">def</span> getParamPoint(self) -&gt; PyGe.Point2d:</code>
            <code><span class="kw">def</span> getSurfaceNormal(self) -&gt; PyGe.Vector3d:</code>
            <code><span class="kw">def</span> setElement(self, val: PyBr.Element2d) -&gt; None:</code>
            <code><span class="kw">def</span> setElementTraverser(self, val: PyBr.Mesh2dElement2dTraverser) -&gt; None:</code>
            <code><span class="kw">def</span> setNode(self, val: PyBr.Node) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Element2dShape">
        <details>
            <summary>class Element2dShape <span class="tag">Class</span></summary>
            <code>kDefault: ClassVar[Self]</code>
            <code>kAllPolygons: ClassVar[Self]</code>
            <code>kAllQuadrilaterals: ClassVar[Self]</code>
            <code>kAllTriangles: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Entity">
        <details>
            <summary>class Entity <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> brepChanged(self) -&gt; bool:</code>
            <code><span class="kw">def</span> checkEntity(self) -&gt; bool:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getBoundBlock(self) -&gt; PyGe.BoundBlock3d:</code>
            <code><span class="kw">def</span> getBrep(self) -&gt; Brep:</code>
            <code><span class="kw">def</span> getLineContainment(self, line: PyGe.LinearEnt3d, numHitsWanted: int) -&gt; list[PyBr.Hit]:</code>
            <code><span class="kw">def</span> getMassProps(self, density: float, tolRequired: float) -&gt; tuple:</code>
            <code><span class="kw">def</span> getPerimeterLength(self, tolRequired: float) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getPointContainment(self, pt: PyGe.Point3d) -&gt; tuple[PyBr.Entity, PyGe.PointContainment]:</code>
            <code><span class="kw">def</span> getSubentPath(self) -&gt; PyDb.FullSubentPath:</code>
            <code><span class="kw">def</span> getSurfaceArea(self, tolRequired: float) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getValidationLevel(self) -&gt; ValidationLevel:</code>
            <code><span class="kw">def</span> getVolume(self, tolRequired: float) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> isEqualTo(self, otherObject: PyRx.RxObject) -&gt; bool:</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setSubentPath(self, val: PyDb.FullSubentPath) -&gt; None:</code>
            <code><span class="kw">def</span> setValidationLevel(self, val: PyBr.ValidationLevel) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="ErrorStatus">
        <details>
            <summary>class ErrorStatus <span class="tag">Class</span></summary>
            <code>eAmbiguousOutput: ClassVar[Self]</code>
            <code>eBrepChanged: ClassVar[Self]</code>
            <code>eDegenerateTopology: ClassVar[Self]</code>
            <code>eInvalidInput: ClassVar[Self]</code>
            <code>eInvalidObject: ClassVar[Self]</code>
            <code>eMissingGeometry: ClassVar[Self]</code>
            <code>eMissingSubentity: ClassVar[Self]</code>
            <code>eNotApplicable: ClassVar[Self]</code>
            <code>eNotImplementedYet: ClassVar[Self]</code>
            <code>eNullObjectId: ClassVar[Self]</code>
            <code>eNullObjectPointer: ClassVar[Self]</code>
            <code>eNullSubentityId: ClassVar[Self]</code>
            <code>eObjectIdMismatch: ClassVar[Self]</code>
            <code>eOk: ClassVar[Self]</code>
            <code>eOutOfMemory: ClassVar[Self]</code>
            <code>eTopologyMismatch: ClassVar[Self]</code>
            <code>eUninitialisedObject: ClassVar[Self]</code>
            <code>eUnsuitableGeometry: ClassVar[Self]</code>
            <code>eUnsuitableTopology: ClassVar[Self]</code>
            <code>eWrongObjectType: ClassVar[Self]</code>
            <code>eWrongSubentityType: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Face">
        <details>
            <summary>class Face <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getArea(self) -&gt; float:</code>
            <code><span class="kw">def</span> getAreaWithTol(self, tolRequired: float) -&gt; tuple[float, float]:</code>
            <code><span class="kw">def</span> getOrientToSurface(self) -&gt; bool:</code>
            <code><span class="kw">def</span> getShell(self) -&gt; Shell:</code>
            <code><span class="kw">def</span> getSurface(self) -&gt; PyGe.Surface:</code>
            <code><span class="kw">def</span> getSurfaceType(self) -&gt; PyGe.EntityId:</code>
        </details>
    </div>

    <div class="class" id="FaceLoopTraverser">
        <details>
            <summary>class FaceLoopTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getFace(self) -&gt; Face:</code>
            <code><span class="kw">def</span> getLoop(self) -&gt; Loop:</code>
            <code><span class="kw">def</span> setFace(self, val: PyBr.Face) -&gt; None:</code>
            <code><span class="kw">def</span> setFaceAndLoop(self, val: PyBr.Loop) -&gt; None:</code>
            <code><span class="kw">def</span> setFaceTraverser(self, val: PyBr.ShellFaceTraverser) -&gt; None:</code>
            <code><span class="kw">def</span> setLoop(self, val: PyBr.Loop) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="FaceTraverser">
        <details>
            <summary>class FaceTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getBrep(self) -&gt; Brep:</code>
            <code><span class="kw">def</span> getFace(self) -&gt; Face:</code>
            <code><span class="kw">def</span> getFaces(self) -&gt; list[PyBr.Face]:</code>
            <code><span class="kw">def</span> setBrep(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> setBrepAndFace(self, val: PyBr.Face) -&gt; None:</code>
            <code><span class="kw">def</span> setFace(self, val: PyBr.Face) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Hit">
        <details>
            <summary>class Hit <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> brepChanged(self) -&gt; bool:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getEntityAssociated(self) -&gt; Entity:</code>
            <code><span class="kw">def</span> getEntityEntered(self) -&gt; Entity:</code>
            <code><span class="kw">def</span> getEntityHit(self) -&gt; Entity:</code>
            <code><span class="kw">def</span> getPoint(self) -&gt; PyGe.Point3d:</code>
            <code><span class="kw">def</span> getValidationLevel(self) -&gt; ValidationLevel:</code>
            <code><span class="kw">def</span> isEqualTo(self, otherObject: PyRx.RxObject) -&gt; bool:</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setValidationLevel(self, val: PyBr.ValidationLevel) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Loop">
        <details>
            <summary>class Loop <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getFace(self) -&gt; Face:</code>
            <code><span class="kw">def</span> getType(self) -&gt; LoopType:</code>
        </details>
    </div>

    <div class="class" id="LoopEdgeTraverser">
        <details>
            <summary>class LoopEdgeTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getEdge(self) -&gt; Edge:</code>
            <code><span class="kw">def</span> getEdgeOrientToLoop(self) -&gt; bool:</code>
            <code><span class="kw">def</span> getLoop(self) -&gt; Loop:</code>
            <code><span class="kw">def</span> getOrientedCurve(self) -&gt; PyGe.Curve3d:</code>
            <code><span class="kw">def</span> getParamCurve(self) -&gt; PyGe.Curve2d:</code>
            <code><span class="kw">def</span> setEdge(self, val: PyBr.Edge) -&gt; None:</code>
            <code><span class="kw">def</span> setLoop(self, val: PyBr.Loop) -&gt; None:</code>
            <code><span class="kw">def</span> setLoopAndEdge(self, val: PyBr.EdgeLoopTraverser) -&gt; None:</code>
            <code><span class="kw">def</span> setLoopTraverser(self, val: PyBr.FaceLoopTraverser) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="LoopType">
        <details>
            <summary>class LoopType <span class="tag">Class</span></summary>
            <code>kUnclassified: ClassVar[Self]</code>
            <code>kExterior: ClassVar[Self]</code>
            <code>kInterior: ClassVar[Self]</code>
            <code>kWinding: ClassVar[Self]</code>
            <code>kLoopUnclassified: ClassVar[Self]</code>
            <code>kLoopExterior: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="LoopVertexTraverser">
        <details>
            <summary>class LoopVertexTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getLoop(self) -&gt; Loop:</code>
            <code><span class="kw">def</span> getParamPoint(self) -&gt; PyGe.Point2d:</code>
            <code><span class="kw">def</span> getVertex(self) -&gt; PyBr.Vertex:</code>
            <code><span class="kw">def</span> setLoop(self, val: PyBr.Loop) -&gt; None:</code>
            <code><span class="kw">def</span> setLoopAndVertex(self, val: PyBr.VertexLoopTraverser) -&gt; None:</code>
            <code><span class="kw">def</span> setLoopTraverser(self, val: PyBr.FaceLoopTraverser) -&gt; None:</code>
            <code><span class="kw">def</span> setVertex(self, val: PyBr.Vertex) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="MassProps">
        <details>
            <summary>class MassProps <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> centroid(self) -&gt; PyGe.Point3d:</code>
            <code><span class="kw">def</span> mass(self) -&gt; float:</code>
            <code><span class="kw">def</span> momInertia(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> prinAxes(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> prinMoments(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> prodInertia(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> radiiGyration(self) -&gt; tuple:</code>
            <code><span class="kw">def</span> volume(self) -&gt; float:</code>
        </details>
    </div>

    <div class="class" id="Mesh">
        <details>
            <summary>class Mesh <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
        </details>
    </div>

    <div class="class" id="Mesh2d">
        <details>
            <summary>class Mesh2d <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
        </details>
    </div>

    <div class="class" id="Mesh2dElement2dTraverser">
        <details>
            <summary>class Mesh2dElement2dTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getElement(self) -&gt; Element2d:</code>
            <code><span class="kw">def</span> getMesh(self) -&gt; Mesh2d:</code>
            <code><span class="kw">def</span> setElement(self, val: PyBr.Element2d) -&gt; None:</code>
            <code><span class="kw">def</span> setMesh(self, val: PyBr.Mesh2d) -&gt; None:</code>
            <code><span class="kw">def</span> setMeshAndElement(self, val: PyBr.Element2d) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="MeshEntity">
        <details>
            <summary>class MeshEntity <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> brepChanged(self) -&gt; bool:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getEntityAssociated(self) -&gt; Entity:</code>
            <code><span class="kw">def</span> getValidationLevel(self) -&gt; ValidationLevel:</code>
            <code><span class="kw">def</span> isEqualTo(self, otherObject: PyRx.RxObject) -&gt; bool:</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool:</code>
            <code><span class="kw">def</span> setValidationLevel(self, val: PyBr.ValidationLevel) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="Node">
        <details>
            <summary>class Node <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getPoint(self) -&gt; PyGe.Point3d:</code>
        </details>
    </div>

    <div class="class" id="Relation">
        <details>
            <summary>class Relation <span class="tag">Class</span></summary>
            <code>kUnknown: ClassVar[Self]</code>
            <code>kOutside: ClassVar[Self]</code>
            <code>kInside: ClassVar[Self]</code>
            <code>kBoundary: ClassVar[Self]</code>
            <code>kCoincident: ClassVar[Self]</code>
            <code>kTangent: ClassVar[Self]</code>
            <code>kIntersect: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Shell">
        <details>
            <summary>class Shell <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getComplex(self) -&gt; Complex:</code>
            <code><span class="kw">def</span> getType(self) -&gt; ShellType:</code>
        </details>
    </div>

    <div class="class" id="ShellFaceTraverser">
        <details>
            <summary>class ShellFaceTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getFace(self) -&gt; Face:</code>
            <code><span class="kw">def</span> getShell(self) -&gt; Shell:</code>
            <code><span class="kw">def</span> setFace(self, val: PyBr.Face) -&gt; None:</code>
            <code><span class="kw">def</span> setShell(self, val: PyBr.Shell) -&gt; None:</code>
            <code><span class="kw">def</span> setShellAndFace(self, val: PyBr.Face) -&gt; None:</code>
            <code><span class="kw">def</span> setShellTraverser(self, val: PyBr.ComplexShellTraverser) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="ShellTraverser">
        <details>
            <summary>class ShellTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getBrep(self) -&gt; Brep:</code>
            <code><span class="kw">def</span> getShell(self) -&gt; Shell:</code>
            <code><span class="kw">def</span> getShells(self) -&gt; list[PyBr.Shell]:</code>
            <code><span class="kw">def</span> setBrep(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> setBrepAndShell(self, val: PyBr.Shell) -&gt; None:</code>
            <code><span class="kw">def</span> setShell(self, val: PyBr.Shell) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="ShellType">
        <details>
            <summary>class ShellType <span class="tag">Class</span></summary>
            <code>kShellUnclassified: ClassVar[Self]</code>
            <code>kShellExterior: ClassVar[Self]</code>
            <code>kShellInterior: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Traverser">
        <details>
            <summary>class Traverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__() -&gt; None:
    <span class="ds">Raises an exception.
This class cannot be instantiated from Python.</span></code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> brepChanged(self) -&gt; bool:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> done(self) -&gt; bool:</code>
            <code><span class="kw">def</span> getValidationLevel(self) -&gt; ValidationLevel:</code>
            <code><span class="kw">def</span> isEqualTo(self, otherObject: PyRx.RxObject) -&gt; bool:</code>
            <code><span class="kw">def</span> isNull(self) -&gt; bool:</code>
            <code><span class="kw">def</span> next(self) -&gt; None:</code>
            <code><span class="kw">def</span> restart(self) -&gt; None:</code>
            <code><span class="kw">def</span> setValidationLevel(self, val: PyBr.ValidationLevel) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="ValidationLevel">
        <details>
            <summary>class ValidationLevel <span class="tag">Class</span></summary>
            <code>kFullValidation: ClassVar[Self]</code>
            <code>kNoValidation: ClassVar[Self]</code>
        </details>
    </div>

    <div class="class" id="Vertex">
        <details>
            <summary>class Vertex <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getPoint(self) -&gt; PyGe.Point3d:</code>
        </details>
    </div>

    <div class="class" id="VertexEdgeTraverser">
        <details>
            <summary>class VertexEdgeTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getEdge(self) -&gt; Edge:</code>
            <code><span class="kw">def</span> getVertex(self) -&gt; PyBr.Vertex:</code>
            <code><span class="kw">def</span> setEdge(self, val: PyBr.Edge) -&gt; None:</code>
            <code><span class="kw">def</span> setVertex(self, val: PyBr.Vertex) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="VertexLoopTraverser">
        <details>
            <summary>class VertexLoopTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getLoop(self) -&gt; Loop:</code>
            <code><span class="kw">def</span> getVertex(self) -&gt; PyBr.Vertex:</code>
            <code><span class="kw">def</span> setLoop(self, val: PyBr.Loop) -&gt; None:</code>
            <code><span class="kw">def</span> setVertex(self, val: PyBr.Vertex) -&gt; None:</code>
            <code><span class="kw">def</span> setVertexAndLoop(self, val: PyBr.LoopVertexTraverser) -&gt; None:</code>
        </details>
    </div>

    <div class="class" id="VertexTraverser">
        <details>
            <summary>class VertexTraverser <span class="tag">Class</span></summary>
            <code><span class="kw">def</span> __init__(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> __reduce__(self) -&gt; Any:</code>
            <code><span class="kw">def</span> className() -&gt; str:</code>
            <code><span class="kw">def</span> desc() -&gt; PyRx.RxClass:
    <span class="ds">Returns a pointer to the AcRxClass object representing the specific class, or most recent
parent class explicitly registered with ObjectARX of either the pointer type used to invoke
it or the class qualifier used with it. (Remember that when a static member function is
invoked via a pointer, the pointer type, not the object type, determines which
implementation of the function is invoked.) When working with a pointer to an object and
the proper AcRxClass object for the class of the object pointed to is desired, the
AcRxObject::isA() function should be used, since it is a virtual non-static method and is
therefore not pointer type dependent. Caching the value of the pointer returned by this
method is acceptable, provided the application knows that the AcRxClass object pointed to
by the returned pointer was created by an ObjectARX application that will not be unloaded.</span></code>
            <code><span class="kw">def</span> getBrep(self) -&gt; Brep:</code>
            <code><span class="kw">def</span> getVertex(self) -&gt; PyBr.Vertex:</code>
            <code><span class="kw">def</span> getVertexs(self) -&gt; list[PyBr.Vertex]:</code>
            <code><span class="kw">def</span> setBrep(self, val: PyBr.Brep) -&gt; None:</code>
            <code><span class="kw">def</span> setBrepAndVertex(self, val: PyBr.Vertex) -&gt; None:</code>
            <code><span class="kw">def</span> setVertex(self, val: PyBr.Vertex) -&gt; None:</code>
        </details>
    </div>
</body>
</html>